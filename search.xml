<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JS特效]]></title>
    <url>%2F2017%2F09%2F07%2Fjs%E7%89%B9%E6%95%88%2F</url>
    <content type="text"><![CDATA[js特效元素隐藏消失 特效思路： 1.确定需要出现的div的和样式，为红色的div设置display:none 2.以通过id名的方式获取页面中对应的两个元素 3.为checkbox绑定鼠标进入事件onmouseover，在事件处理函数中将红色div的设置 dom对象.style.display = &quot;block&quot; 4..为checkbox绑定鼠标离开事件onmouseout，在事件处理函数中将红色div的设置 dom对象.style.display = &quot;none&quot; 代码演示 下拉菜单 特效思路： 1.写好html结构和样式，为要隐藏的子元素ul设置 display: none 2.为整个最外层元素设置鼠标进入事件，和鼠标离开事件，分别设置 dom对象.style.display = &quot;block&quot;和 dom对象.style.display = &quot;none&quot; 3.为 li 中的 a 标签设置 a:hover{background:aqua;} 代码演示 点击创建小方块 特效思路： 1.先初始化小方块的样式，宽高以及设置为绝对定位，创建一个颜色数组 arrColor= [&quot;red&quot;, &quot;yellow&quot;, &quot;blue&quot;, &quot;green&quot;] 2.创建一个空字符串用于拼接，进行for循环遍历var left = (i%10)*60+50; //left值的规律 var top = parseInt(i/10)*60+50;//top值的规律 rrColor[i%arrColor.length]//颜色的值 3.获取容器对象通过innerHTML插入到文档中 代码演示 基于jquery的手风琴特效 特效思路： 1.先布置静态结构和样式，获取全部h3标签，绑定鼠标点击事件，为当前h3添加背景为蓝色样式，移除其他兄弟h3.siblings元素的背景色样式 2.为所有h3标签绑定鼠标进入和离开事件，为下一个next元素进行show 显示和hide隐藏 1234//所用到的api函数on() addClass() removeClass() siblings() next() show() hide() //所用到事件click事件 mouseenter事件 mouseleave事件 代码演示 显示当前系统时间 特效思路： 1.利用内置对象Date中的一些api，特别注意要处理一下，getDay()所返回的星期数为0-6，0为星期日 2.封装一个小函数来补零，进行字符串拼接 3.通过setInterval间隔1s调用一次 代码演示 模拟时钟]]></content>
  </entry>
  <entry>
    <title><![CDATA[HTTP API 设计指南]]></title>
    <url>%2F2017%2F09%2F02%2FHTTP%20API%20%E8%AE%BE%E8%AE%A1%E6%8C%87%E5%8D%97%EF%BC%88%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86%EF%BC%89%2F</url>
    <content type="text"><![CDATA[HTTP API 设计指南（基础部分）隔离关注点设计时通过将请求和响应之间的不同部分隔离来让事情变得简单。保持简单的规则让我们能更关注在一些更大的更困难的问题上。 请求和响应将解决一个特定的资源或集合。使用路径（path）来表明身份，body来传输内容（content）还有头信息（header）来传递元数据（metadata）。查询参数同样可以用来传递头信息的内容，但头信息是首选，因为他们更灵活、更能传达不同的信息。 强制使用安全连接（Secure Connections）所有的访问API行为，都需要用 TLS 通过安全连接来访问。没有必要搞清或解释什么情况需要 TLS 什么情况不需要 TLS，直接强制任何访问都要通过 TLS。理想状态下，通过拒绝所有非 TLS 请求，不响应 http 或80端口的请求以避免任何不安全的数据交换。如果现实情况中无法这样做，可以返回403 Forbidden响应。 把非 TLS 的请求重定向(Redirect)至 TLS 连接是不明智的，这种含混/不好的客户端行为不会带来明显好处。依赖于重定向的客户端访问不仅会导致双倍的服务器负载，还会使 TLS 加密失去意义，因为在首次非 TLS 调用时，敏感信息就已经暴露出去了。 强制头信息 Accept 中提供版本号制定版本并在版本之间平缓过渡对于设计和维护一套API是个巨大的挑战。所以，最好在设计之初就使用一些方法来预防可能会遇到的问题。 为了避免API的变动导致用户使用中产生意外结果或调用失败，最好强制要求所有访问都需要指定版本号。请避免提供默认版本号，一旦提供，日后想要修改它会相当困难。 最适合放置版本号的位置是头信息(HTTP Headers)，在 Accept 段中使用自定义类型(content type)与其他元数据(metadata)一起提交。例如: 1Accept: application/vnd.heroku+json; version=3 支持Etag缓存在所有返回的响应中包含ETag头信息，用来标识资源的版本。这让用户对资源进行缓存处理成为可能，在后续的访问请求中把If-None-Match头信息设置为之前得到的ETag值，就可以侦测到已缓存的资源是否需要更新。 为内省而提供 Request-Id为每一个请求响应包含一个Request-Id字段，并使用UUID作为该值。通过在客户端、服务器或任何支持服务上记录该值，它能主我们提供一种机制来跟踪、诊断和调试请求。 通过请求中的范围（Range）拆分大的响应一个大的响应应该通过多个请求使用Range头信息来拆分，并指定如何取得。详细的请求和响应的头信息（header），状态码(status code)，范围(limit)，排序(ordering)和迭代(iteration)等，参考Heroku Platform API discussion of Ranges. HTTP API 设计指南（请求部分）前言这篇指南介绍描述了 HTTP+JSON API 的一种设计模式，最初摘录整理自 Heroku 平台的 API 设计指引 Heroku 平台 API 指引。 这篇指南除了详细介绍现有的 API 外，Heroku 将来新加入的内部 API 也会符合这种设计模式，我们希望非 Heroku 员工的API设计者也能感兴趣。 我们的目标是保持一致性，专注业务逻辑同时避免过度设计。我们一直试图找出一种良好的、一致的、显而易见的 API 设计方法，而并不是所谓的”最终/理想模式”。 我们假设你熟悉基本的 HTTP+JSON API 设计方法，所以本篇指南并不包含所有的 API 设计基础。 我们欢迎你为这篇指南做贡献。 返回合适的状态码为每一次的响应返回合适的HTTP状态码。 好的响应应该使用如下的状态码: 200: GET请求成功，及DELETE或PATCH同步请求完成，或者PUT同步更新一个已存在的资源 201: POST 同步请求完成，或者PUT同步创建一个新的资源 202: POST，PUT，DELETE，或PATCH请求接收，将被异步处理 206: GET 请求成功，但是只返回一部分，参考：上文中范围分页 使用身份认证（authentication）和授权（authorization）错误码时需要注意： 401 Unauthorized: 用户未认证，请求失败 403 Forbidden: 用户无权限访问该资源，请求失败 当用户请求错误时，提供合适的状态码可以提供额外的信息： 422 Unprocessable Entity: 请求被服务器正确解析，但是包含无效字段 429 Too Many Requests: 因为访问频繁，你已经被限制访问，稍后重试 500 Internal Server Error: 服务器错误，确认状态并报告问题 对于用户错误和服务器错误情况状态码，参考： HTTP response code spec 提供全部可用的资源提供全部可显现的资源 (例如： 这个对象的所有属性) ，当响应码为200或是201时返回所有可用资源，包含 PUT/PATCH 和 DELETE请求，例如: 123456789101112$ curl -X DELETE \ https://service.com/apps/1f9b/domains/0fd4HTTP/1.1 200 OKContent-Type: application/json;charset=utf-8...&#123; "created_at": "2012-01-01T12:00:00Z", "hostname": "subdomain.example.com", "id": "01234567-89ab-cdef-0123-456789abcdef", "updated_at": "2012-01-01T12:00:00Z"&#125; 当请求状态码为202时，不返回所有可用资源，例如： 1234567$ curl -X DELETE \ https://service.com/apps/1f9b/dynos/05bdHTTP/1.1 202 AcceptedContent-Type: application/json;charset=utf-8...&#123;&#125; 在请求的body体使用JSON格式数据在 PUT/PATCH/POST 请求的正文（request bodies）中使用JSON格式数据，而不是使用 form 表单形式的数据。这与我们使用JSON格式返回请求相对应，例如: 12345678910111213$ curl -X POST https://service.com/apps \ -H "Content-Type: application/json" \ -d '&#123;"name": "demoapp"&#125;'&#123; "id": "01234567-89ab-cdef-0123-456789abcdef", "name": "demoapp", "owner": &#123; "email": "username@example.com", "id": "01234567-89ab-cdef-0123-456789abcdef" &#125;, ...&#125; 使用统一的资源路径格式资源名（Resource names）使用复数形式为资源命名，除非这个资源在系统中是单例的 (例如，在大多数系统中，给定的用户帐户只有一个)。 这种方式保持了特定资源的统一性。 行为（Actions）好的末尾不需要为资源指定特殊的行为，但在特殊情况下，为某些资源指定行为却是必要的。为了描述清楚，在行为前加上一个标准的actions： 1/resources/:resource/actions/:action 例如： 1/runs/&#123;run_id&#125;/actions/stop 路径和属性要小写为了和域名命名规则保持一致，使用小写字母并用-分割路径名字，例如： 12service-api.com/usersservice-api.com/app-setups 属性也使用小写字母，但是属性名要用下划线_分割，以便在Javascript中省略引号。 例如： 1service_class: "first" 支持方便的无id间接引用在某些情况下，让用户提供ID去定位资源是不方便的。例如，一个用户想取得他在Heroku平台app信息，但是这个app的唯一标识是UUID。这种情况下，你应该支持接口通过名字和ID都能访问，例如: 123$ curl https://service.com/apps/&#123;app_id_or_name&#125;$ curl https://service.com/apps/97addcf0-c182$ curl https://service.com/apps/www-prod 不要只接受使用名字而放弃了使用id。 最小化路径嵌套在一些有父路径/子路径嵌套关系的资源数据模块中，路径可能有非常深的嵌套关系，例如: 1/orgs/&#123;org_id&#125;/apps/&#123;app_id&#125;/dynos/&#123;dyno_id&#125; 推荐在根(root)路径下指定资源来限制路径的嵌套深度。使用嵌套指定范围的资源。在上述例子中，dyno属于app，app属于org可以表示为： 12345/orgs/&#123;org_id&#125;/orgs/&#123;org_id&#125;/apps/apps/&#123;app_id&#125;/apps/&#123;app_id&#125;/dynos/dynos/&#123;dyno_id&#125; HTTP API 设计指南（响应部分）前言这篇指南介绍描述了 HTTP+JSON API 的一种设计模式，最初摘录整理自 Heroku 平台的 API 设计指引 Heroku 平台 API 指引。 这篇指南除了详细介绍现有的 API 外，Heroku 将来新加入的内部 API 也会符合这种设计模式，我们希望非 Heroku 员工的API设计者也能感兴趣。 我们的目标是保持一致性，专注业务逻辑同时避免过度设计。我们一直试图找出一种良好的、一致的、显而易见的 API 设计方法，而并不是所谓的”最终/理想模式”。 我们假设你熟悉基本的 HTTP+JSON API 设计方法，所以本篇指南并不包含所有的 API 设计基础。 我们欢迎你为这篇指南做贡献。 提供资源的(UU)ID在默认情况给每一个资源一个id属性。除非有更好的理由，否则请使用UUID。不要使用那种在服务器上或是资源中不是全局唯一的标识，尤其是自动增长的id。 生成小写的UUID格式 8-4-4-4-12，例如： 1"id": "01234567-89ab-cdef-0123-456789abcdef" 提供标准的时间戳为资源提供默认的创建时间 created_at 和更新时间 updated_at，例如: 123456&#123; ... "created_at": "2012-01-01T12:00:00Z", "updated_at": "2012-01-01T13:00:00Z", ...&#125; 有些资源不需要使用时间戳那么就忽略这两个字段。 使用UTC（世界标准时间）时间，用ISO8601进行格式化在接收和返回时都只使用UTC格式。ISO8601格式的数据，例如: 1"finished_at": "2012-01-01T12:00:00Z" 嵌套外键关系使用嵌套对象序列化外键关联，例如: 1234567&#123; "name": "service-production", "owner": &#123; "id": "5d8201b0..." &#125;, // ...&#125; 而不是像这样: 12345&#123; "name": "service-production", "owner_id": "5d8201b0...", ...&#125; 这种方式尽可能的把相关联的资源信息内联在一起，而不用改变资源的结构，或者引入更多的字段，例如: 123456789&#123; "name": "service-production", "owner": &#123; "id": "5d8201b0...", "name": "Alice", "email": "alice@heroku.com" &#125;, ...&#125; 生成结构化的错误响应错误的时，生成统一的、结构化的错误信息。包含一个机器可读的错误 id，一个人类能识别的错误信息（message），根据情况可以添加一个url来告诉客户端关于这个错误的更多信息以及如何去解决它，例如: 1HTTP/1.1 429 Too Many Requests 12345&#123; "id": "rate_limit", "message": "Account reached its API rate limit.", "url": "https://docs.service.com/rate-limits"&#125; 文档化客户端可能遇到的错误信息格式，以及这些可能的错误信息id。 显示频率限制状态客户端的访问速度限制可以维护服务器的良好状态，保证为其他客户端请求提供高性的服务。你可以使用token bucket algorithm技术量化请求限制。 为每一个带有RateLimit-Remaining响应头的请求，返回预留的请求tokens。 保证响应JSON最小化请求中多余的空格会增加响应大小，而且现在很多的HTTP客户端都会自己输出可读格式（”prettify”）的JSON。所以最好保证响应JSON最小化，例如： 1&#123;"beta":false,"email":"alice@heroku.com","id":"01234567-89ab-cdef-0123-456789abcdef","last_login":"2012-01-01T12:00:00Z","created_at":"2012-01-01T12:00:00Z","updated_at":"2012-01-01T12:00:00Z"&#125; 而不是这样： 12345678&#123; "beta": false, "email": "alice@heroku.com", "id": "01234567-89ab-cdef-0123-456789abcdef", "last_login": "2012-01-01T12:00:00Z", "created_at": "2012-01-01T12:00:00Z", "updated_at": "2012-01-01T12:00:00Z"&#125; 你可以提供可选的方式为客户端提供更详细可读的响应，使用查询参数（例如：?pretty=true）或者通过Accept头信息参数（例如：Accept: application/vnd.heroku+json; version=3; indent=4;） HTTP API 设计指南（结尾）前言这篇指南介绍描述了 HTTP+JSON API 的一种设计模式，最初摘录整理自 Heroku 平台的 API 设计指引 Heroku 平台 API 指引。 这篇指南除了详细介绍现有的 API 外，Heroku 将来新加入的内部 API 也会符合这种设计模式，我们希望非 Heroku 员工的API设计者也能感兴趣。 我们的目标是保持一致性，专注业务逻辑同时避免过度设计。我们一直试图找出一种良好的、一致的、显而易见的 API 设计方法，而并不是所谓的”最终/理想模式”。 我们假设你熟悉基本的 HTTP+JSON API 设计方法，所以本篇指南并不包含所有的 API 设计基础。 我们欢迎你为这篇指南做贡献。 提供机器可读的JSON模式提供一个机器可读的模式来恰当的表现你的API。使用prmd管理你的模式，并且确保用prmd verify验证是有效的。 提供人类可读的文档提供人类可读的文档让客户端开发人员可以理解你的API。 如果你用prmd创建了一个概要并且按上述要求描述，你可以为所有节点很容易的使用prmd doc生成Markdown文档。 除了节点信息，提供一个API概述信息: 验证授权，包含如何取得和如何使用token。API稳定及版本管理，包含如何选择所需要的版本。一般情况下的请求和响应的头信息。错误的序列化格式。不同编程语言客户端使用API的例子。 提供可执行的例子提供可执行的示例让用户可以直接在终端里面看到API的调用情况，最大程度的让这些示例可以简单的使用，以减少用户尝试使用API的工作量。例如: $ export TOKEN=… # acquire from dashboard$ curl -is https://$TOKEN@service.com/users如果你使用prmd生成Markdown文档，每个节点都会自动获取一些示例。 描述稳定性描述您的API的稳定性或是它在各种各样节点环境中的完备性和稳定性，例如：加上 原型版（prototype）/开发版（development）/产品版（production）等标记。 更多关于可能的稳定性和改变管理的方式，查看 Heroku API compatibility policy 一旦你的API宣布产品正式版本及稳定版本时，不要在当前API版本中做一些不兼容的改变。如果你需要，请创建一个新的版本的API。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Canvas实现的刮刮乐效果]]></title>
    <url>%2F2017%2F03%2F10%2FCanvas%E5%AE%9E%E7%8E%B0%E5%88%AE%E5%88%AE%E4%B9%90%E6%95%88%E6%9E%9C%2F</url>
    <content type="text"><![CDATA[使用canvas实现的简单刮刮乐效果 index.html 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;刮刮乐&lt;/title&gt; &lt;link rel="stylesheet" href="css/index.css"&gt;&lt;/head&gt;&lt;body&gt; &lt;canvas width="400" height="300"&gt;&lt;/canvas&gt; &lt;script src="js/index.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; index.css 12345678910body &#123; margin: 0; padding: 0; &#125;canvas &#123; border: 1px solid #ccc; background: #ccc; margin: 100px auto; display: block;&#125; index.js 12345678910111213141516171819202122232425262728293031var ctx = document.querySelector('canvas').getContext('2d')var img = new Image()img.onload = function () &#123; // 设置填充方案 var pat = ctx.createPattern(img, 'no-repeat') ctx.strokeStyle = pat //设置线的样式 （包括线宽，线帽，拐点） ctx.lineWidth = 25 ctx.lineCap = 'round' ctx.lineJoin = 'round' //设置一个阈值 var isDown = false //绑定鼠标按下事件 ctx.canvas.addEventListener('mousedown', function (e) &#123; ctx.moveTo(e.clientX - ctx.canvas.offsetLeft, e.clientY -ctx.canvas.offsetTop) isDown = true &#125;) //绑定鼠标移动事件 ctx.canvas.addEventListener('mousemove', function (e) &#123; if (isDown) &#123; ctx.lineTo(e.clientX - ctx.canvas.offsetLeft, e.clientY -ctx.canvas.offsetTop) ctx.stroke() &#125; &#125;) //绑定鼠标抬起事件 ctx.canvas.addEventListener('mouseup', function () &#123; isDown = false &#125;)&#125;/* 设置图片资源路径 */img.src = '../images/xiexie.png']]></content>
      <categories>
        <category>canvas</category>
      </categories>
      <tags>
        <tag>canvas</tag>
        <tag>刮刮乐</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Canvas相关知识]]></title>
    <url>%2F2017%2F03%2F10%2Fmycanvas%2F</url>
    <content type="text"><![CDATA[canvas 最早由Apple引入WebKit,用于Mac OS X 的 Dashboard,后来又在Safari和Google Chrome被实现。 基于 Gecko 1.8的浏览器,比如 Firefox 1.5, 同样支持这个元素。&lt;canvas&gt; 元素是WhatWG Web applications 1.0规范的一部分,也包含于HTML 5中。 什么是Canvas？ canvas 是一个 HTML5元素，中文翻译是画布，但是本事没有绘画的功能，需要通过javascript在上面绘制图像。 canvas是一个矩形区域，（算是内联可置换元素在chrome中display默认值为 inline），可以控制其中的每一像素默认大小是 300 * 150 ，浏览器在解析的时候会按图片进行处理 canvas 拥有多种绘制路径、矩形、圆形、字符以及添加图像的方法。 创建Canvas元素向 HTML5 页面添加 canvas 元素。规定元素的 id、宽度和高度：（在style标签中为其设置宽高属性也是起作用的但是并不推荐这么做） 1&lt;canvas id="myCanvas" width="600" height="400"&gt;&lt;/canvas&gt; Canvas坐标系 通过JavaScript来绘制 12345678&lt;!- 为了效果明显，加了一点样式 -&gt;&lt;style&gt; canvas&#123; border: 1px solid #ccc; margin: 0 auto; display: block; &#125;&lt;/style&gt; 12345678910/*获取元素*/var myCanvas = document.querySelector('#myCanvas')/*获取绘图工具（也可以叫做绘制环境）*/var context = myCanvas.getContext('2d')/*设置绘图的起始位置*/context.moveTo(100,100)/*绘制路径*/context.lineTo(200,200)/*描边*/context.stroke() Canvas的基本使用图形绘制需要理解些概念： 路径的概念 路径的绘制 描边 stroke() 填充 fill() 闭合路径 手动闭合 程序闭合 closePath() 填充规则(非零环绕) 开启新的路径 beginPath() 设置样式 画笔的状态 lineWidth 线宽，默认1px lineCap 线末端类型：(butt默认)、round、square lineJoin 相交线的拐点 miter(默认)、round、bevel strokeStyle 线的颜色 fillStyle 填充颜色 setLineDash() 设置虚线 getLineDash() 获取虚线宽度集合 lineDashOffset 设置虚线偏移量（负值向右偏移） 此处的坑 123456/*canvas所绘制的线条本质就是一定数量的默认大小为1px颜色为黑色的像素点的结合，以坐标的中心绘制,但浏览器无发显示0.5px，chrome处理方式是把把线宽扩大到2px但是，毕竟这并不是真正设置2px的线宽，所以做了将颜色变浅以示区分。解决方案：1. 当设置线宽为单数的时候，手动将其y轴方向进行0.5px的增减，换句话说就是把这条线放到浏览器能正常显示的像素格内，避免浏览器进行线条虚化操作。2. 将线宽设置为偶数，但要注意canvas线条位置的渲染方式，计算好真正想让线条出现的位置*/ 实例练习 绘制平行线不同颜色 1234567891011121314151617181920212223/*1.获取canvas元素*/ var canvas = document.querySelector('canvas'); /*2.获取绘制环境 （获取绘制工具）*/ /*content内容 context 上下文 */ var ctx = canvas.getContext('2d'); /*3.设置起始绘图的位置*/ ctx.moveTo(100,100); /*6.设置宽度*/ ctx.lineWidth = 10; /*4.绘制路径 */ ctx.lineTo(200,100); /*7. 设置描边的颜色*/ ctx.strokeStyle = 'red'; /*5.描边*/ ctx.stroke(); /*绿色*/ /*再次绘制的时候 会使用之前设置的样式 设置的样式最后的会生效*/ /*开启新路径*/ ctx.beginPath(); ctx.moveTo(100,200); ctx.lineTo(200,200); ctx.strokeStyle = 'green'; ctx.stroke(); 绘制一个三角形 12345678910111213141516var canvas = document.querySelector('canvas'); /*获取绘图工具*/ var ctx = canvas.getContext('2d'); /*3d目前还不支持*//*webgl*/ /*移动画笔*/ ctx.moveTo(100,100); ctx.lineTo(200,100); ctx.lineTo(200,200); ctx.lineWidth = 10; /*自动闭合*/ ctx.closePath(); // ctx.stroke(); ctx.strokeStyle = 'red'; ctx.stroke(); /*填充*/ ctx.fillStyle = 'orange'; ctx.fill(); 镂空的正方形 12345678910111213141516var canvas = document.querySelector('canvas'); /*获取绘图工具*/ var ctx = canvas.getContext('2d'); /*3d目前还不支持*//*webgl*/ /*移动画笔*/ ctx.moveTo(100,100); ctx.lineTo(200,100); ctx.lineTo(200,200); ctx.lineWidth = 10; /*自动闭合*/ ctx.closePath(); // ctx.stroke(); ctx.strokeStyle = 'red'; ctx.stroke(); /*填充*/ ctx.fillStyle = 'skyblue'; ctx.fill(); 线的两端样式 123456789101112131415161718192021222324var canvas = document.querySelector('canvas'); /*获取绘图工具*/ var ctx = canvas.getContext('2d'); /*3d目前还不支持*//*webgl*/ ctx.lineWidth = 10; ctx.moveTo(100,100); ctx.lineTo(200,100); ctx.strokeStyle = 'red'; ctx.lineCap = 'butt'; ctx.stroke(); ctx.beginPath(); ctx.moveTo(100,200); ctx.lineTo(200,200); ctx.strokeStyle = 'green'; ctx.lineCap = 'round'; ctx.stroke(); ctx.beginPath(); ctx.moveTo(100,300); ctx.lineTo(200,300); ctx.strokeStyle = 'skyblue'; ctx.lineCap = 'square'; ctx.stroke(); 线拐点的样式 123456789101112131415161718192021222324252627var canvas = document.querySelector('canvas'); /*获取绘图工具*/ var ctx = canvas.getContext('2d'); /*3d目前还不支持*//*webgl*/ ctx.lineWidth = 10; ctx.moveTo(100,100); ctx.lineTo(150,150); ctx.lineTo(200,100); ctx.strokeStyle = 'red'; ctx.lineJoin = 'miter'; ctx.stroke(); ctx.beginPath(); ctx.moveTo(100,200); ctx.lineTo(150,250); ctx.lineTo(200,200); ctx.strokeStyle = 'green'; ctx.lineJoin = 'round'; ctx.stroke(); ctx.beginPath(); ctx.moveTo(100,300); ctx.lineTo(150,350); ctx.lineTo(200,300); ctx.strokeStyle = 'pink'; ctx.lineJoin = 'bevel'; ctx.stroke(); 绘制渐变的线 1234567891011121314151617var canvas = document.querySelector('canvas'); /*获取绘图工具*/ var ctx = canvas.getContext('2d'); /*3d目前还不支持*//*webgl*/ /*1.从左到右*/ /*2.起始颜色 白色*/ /*3.结束颜色 红色*/ ctx.lineWidth = 10; for (var i = 0; i &lt; 255; i++) &#123; ctx.beginPath(); ctx.moveTo(99+i,100); ctx.lineTo(100+i,100); var g = 255 - i; var b = 255 - i; ctx.strokeStyle = 'rgb(255,'+g+','+b+')'; ctx.stroke(); &#125; 绘制虚线 12345678910111213141516171819202122232425262728293031323334353637383940var canvas = document.querySelector('canvas'); /*获取绘图工具*/ var ctx = canvas.getContext('2d'); /*3d目前还不支持*//*webgl*/ ctx.moveTo(100,100) ctx.lineTo(500,100) ctx.setLineDash([5]); console.log(ctx.getLineDash()); ctx.stroke(); ctx.beginPath(); ctx.moveTo(100,200); ctx.lineTo(500,200); /*绘制虚线的方法*/ /*传数组 设置虚线长度的*/ ctx.setLineDash([5,10]); /*如果是偶数个数设置 */ /*如果是奇数数个数设置 */ /*获取的不重复的一段*/ console.log(ctx.getLineDash()); ctx.stroke(); ctx.beginPath(); ctx.moveTo(100,300) ctx.lineTo(500,300) ctx.setLineDash([5,10,15]); console.log(ctx.getLineDash()); ctx.stroke();var canvas = document.querySelector('canvas'); /*获取绘图工具*/ var ctx = canvas.getContext('2d'); /*3d目前还不支持*//*webgl*/ ctx.moveTo(100,100); ctx.lineTo(500,100); /*绘制虚线的方法*/ /*传数组 设置虚线长度的*/ ctx.setLineDash([5,10,15]); /*如果是偶数个数设置 */ /*如果是奇数数个数设置 */ /*获取的不重复的一段*/ console.log(ctx.getLineDash()); ctx.stroke(); 绘制坐标系方法一 12345678910111213141516171819202122232425262728293031var canvas = document.querySelector('canvas'); /*获取绘图工具*/ var ctx = canvas.getContext('2d'); /*3d目前还不支持*//*webgl*/ /*1.确定间隔 20 */ var space = 20; /*2.计算原点*/ var width = ctx.canvas.width; var height = ctx.canvas.height; var x0 = 0 + space; var y0 = height - space; /*假设 箭头大小 8px*/ var arrowSize = 10; /*绘制x轴*/ ctx.moveTo(x0,y0); ctx.lineTo(width-space,y0); ctx.lineTo(width-space-arrowSize,y0+arrowSize/2); ctx.lineTo(width-space-arrowSize,y0-arrowSize/2); ctx.lineTo(width-space,y0); ctx.stroke(); ctx.fill(); /*绘制y轴*/ ctx.moveTo(x0,y0); ctx.lineTo(space,space); ctx.lineTo(space+arrowSize/2,space+arrowSize); ctx.lineTo(space-arrowSize/2,space+arrowSize); ctx.lineTo(space,space); ctx.stroke(); ctx.fill(); 方法二:面向对象方式 123456789101112131415161718192021222324252627282930313233343536var DrawAxis = function () &#123; /*绘图工具*/ this.ctx = document.querySelector('canvas').getContext('2d'); /*间距*/ this.space = 20; /*画布的尺寸*/ this.width = this.ctx.canvas.width; this.height = this.ctx.canvas.height; /*原点*/ this.x0 = this.space; this.y0 = this.height - this.space; /*箭头尺寸*/ this.arrowSize = 10; &#125; /*绘制方法*/ DrawAxis.prototype.draw = function () &#123; /*x轴*/ this.ctx.moveTo(this.x0,this.y0); this.ctx.lineTo(this.width-this.space,this.y0); this.ctx.lineTo(this.width-this.space-this.arrowSize,this.y0+this.arrowSize/2); this.ctx.lineTo(this.width-this.space-this.arrowSize,this.y0-this.arrowSize/2); this.ctx.lineTo(this.width-this.space,this.y0); this.ctx.stroke(); this.ctx.fill(); /*y轴*/ this.ctx.moveTo(this.x0,this.y0); this.ctx.lineTo(this.space,this.space); this.ctx.lineTo(this.space+this.arrowSize/2,this.space+this.arrowSize); this.ctx.lineTo(this.space-this.arrowSize/2,this.space+this.arrowSize); this.ctx.lineTo(this.space,this.space); this.ctx.stroke(); this.ctx.fill(); &#125; var drawAxis = new DrawAxis(); drawAxis.draw(); ​ 绘制坐标点 方法一 123456789101112131415161718192021var canvas = document.querySelector('canvas'); /*获取绘图工具*/ var ctx = canvas.getContext('2d'); /*3d目前还不支持*//*webgl*/ /*点坐标*/ var dotted = &#123; x: 200, y: 100 &#125; /*点大小*/ var edge = 8; /*画笔的起始位置*/ ctx.moveTo(dotted.x - edge / 2, dotted.y - edge / 2); ctx.lineTo(dotted.x + edge / 2, dotted.y - edge / 2); ctx.lineTo(dotted.x + edge / 2, dotted.y + edge / 2); ctx.lineTo(dotted.x - edge / 2, dotted.y + edge / 2); ctx.closePath(); ctx.fill(); 方法二：面向对象 12345678910111213141516171819var DrawDotted = function () &#123; this.ctx = document.querySelector('canvas').getContext('2d'); this.edge = 10; &#125; /*dotted 对象 x y 轴坐标*/ DrawDotted.prototype.draw = function (dotted) &#123; this.ctx.beginPath(); this.ctx.moveTo(dotted.x-this.edge/2,dotted.y-this.edge/2); this.ctx.lineTo(dotted.x+this.edge/2,dotted.y-this.edge/2); this.ctx.lineTo(dotted.x+this.edge/2,dotted.y+this.edge/2); this.ctx.lineTo(dotted.x-this.edge/2,dotted.y+this.edge/2); this.ctx.closePath(); this.ctx.fill(); &#125; var drawDotted = new DrawDotted(); drawDotted.draw(&#123;x:100,y:100&#125;); drawDotted.draw(&#123;x:100,y:200&#125;); drawDotted.draw(&#123;x:200,y:200&#125;); ​ 绘制折线图 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586/*假设一组 基于坐标轴的*/ var data = [ &#123;x: 100, y: 80&#125;, &#123;x: 200, y: 120&#125;, &#123;x: 300, y: 250&#125;, &#123;x: 400, y: 340&#125;, &#123;x: 500, y: 230&#125; ]; var LineChart = function () &#123; /*绘制工具*/ this.ctx = document.querySelector('canvas').getContext('2d'); /*坐标原点*/ this.space = 20; this.width = this.ctx.canvas.width; this.height = this.ctx.canvas.height; this.x0 = this.space; this.y0 = this.height - this.space; /*箭头大小*/ this.arrow = 10; /*点相关 点大小*/ this.edge = 10; &#125; /*初始化方法*/ LineChart.prototype.init = function (data) &#123; this.drawAxis(); this.drawDotted(data); &#125; /*绘制坐标轴*/ LineChart.prototype.drawAxis = function () &#123; /*X轴*/ this.ctx.moveTo(this.x0, this.y0); this.ctx.lineTo(this.width - this.space, this.y0); this.ctx.lineTo(this.width - this.space - this.arrow, this.y0 + this.arrow/2); this.ctx.lineTo(this.width - this.space - this.arrow, this.y0 - this.arrow/2); this.ctx.lineTo(this.width - this.space, this.y0); this.ctx.stroke(); this.ctx.fill(); /*Y轴*/ this.ctx.moveTo(this.x0, this.y0); this.ctx.lineTo(this.space, this.space); this.ctx.lineTo(this.space + this.arrow/2, this.space + this.arrow); this.ctx.lineTo(this.space - this.arrow/2, this.space + this.arrow); this.ctx.lineTo(this.space, this.space); this.ctx.stroke(); this.ctx.fill(); &#125; /*转换点坐标*/ LineChart.prototype.formatDot = function (data) &#123; var that = this; var canvasData = []; data.forEach(function(item,i)&#123; var cx = item.x + that.x0; var cy = that.y0 - item.y; canvasData.push(&#123;x:cx,y:cy&#125;); &#125;); return canvasData; &#125; /*绘制多个点*/ LineChart.prototype.drawDotted = function (data) &#123; var that = this; /*转换*/ var canvasData = this.formatDot(data); console.log(canvasData); canvasData.forEach(function (item, i) &#123; that.ctx.beginPath(); that.ctx.moveTo(item.x - that.edge /2 , item.y - that.edge/2); that.ctx.lineTo(item.x + that.edge /2 , item.y - that.edge/2); that.ctx.lineTo(item.x + that.edge /2 , item.y + that.edge/2); that.ctx.lineTo(item.x - that.edge /2 , item.y + that.edge/2); that.ctx.closePath(); that.ctx.fill(); that.ctx.beginPath(); if(i == 0)&#123; that.ctx.moveTo(that.x0,that.y0); &#125;else&#123; that.ctx.moveTo(canvasData[i-1].x,canvasData[i-1].y) &#125; that.ctx.lineTo(item.x,item.y); that.ctx.stroke(); &#125;); &#125; new LineChart().init(data); ​ 参考文档 w3school Canvas_API Canvas图形绘制矩形绘制 rect(x,y,w,h) 没有独立路径 strokeRect(x,y,w,h) 有独立路径，不影响别的绘制 fillRect(x,y,w,h) 有独立路径，不影响别的绘制 clearRect(x,y,w,h) 擦除矩形区域 圆弧绘制 弧度概念 arc() x 圆心横坐标 y 圆心纵坐标 r 半径 startAngle 开始角度 endAngle 结束角度 anticlockwise 是否逆时针方向绘制（默认false表示顺时针；true表示逆时针） 绘制文本 ctx.font = ‘微软雅黑’ 设置字体 strokeText() fillText(text,x,y,maxWidth) text 要绘制的文本 x,y 文本绘制的坐标（文本左下角） maxWidth 设置文本最大宽度，可选参数 ctx.textAlign文本水平对齐方式，相对绘制坐标来说的 left center right start 默认 end direction属性css(rtl ltr) start和end于此相关 如果是ltr,start和left表现一致 如果是rtl,start和right表现一致 ctx.textBaseline 设置基线（垂直对齐方式 ） top 文本的基线处于文本的正上方，并且有一段距离 middle 文本的基线处于文本的正中间 bottom 文本的基线处于文本的证下方，并且有一段距离 hanging 文本的基线处于文本的正上方，并且和文本粘合 alphabetic 默认值，基线处于文本的下方，并且穿过文字 ideographic 和bottom相似，但是不一样 measureText() 获取文本宽度obj.width 实例练习 绘制扇形 绘制圆角矩形 绘制圆 绘制饼图 做动画绘制图片 drawImage() 三个参数drawImage(img,x,y) img 图片对象、canvas对象、video对象 x,y 图片绘制的左上角 五个参数drawImage(img,x,y,w,h) img 图片对象、canvas对象、video对象 x,y 图片绘制的左上角 w,h 图片绘制尺寸设置(图片缩放，不是截取) 九个参数drawImage(img,x,y,w,h,x1,y1,w1,h1) img 图片对象、canvas对象、video对象 x,y,w,h 图片中的一个矩形区域 x1,y1,w1,h1 画布中的一个矩形区域 序列帧动画 绘制精灵图 动起来 控制边界 键盘控制 坐标变换 平移 移动画布的原点 translate(x,y) 参数表示移动目标点的坐标 缩放 scale(x,y) 参数表示宽高的缩放比例 旋转 rotate(angle) 参数表示旋转角度]]></content>
      <categories>
        <category>canvas</category>
      </categories>
      <tags>
        <tag>canvas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript Standard Style(JavaScript 标准编码风格)]]></title>
    <url>%2F2017%2F01%2F20%2FJavaScript%2BStandard%2BStyle(JavaScript%2B%E6%A0%87%E5%87%86%E7%BC%96%E7%A0%81%E9%A3%8E%E6%A0%BC)%2F</url>
    <content type="text"><![CDATA[让我们看一看 @feross 的 JavaScript 标准风格 ，这是一个流行的 JavaScript 风格指南。它可以帮助你减少团队之间的摩擦，增加程序员的幸福感。 这是 一组规则 ，可以使 JavaScript 代码更加一致 ，并且可以防止类似于 tabs缩进 和 空格缩进优缺点这一类无聊的话题讨论。你可以采用多种风格之一，并且与其他 （如 JSLint ， JSHint 和 ESLint ）是同一种类型的 JavaScript 检测器。 如果你还不知道什么是linter (检查工具)，或者为什么需要，请查看我们对 JavaScript 检查(Linting)工具的比较。 风格的重要性如果你已经从事编码工作有一段时间了的话，那你肯定会有一种自己喜欢的风格。当你成百上千次以特定的模式编写代码时，你会发现你的编码方式是令人愉悦的。突然间来了个人，开始把挂在行尾的大括号单起一行。你可能会发牢骚。深呼吸冷静思考一下，你放置括号的位置 或 关键字后加空格 不会让你的程序更加正确，这只是个人喜好。 每种编程语言都有一种主流编码风格，比如像 Python，官方提供的 风格指南 被认为是编写程序的正确方式。那么你是否还会继续讨厌缩进用4个空格的人呢？（注：Python 官方提供的风格指南，建议使用4个空格缩进）。 用主流风格进行编码将有助于你的程序更能适应语言的生态环境。您还会发现，如果您熟悉该语言的主流编码风格，并且一开始就同意这种编码风格，那么您可以更容易地为开源项目贡献代码，同样也更容易让其他人来为你的开源项目贡献代码。 JavaScript 没有官方的编码风格指南，或许 Douglas Crockford 的 The Good Parts 是一个实际上的标准。他的书（注：《JavaScript 语言精粹》）提供了一种编写可靠的方法来 JavaScript 程序，他强调了我们应该积极避免的某些特性。他发布了 JSLint 来支持这些观点，而其他的检查工具也紧随其后。大多数的检查工具是高度可配置的，让你选择最适合你自己的风格，并将其强加于别人或团队！JavaScript Standard Style(注：这个项目名，所以没翻译，意思为 JavaScript 标准编码风格) 则不同。你最喜欢的编码风格无关紧要，重要的是，任何选择都可以让每个人理解和合作。 采用 standard 编码风格意味着 代码清晰性和社区约定的重要性要高于个人的编码风格。这不一定适用于所有项目和开发文化，但是开放项目源码对于新手来说可能非常不适应。建立清晰的、自动的编码风格，满足贡献者期望可以使项目发展更健康。 如果你正在为自己编写一个程序，没有其他人需要为你做贡献，那就使用那些让你最快乐的工具和编码风格。当你在一个团队中工作时，你应该尽量减少摩擦，保持专业，不要因为小事而浪费太多的时间。 在介绍自己的风格之前，花点时间学习现有代码库的风格。 JavaScript Standard Style （JavaScript 标准编码风格） 使用两个空格 – 进行缩进 字符串使用单引号 – 需要转义的地方除外 不再有冗余的变量 – 这是导致 大量 bug 的源头! 无分号 – 这里有3篇文章说明不用分号的好处：文章1文章2文章3 行首不要以 (, [, or ` 开头 这是省略分号时唯一会造成问题的地方 – 工具里已加了自动检测！ [详情][4] 关键字后加空格if (condition) { ... } 函数名后加空格function name (arg) { ... } 坚持使用全等 === 摒弃 == 一但在需要检查 null || undefined 时可以使用 obj == null。 一定要处理 Node.js 中错误回调传递进来的 err 参数。 使用浏览器全局变量时加上 window 前缀 – document 和 navigator 除外 避免无意中使用到了这些命名看上去很普通的全局变量， open, length,event 还有 name。 请参阅 完整的规则列表 最有争议的规则无疑是不用分号。多年来人们一直认为，始终使用分号是避免错误的最佳实践，Crockford 做了很多工作来促进这一点，使用封号有很深的根源，在 C 语言里，分号是严格要求的，否则程序不会运行。 JavaScript Standard Style(JavaScript 标准编码风格) 改变了我的想法，不用分号的 JavaScript 非常好。 分号自动插入是 JavaScript 的一个特性，它可以减少噪点、简化程序，我从来没有遇到过由于缺少分号而导致的bug，我也不相信你会遇到。查看 JavaScript 中有必需使用分号的吗? 以了解更多。 并不是所有人都同意，forks semistandard 和 happiness 有点唱反调，强调使用分号。我发现这些 forks 有点伤感，因为它们错过忽略了整个标准的要点。 如果我不同意某条规则，可以改吗？ 不行。制定这套 standard 规范的目的就是让大家都不必再花时间浪费在无谓的代码风格之争上面了。关于缩进该用制表符还是空格这个问题已经争论了很久了，永远也没有答案。争论这个都可以把需求提前写完了。遵循 standard 规范，你就不用再犹豫了，毕竟不管怎样争论总归会选择一种风格的。希望大家也能在个人语义和普适价值上做一个权衡。 就我个人而言，我已经开始喜欢不使用分号的编码风格了，也许是因为需要编写 Ruby、Python 和 CoffeeScript 的缘故，这些都不使用分号的语法。无论什么原因，当看不到分号的时候，我发现程序更清晰了。 良好的程序层次结构程序员应该重视： 正确性 可读性 幸福感 高效率 事实证明，采用 JavaScript Standard Style(JavaScript 标准编码风格)，对以上每一条都有好处。 正确性在所有程序中使用的任何东西，都必须做你想要的，并且没有错误。 编码风格并不会使程序更正确，但是在发布之前，检查工具可以帮你捕获一些错误。 可读性作为一个专业的开发人员，除了提供一份能正常运行的程序代码之外，代码的可读性是最重要的。阅读和尝试理解程序比编写代码要花费更多的精力和时间，因此请为未来的自己和维护代码的其他人进行可读性优化。 清晰可预测的风格使代码更容易阅读和理解。 程序员的幸福感我喜欢 JavaScript Standard Style(JavaScript 标准编码风格) 的原因之一是，它把重点放在人而不是机器上。程序员的幸福感在这个列表中排名第三的唯一原因是团队合作中更需要可读性，功能代码的正确性应该放在我们自己的幸福感之前，这是毋庸置疑的。 你想享受生活，不是吗？如果你很快就能完成工作，而且你的工作又有趣，那不就是我们想要的享受生活吗？这在一定程度上就是我们生活的目的。你的生活会更加美好。 – Yukihiro Matsumoto （注：松本行弘是一位日本计算机科学家和程序员。他是Ruby程序设计语言的主要设计者和实现者。） 人生苦短，不能因个人偏好的不同而引起意见分歧，设定一个标准并后续推进不是更好吗？如果一个标准的编码风格能够避免团队之间的分歧和摩擦，那么你就会更快乐。 高效率列在最后，但并非最不重要。 如果你必须在这些要点上进行权衡，那么你应该更加重视代码正确性、可读性，并且使程序员对快速编写代码感到愉悦。 计算机处理速度很快。如果程序高效，那就没事了。如果您发现性能不佳，请花时间寻找性能瓶颈并使代码更高效。 人类处理问题的速度相对来说很慢。让事情变得更有效率对我们来说更有价值。采用一种标准编码风格的清晰性使您的代码能够更快地理解并贡献代码。花在分歧上的时间也少了很多，这是最受欢迎的。 实施 JavaScript Standard Style(JavaScript 标准编码风格)你可以不用任何工具就可以采用这个标准，只要通读一下 规则 就可以，特别注意哪些和你以前习惯不同的规则。尝试一个星期，看看你是否喜欢。如果你不是特别反感，那就用它吧！ 还有一个 npm 包，用于检查你的JavaScript代码。 1npm install standard --global 通过这个检测器，运行 standard 将执行目录中的所有 JavaScript 文件。 此外，还有所有常见的 文本编辑器插件 ，这里是如何在 Atom 中安装检测器。 12apm install linterapm install linter-js-standard 就我个人而言，当你正在输入代码的时候，自动打印风格警告提示会让你分心。如果你有同样的感觉，在你完成工作后，再来检查会更好。JavaScript 标准编码风格 命令也有一个自动修复某些风格错误的 flag，这可能会节省一些时间。 1standard --fix 采用 JavaScript Standard Style(JavaScript 标准编码风格)你应该采用 JavaScript Standard Style(JavaScript 标准编码风格) 吗？那么这完全取决于你。 如果你没有合适的风格指南，那就准备好面对分歧和冲突吧。 如果你已经完善了一套理想的规则，并希望在整个代码库中执行它，那么 ESLint 可能就是你最好的选择。 如果你不想浪费时间在无聊的语法细节上，那就请用JavaScript Standard Style(JavaScript 标准编码风格) 吧，欢迎评论说出你的想法。 原文链接：https://www.sitepoint.com/why-use-javascript-style-guide/]]></content>
      <categories>
        <category>标准编码风格</category>
      </categories>
      <tags>
        <tag>标准编码风格</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串的常用方法]]></title>
    <url>%2F2017%2F01%2F10%2F%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[字符串slice()截取方法(不会改变原字符串，返回新字符串) 字符串slice截取方法 MDN这样说 slice() 方法提取字符串中的一部分，并返回这个新的字符串。 写法112var str = 'The morning is upon us.';console.log(str.slice(2,5)); //returns 'e m' 表示从索引第2个字符开始，截取到索引为5的字符包含2，不包含5;[2，5); 写法2123var str1 = 'The morning is upon us.';var str2 = str1.slice(4,-1); //[4,-1) 表示从索引第4个字符开始，截取到最后一个字符 包含4，不包含-1;console.log(str2); //morning is upon us; 写法31234var str3 = 'The morning is upon us.';str3.slice(-3); // returns 'us.' 表示字符串从右往左数第三个字符截取到最后str3.slice(-3, -1); // returns 'us' 表示字符串从右往左数第三个字符截取到最后一个字符 [3,-1);str3.slice(0, -1); // returns 'The morning is upon us' [0，-1) 写法4123var str4 = 'The morning is upon us.';str4.slice(5, 6); //returns 'o'console.log(str4.slice(5, 2) === '');// true 返回空字符串 字符串substr()方法(不会改变原字符串，返回新字符串) 字符串substr方法 MDN这样说 substr() 方法返回字符串中从指定位置开始到指定长度的子字符串 12345语法str.substr(start[, length])参数start开始提取字符的位置。如果为负值，则被看作 strLength + start，其中 strLength 为字符串的长度（例如，如果 start 为 -3，则被看作 strLength-3）。参数length可选。提取的字符数。不填则默认截取到最后一个字符。 123456789var sstr1 = "abcdefghij";console.log("(1,2): " + sstr1.substr(1,2)); // (1,2): "bc" 表示从索引为1开始 截取2个字符console.log("(-3,2): " + sstr1.substr(-3,2)); // (-3,2): hi 表示从右往左数第三个开始截取 截取2个字符 （MDN说 如果 start 为 -3，则被看作 strLength-3）10-3=7 从索引为7的字符截取2个console.log("(-3): " + sstr1.substr(-3)); // (-3): hij 表示从右往左数第三个开始截取 截取到最后console.log("(1): " + sstr1.substr(1)); // (1): bcdefghij 表示从索引为1的数字开始 截取到最后console.log("(-10,2): " + sstr1.substr(-10,2)); // (1): ab 表示从索引为0的数字开始 截取到2个console.log("(-21, 2): " + sstr1.substr(-21,2)); // (-21, 2): ab 如果 start 为负值且 abs(start) 大于字符串的长度，则 substr 使用 0 作为开始提取的索引。表示从索引为0的位置截取2个字符//注 字符串substr方法 str.substr(start[, length]) 不支持负的 start 索引 有兼容问题 解决兼容问题见MDN 字符串substring()方法(不改变原字符串，返回新字符串) 字符串substring()方法 返回字符串两个索引之间（或到字符串末尾）的子串。 12345语法 str.substring(indexStart[, indexEnd])参数indexStart 一个 0 到字符串长度之间的整数。indexEnd可选。一个 0 到字符串长度之间的整数。 1234567891011121314151617181920var anyString = "Mozilla";// 输出 "Moz"console.log(anyString.substring(0,3)); //表示从索引为0截取到索引到3的字符串 [0，3）包含索引0 不包含索引3；console.log(anyString.substring(3,0)); // 如果 indexStart 大于 indexEnd，则 substring 的执行效果就像两个参数调换了一样。 所以输出结果同上；// 输出 "lla"console.log(anyString.substring(4,7)); //如果任一参数大于 stringName.length，则被当作 stringName.length。表示从索引为4截取到最后啦。console.log(anyString.substring(7,4)); // 如果 indexStart 大于 indexEnd，则 substring 的执行效果就像两个参数调换了一样。 所以输出结果同上；// 输出 "Mozill"console.log(anyString.substring(0,6)); //[0，6）；// 输出 "Mozilla"console.log(anyString.substring(0,7));//[0，7）console.log(anyString.substring(0,10));//如果任一参数大于 stringName.length，则被当作 stringName.length。//注 如果 indexStart 等于 indexEnd，substring 返回一个空字符串。// 如果省略 indexEnd，substring 提取字符一直到字符串末尾。// 如果任一参数小于 0 或为 NaN，则被当作 0。// 如果任一参数大于 stringName.length，则被当作 stringName.length。 字符串toUpperCase()方法(不改变原字符串，返回新字符串) toUpperCase 将调用该方法的字符串值转换为大写形式，并返回。toUpperCase 方法不影响字符串本身的值。 1console.log( "alphabet".toUpperCase()); // "ALPHABET" 字符串toLowerCase()方法(不改变原字符串，返回新字符串) 字符串toLowerCase() 将调用该方法的字符串值转为小写形式，并返回。 1console.log( "ALPHABET".toLowerCase() ); // "alphabet" 字符串split()方法(不改变原字符串，返回一个新字符串数组) split() 方法通过把字符串分割成子字符串来把一个 String 对象分割成一个字符串数组。 1234语法str.split([separator][, limit])separator 指定用来分割字符串的字符（串）。limit一个整数，限定返回的分割片段数量。split 方法仍然分割每一个匹配的 separator，但是返回的数组只会截取最多 limit 个元素。 12345var myString = "Hello World. How are you doing?";var splits = myString.split(""); //如果 separator 是一个空字符串，则 str 将被转换为由字符串中字符组成的一个数组。console.log(splits); //返回结果["H", "e", "l", "l", "o", " ", "W", "o", "r", "l", "d", ".", " ", "H", "o", "w", " ", "a", "r", "e", " ", "y", "o", "u", " ", "d", "o", "i", "n", "g", "?"] 用心去体会console.log(myString.split()) // 如果忽略 separator，则返回整个字符串的数组形式。 ["Hello World. How are you doing?"]console.log(myString.split(" ")); // 当找到一个 seperator 时，separator 会从字符串中被移除，返回存进一个数组当中的子字符串。["Hello", "World.", "How", "are", "you", "doing?"] 说白了separator就是分割元素； 字符串indexOf() 方法(不改变原字符串，返回一个number类型的值) indexOf() 方法返回指定值在字符串对象中首次出现的位置。从 fromIndex 位置开始查找，如果不存在，则返回 -1。 12345678语法 str.indexOf(searchValue[, fromIndex])参数searchValue一个字符串表示被查找的值。fromIndex 可选表示调用该方法的字符串中开始查找的位置。可以是任意整数。默认值为 0。如果 fromIndex &lt; 0 则查找整个字符串（如同传进了 0）。如果 fromIndex &gt;= str.length，则该方法返回 -1，除非被查找的字符串是一个空字符串，此时返回 str.length。描述字符串中的字符被从左向右索引。首字符的索引（index）为 0，字符串 stringName 的最后一个字符的索引是 stringName.length - 1。 1234567"Blue Whale".indexOf("Blue"); // returns 0"Blue Whale".indexOf("Blute"); // returns -1"Blue Whale".indexOf("Blute"); // returns -1"Blue Whale".indexOf("Whale", 5); // returns 5"Blue Whale".indexOf("", 9); // returns 9"Blue Whale".indexOf("", 10); // returns 10"Blue Whale".indexOf("", 11); // returns 10 字符串charAt()方法(不改变原字符串，返回一个字符) 语法 str.charAt(index) charAt() 方法返回字符串中指定位置的字符。 123456789101112131415var anyString = "Brave new world";console.log("The character at index 0 is '" + anyString.charAt(0) + "'");console.log("The character at index 1 is '" + anyString.charAt(1) + "'");console.log("The character at index 2 is '" + anyString.charAt(2) + "'");console.log("The character at index 3 is '" + anyString.charAt(3) + "'");console.log("The character at index 4 is '" + anyString.charAt(4) + "'");console.log("The character at index 999 is '" + anyString.charAt(999) + "'");//上面代码的输出为：// The character at index 0 is 'B'// The character at index 1 is 'r'// The character at index 2 is 'a'// The character at index 3 is 'v'// The character at index 4 is 'e'// The character at index 999 is '' 一个简单应用已知有字符串foo=“get-element-by-id”,写一个function将其转化成驼峰表示法“getElementById”。 12345678910111213var foo = 'get-element-by-id'console.log(createCamel(foo))function createCamel(str) &#123; var arr = str.split('-') var str2 = '' for (var i = 0; i &lt; arr.length; i++) &#123; if (i) &#123; arr[i] = arr[i].charAt(0).toUpperCase()+arr[i].substring(1) &#125; str2 += arr[i] &#125; return str2;&#125;]]></content>
      <categories>
        <category>字符串方法</category>
      </categories>
      <tags>
        <tag>字符串方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[白话原型和原型链]]></title>
    <url>%2F2017%2F01%2F10%2F%E7%99%BD%E8%AF%9D%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE%2F</url>
    <content type="text"><![CDATA[关于原型和原型链的介绍，网上数不胜数，但能讲清楚这两个概念的很少，大多数都是介绍各种对象、属性之间如何指来指去，最后的结果就是箭头满天飞，大脑一团糟。本文将从这两个概念的命名入手，用通俗易懂的语言，帮助你理解这两个东西到底是何方神圣。 一. 背景知识JavaScript和Java、C++等传统面向对象的编程语言不同，它是没有类（class）的概念的（ES6 中的class也只不过是语法糖，并非真正意义上的类），而在JavaScript中，一切皆是对象（object）。在基于类的传统面向对象的编程语言中，对象由类实例化而来，实例化的过程中，类的属性和方法会拷贝到这个对象中；对象的继承实际上是类的继承，在定义子类继承于父类时，子类会将父类的属性和方法拷贝到自身当中。因此，这类语言中，对象创建和继承行为都是通过拷贝完成的。但在JavaScript中，对象的创建、对象的继承（更好的叫法是对象的代理，因为它并不是传统意义上的继承）是不存在拷贝行为的。现在让我们忘掉类、忘掉继承，这一切都不属于JavaScript。 二. 原型和原型链其实，原型这个名字本身就很容易产生误解，原型在百度词条中的释义是：指原来的类型或模型。按照这个定义解释的话，对象的原型是对象创建自身的模子，模子具备的特点对象都要具有，这俨然就是拷贝的概念。我们已经说过， JavaScript的对象创建不存在拷贝，对象的原型实际上也是一个对象，它和对象本身是完全独立的两个对象。既然如此，原型存在的意义又是什么呢？原型是为了共享多个对象之间的一些共有特性（属性或方法），这个功能也是任何一门面向对象的编程语言必须具备的。A、B两个对象的原型相同，那么它们必然有一些相同的特征。 JavaScript中的对象，都有一个内置属性[[Prototype]]，指向这个对象的原型对象。当查找一个属性或方法时，如果在当前对象中找不到定义，会继续在当前对象的原型对象中查找；如果原型对象中依然没有找到，会继续在原型对象的原型中查找（原型也是对象，也有它自己的原型）；如此继续，直到找到为止，或者查找到最顶层的原型对象中也没有找到，就结束查找，返回undefined。可以看出，这个查找过程是一个链式的查找，每个对象都有一个到它自身原型对象的链接，这些链接组件的整个链条就是原型链。拥有相同原型的多个对象，他们的共同特征正是通过这种查找模式体现出来的。 在上面的查找过程，我们提到了最顶层的原型对象，这个对象就是Object.prototype，这个对象中保存了最常用的方法，如toString、valueOf、hasOwnProperty等，因此我们才能在任何对象中使用这些方法。 1.字面量方式当通过字面量方式创建对象时，它的原型就是Object.prototype。虽然我们无法直接访问内置属性[[Prototype]]，但我们可以通过Object.getPrototypeOf()或对象的__proto__（不是标准属性，但几乎所有浏览器都实现了该属性）获取对象的原型。123var obj = &#123;&#125;;Object.getPrototypeOf(obj) === Object.prototype; // trueobj.__proto__ === Object.prototype; // true 2.函数的构造调用通过函数的构造调用（注意，我们不把它叫做构造函数，因为JavaScript中同样没有构造函数的概念，所有的函数都是平等的，只不过用来创建对象时，函数的调用方式不同而已）也是一种常用的创建对象的方式。基于同一个函数创建出来的对象，理应可以共享一些相同的属性或方法，但这些属性或方法如果放在Object.prototype里，那么所有的对象都可以使用它们了，作用域太大，显然不合适。于是，JavaScript在定义一个函数时，同时为这个函数定义了一个 默认的prototype属性，所有共享的属性或方法，都放到这个属性所指向的对象中。由此看出，通过一个函数的构造调用创建的对象，它的原型就是这个函数的prototype指向的对象。12345var f = function(name) &#123; this.name = name &#125;;f.prototype.getName = function() &#123; return this.name; &#125; //在prototype下存放所有对象的共享方法var obj = new f('JavaScript');obj.getName(); // JavaScriptobj.__proto__ === f.prototype; // true 3.Object.create（）第三种常用的创建对象的方式是使用Object.create()。这个方法会以你传入的对象作为创建出来的对象的原型。123var obj = &#123;&#125;;var obj2 = Object.create(obj);obj2.__proto__ === obj; // true 这种方式还可以模拟对象的“继承”行为。1234567891011121314151617181920212223242526272829function Foo(name) &#123; this.name = name;&#125;Foo.prototype.myName = function() &#123; return this.name;&#125;;function Bar(name,label) &#123; Foo.call( this, name ); // this.label = label;&#125;// temp对象的原型是Foo.prototypevar temp = Object.create( Foo.prototype ); // 通过new Bar() 创建的对象，其原型是temp, 而temp的原型是Foo.prototype，// 从而两个原型对象Bar.prototype和Foo.prototype 有了"继承"关系Bar.prototype = temp;Bar.prototype.myLabel = function() &#123; return this.label;&#125;;var a = new Bar( "a", "obj a" );a.myName(); // "a"a.myLabel(); // "obj a"a.__proto__.__proto__ === Foo.prototype; //true 三. __proto__和prototype这是容易混淆的两个属性。__proto__指向当前对象的原型，prototype是函数才具有的属性，默认情况下，new 一个函数创建出的对象，其原型都指向这个函数的prototype属性。 四. 三种特殊情况1.对于JavaScript中的内置对象，如String、Number、Array、Object、Function等，因为他们是native代码实现的，他们的原型打印出来都是ƒ () { [native code] }。 2.内置对象本质上也是函数，所以可以通过他们创建对象，创建出的对象的原型指向对应内置对象的prototype属性，最顶层的原型对象依然指向Object.prototype。1234567891011121314151617'abc'.__proto__ === String.prototype; // true new String('abc').__proto__ === String.prototype; //truenew Number(1).__proto__ ==== Number.prototype; // true[1,2,3].__proto__ === Array.prototype; // truenew Array(1,2,3).__proto__ === Array.prototype; // truevar obj = &#123;&#125;;obj.__proto__ === Object.prototype; // true (再次印证字面量创建的对象原型是Object.prototype)&#123;&#125;.__proto__ === Object.prototype; //chrome下报错，谁知道原因的告诉声new Object(&#123;&#125;).__proto__ === Object.prototype; // truevar f = function() &#123;&#125;;f.__proto__ === Function.prototype; // truevar f = new Function('&#123;&#125;');f.__proto__ === Function.prototype; // true 3.Object.create(null) 创建出的对象，不存在原型。12var a = Object.create(null); a.__proto__; // undefined 此外，函数的prototype中还有一个constructor方法，建议大家就当它不存在，它的存在让JavaScript原型的概念变得更加混乱，而且这个方法也几乎没有作用。]]></content>
      <categories>
        <category>原型</category>
      </categories>
      <tags>
        <tag>prototype</tag>
        <tag>原型链</tag>
        <tag>原型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript对字符串进行加密(自定义简单版)]]></title>
    <url>%2F2017%2F01%2F10%2FJavaScript%E5%AF%B9%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BF%9B%E8%A1%8C%E5%8A%A0%E5%AF%86(%E8%87%AA%E5%AE%9A%E4%B9%89%E7%AE%80%E5%8D%95%E7%89%88)%2F</url>
    <content type="text"><![CDATA[原理就是先把字符串通过charCodeAt()方法转化成对应的unicode，再把unicode统一减去100（任意数值，这里去值为100），把得到的unicode码通过String.fromCharCode()方法转换成对应的字符，代码如下： index.html123456789101112131415&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;字符串加密&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;input type="text"/&gt; &lt;input type="button" value="加密"&gt; &lt;div id="txt"&gt;加密/解密的结果显示区域~&lt;/div&gt; &lt;input type="text"/&gt; &lt;input type="button" value="解密"&gt; &lt;script src="js/index.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; index.js 12345678910111213141516171819202122232425window.onload=function()&#123; //获取dom元素 var aIpt = document.getElementsByTagName('input'); var oDiv = document.getElementById('txt'); //注册点击加密事件 aIpt[1].onclick = function()&#123; var txtVal = aIpt[0].value; var str = ""; console.log(txtVal); for(var i=0;i&lt;txtVal.length;i++)&#123; str += String.fromCharCode(txtVal.charCodeAt(i)-100); &#125; oDiv.innerHTML = str; &#125; //注册点击解密事件 aIpt[3].onclick=function () &#123; var txtVal = aIpt[2].value; var str = ""; console.log(txtVal); for (var i = 0; i &lt; txtVal.length; i++) &#123; str += String.fromCharCode(txtVal.charCodeAt(i)+100); &#125; oDiv.innerHTML = str; &#125;&#125;]]></content>
      <categories>
        <category>加密</category>
      </categories>
      <tags>
        <tag>字符串加密</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用SVG + CSS实现动态霓虹灯文字效果]]></title>
    <url>%2F2017%2F01%2F01%2F%E4%BD%BF%E7%94%A8SVG%20%2B%20CSS%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81%E9%9C%93%E8%99%B9%E7%81%AF%E6%96%87%E5%AD%97%E6%95%88%E6%9E%9C%2F</url>
    <content type="text"><![CDATA[早上无意间进入一个网站，看到他们的LOGO效果略屌，如图： 刚开始以为是gif动画之类的，审查元素发现居然是用SVG + CSS3动画实现的，顿时激起了我的(hao)欲(qi)望(xin)，决定要一探究竟，查看代码之后，发现原理居然是如此简单：多个SVG描边动画使用不同的animation-delay即可！ 对于一个形状SVG元素或文本SVG元素，可以使用stroke-dasharray来控制描边的间隔样式，并且可以用stroke-dashoffset来控制描边的偏移量，借此可以实现描边动画效果，更具体的资料可以看看张大神的《纯CSS实现帅气的SVG路径描边动画效果》 我们先实现一个简单的文字描边动画： 12345&lt;svg width="100%" height="100"&gt; &lt;text text-anchor="middle" x="50%" y="50%" class="text"&gt; segmentfault.com &lt;/text&gt;&lt;/svg&gt; 123456789101112131415.text&#123; font-size: 64px; font-weight: bold; text-transform: uppercase; fill: none; stroke: #3498db; stroke-width: 2px; stroke-dasharray: 90 310; animation: stroke 6s infinite linear;&#125;@keyframes stroke &#123; 100% &#123; stroke-dashoffset: -400; &#125;&#125; 演示地址：http://output.jsbin.com/demic… 然后我们同时使用多个描边动画，并设置不同的animation-delay： 1234567891011121314&lt;svg width="100%" height="100"&gt; &lt;text text-anchor="middle" x="50%" y="50%" class="text text-1"&gt; segmentfault.com &lt;/text&gt; &lt;text text-anchor="middle" x="50%" y="50%" class="text text-2"&gt; segmentfault.com &lt;/text&gt; &lt;text text-anchor="middle" x="50%" y="50%" class="text text-3"&gt; segmentfault.com &lt;/text&gt; &lt;text text-anchor="middle" x="50%" y="50%" class="text text-4"&gt; segmentfault.com &lt;/text&gt;&lt;/svg&gt; 注意：要使用多少种颜色，就放多少个text 1234567891011121314151617181920212223242526272829303132333435.text&#123; font-size: 64px; font-weight: bold; text-transform: uppercase; fill: none; stroke-width: 2px; stroke-dasharray: 90 310; animation: stroke 6s infinite linear;&#125;.text-1&#123; stroke: #3498db; text-shadow: 0 0 5px #3498db; animation-delay: -1.5s;&#125;.text-2&#123; stroke: #f39c12; text-shadow: 0 0 5px #f39c12; animation-delay: -3s;&#125;.text-3&#123; stroke: #e74c3c; text-shadow: 0 0 5px #e74c3c; animation-delay: -4.5s;&#125;.text-4&#123; stroke: #9b59b6; text-shadow: 0 0 5px #9b59b6; animation-delay: -6s;&#125;@keyframes stroke &#123; 100% &#123; stroke-dashoffset: -400; &#125;&#125; 大功告成，演示地址：http://output.jsbin.com/vuyuv… 需要注意的几个点： 各个元素的animation-delay与animation的总时长的设置要协调 stroke-dashoffset与stroke-dasharray的设置要协调]]></content>
      <categories>
        <category>css案例</category>
      </categories>
      <tags>
        <tag>霓虹灯效果</tag>
        <tag>svg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript基础知识（上篇）]]></title>
    <url>%2F2016%2F06%2F12%2FJS%E5%9F%BA%E7%A1%80(%E4%B8%8A%E7%AF%87)%2F</url>
    <content type="text"><![CDATA[JS前置知识浏览器以及网站相关介绍 浏览器定义：可以显示网页服务器或者文件系统的HTML文件内容，并让用户与这些文件交互的一种软件 我们常规使用的五大浏览器：chorme，firefox，IE，Safari以及Oprea 从内核来看：有webkit，gecko，trident，presto 1、Trident内核代表产品Internet Explorer，又称其为IE内核。Trident（又称为MSHTML），是微软开发的一种排版引擎。使用Trident渲染引擎的浏览器包括：IE、傲游、世界之窗浏览器、Avant、腾讯TT、Netscape 8、NetCaptor、Sleipnir、GOSURF、GreenBrowser和KKman等。 2、Gecko内核代表作品Mozilla FirefoxGecko是一套开放源代码的、以C++编写的网页排版引擎。Gecko是最流行的排版引擎之一，仅次于Trident。使用它的最著名浏览器有Firefox、Netscape6至9。 3、WebKit内核代表作品Safari、Chromewebkit 是一个开源项目，包含了来自KDE项目和苹果公司的一些组件，主要用于Mac OS系统，它的特点在于源码结构清晰、渲染速度极快。缺点是对网页代码的兼容性不高，导致一些编写不标准的网页无法正常显示。主要代表作品有Safari和Google的浏览器Chrome。 4、Presto内核代表作品OperaPresto是由Opera Software开发的浏览器排版引擎，供Opera 7.0及以上使用。它取代了旧版Opera 4至6版本使用的Elektra排版引擎，包括加入动态功能，例如网页或其部分可随着DOM及Script语法的事件而重新排版。 各主流浏览器内核介绍 了解四大主流浏览器内核 主流浏览器内核介绍 1浏览器工作原理的介绍 说明： 1、User Interface 用户界面，我们所看到的浏览器 2、Browser engine 浏览器引擎，用来查询和操作渲染引擎 3、Rendering engine 用来显示请求的内容，负责解析HTML、CSS 4、Networking 网络，负责发送网络请求 5、JavaScript Interpreter(解析者) JavaScript解析器，负责执行JavaScript的代码 6、UI Backend UI后端，用来绘制类似组合框和弹出窗口 7、Data Persistence(持久化) 数据持久化，数据存储 cookie、HTML5中的sessionStorage 2网站工作原理的简单介绍 为什么要有js？js设计的最初目的 - 判断客户端表单输入验证(以前的网速慢) - 后来被一度用于小广告 js现在的意义 -页面特效（pc端的网页特效） -移动端（移动web和app） -异步和服务器交互 ajax -服务器端开发（nodeJs） -数据库甚至烤面包机都可以运行js了 （mongodb 嵌入式开发） js的历史总结： -javascript诞生于1995年 -javascript的是由网景公司的布兰登艾奇开发的 -javascript的前名叫livescript 什么是JS语言？ javascript是一种运行在客户端 的脚本语言 客户端：即接受服务的一端，与服务端相对应，在前端开发中，通常客户端指的就是浏览器。 脚本语言：也叫解释型语言，特点是执行一行，解释一行，如果发现报错，代码就停止执行 。 tips：脚本语言一般会有一个宿主环境（当前脚本运行并且起作用一个环境） 类似的有：as（actionScript flash宿主环境） javascript的三个组成部分：ECMAScript、BOM、DOM ECMAScript：定义了javascript的语法规范，是js语法的基础核心。 BOM：定义一套操作浏览器功能的API，通过这些api能够更好的操作浏览器行为。 DOM：定义一套操作页面元素的API，通过使用这些api来操作页面元素。 script标签 书写Javascript代码有三种方式，第一种是直接在script标签中书写，第二种是将代码写在js文件中，通过script进行引入。第三种为内嵌入html结构中书写js，但不利于后期代码开发和维护，不推荐； 直接在script中书写javascript代码： 123&lt;script&gt; alert("今天天气真好呀");&lt;/script&gt; 通过script标签引入一个JS文件，需要指定src属性 1&lt;script src="test.js"&gt;&lt;/script&gt; 通过在html标签中内嵌入html结构执行(但这种方式并不推荐 不利于后期代码开发和维护) 1&lt;div onclick="alert('今天天气不错！')"&gt;&lt;/div&gt; tips：如果script标签指定了src属性，说明是想要引入一个js文件，这个时候不能继续在script标签中写JS代码，即便写了，也不会执行。 script标签的书写位置，原则上来说，可以在页面中的任意位置书写script标签。 写在head标签中，style标签之后。 写在&lt;//body&gt;标签的前面。 写在的后面，即页面的最后面。 script的一些属性 1&lt;script language=JavaScript type="text/javascript"&gt; language已废弃,用于说明代码使用的脚本语言 src 表示要引入的外部文件 type 表示脚本语言的类型(type=”text/javascript” 在html5的结构可以省略不写) async(了解) async=”async” 值可以省略，立即异步下载外部JS下载完毕立即执行 defer(了解) defer=”defer” 值可以省略，脚本延迟到文档完全被解析和显示后再执行 1234&lt;script src="myJs.js" async="async"&gt;&lt;/script&gt;&lt;!--async立即异步下载外部JS,JS下载完毕立即执行--&gt;&lt;!--defer立即异步下载外部JS,JS下载完毕延迟到最后执行--&gt;&lt;!--这两个属性可以省略属性值--&gt; 输入输出语句 在实际开发，常用1和3，并且1在控制台输出不影响页面正常显示，不会阻塞代码运行，灵活操作，在实际开发中用于代码调试较多。 console.log 控制台输出日志 document.write 往页面中写入内容 alert 弹框警告[^注释] confirm 确认框[^注释] prompt 输入框[^注释] 1234567console.log("内容");//在控制台打印输出内容document.write("内容");//在页面书写内容alert("内容");//弹窗显示内容console.warn("警告框 一般系统在使用");console.error("错误提示信息，一般系统在使用");console.info("输出信息");confirm("请回答是或者否"); [^注释]: window 是全局对象 是浏览器中的顶级对象 window.alert()中的window 可以省略不写 注释 不被程序执行的代码。用于程序员标记代码，在后期的修改，以及他人的学习时有所帮助，在JS中，分为单行注释和多行注释 1234//这是单行注释，只能注释一行/* 这是多行注释，不能嵌套*/ 注释的作用： 1. 模块划分，方便代码查找和维护 2. 用于解释复杂代码的逻辑，方便维护和后期开发。 永无bug.js 变量 什么是变量变量是计算机内存中存储数据的标识符，根据变量名称可以获取到内存中存储的数据 为什么要使用变量使用变量可以方便的获取或者修改内存中的数据 如何使用变量 var声明变量 1var age; //声明未赋值 其值为未定义undefined 变量的赋值 12var age;age = 18; 同时声明多个变量 123var age, name, sex;age = 10;name = 'zs'; 同时声明多个变量并赋值 1var age = 10, name = 'zs'; 变量在内存中的存储后续通过交换值变量来演示 变量的命名规则与规范1234567命名规则（必须遵守）：1.由字母、数字、下划线、$符号组成，开头不能是数字。2.不能是关键字和保留字3.区分大小写命名规范（建议遵守）：1. 命名要有意义2. 遵守驼峰命名法。首字母小写，后面单词的首字母需要大写。 1var userName; var borderTopColor; 变量练习第一种方式：普通临时变量交换方式12345678910/* 适用性: 适用于所有类型 简要说明: 这是用到的最广泛的一种方式，经实战测试分析，性能也很高 (在JS中,这种方式效率确实很高，而且就算是其它语言中，只要tmp变量提前创建，性能也不会很低，反而是一些杂技派和少数派性能方面很低) 基本上可以说: 经典的才是最优雅的*/tmp = aa = bb = tmp 第二种:利用一个新的对象来进行数据交换12345678/* 适用性: 适用于所有类型 简要说明:这种方式在实战中应用的很少*/a = &#123;a : b, b : a&#125;b = a.ba = a.a 第三种:利用一个新的数组来进行数据交换123456/* 适用性: 适用于所有类型 简要说明:这种方式在各大论坛中都有看到有人使用，但经测试实际性能并不高*/a = [b, b=a][0] 第四种:利用数组交换变量(需EJS支持)123456/* 适用性: 适用于所有类型 简要说明:这也是在ES6出来后看到有人用的，实际在现有的浏览器中测试，性能很低*/[a, b] = [b, a] 第五种:利用try catch交换123456789/* 适用性: 适用于所有类型 简要说明:这种方法应该是基本没人使用的，也没有什么实用性，而且性能也是属于在各种方法中垫底的*/a=(function()&#123; try&#123;return b&#125; finally&#123;b=a&#125;&#125;)() 第六种:异或操作交换变量第一种方式123456/* 适用性: 适用于数字或字符串 简要说明:异或方法在数字或字符串时用到的比较普遍，而且性能也不低*/a = (b = (a ^= b) ^ b) ^ a 第七种:异或操作交换变量第二种方式12345678/* 适用性: 适用于数字或字符串 简要说明:异或方法在数字或字符串时用到的比较普遍，而且性能也不低*/a ^=bb ^=aa ^=b 第八种:数字之间的加减运算来实现，第一种加减方式12345678/* 适用性: 仅适用于数字 简要说明:这种用法在只用于数字间的交换时，性能也不弱*/a = a + b;b = a - b; a = a - b; 第九种:数字之间的加减运算来实现，第一种加减方式123456/* 适用性: 仅适用于数字 简要说明:这种用法在只用于数字间的交换时，性能也不弱*/a = b -a +(b = a) 第十种:利用eval计算1234567/* 适用性: 仅适用于数字和字符串 简要说明:这种方式仅用于研究，实战慎用这种模式执行一万次耗时等于其它执行一亿次...*/eval("a="+b+";b="+a); 第十一种:数组中，利用splice交换两个元素的位置123456/* 适用性: 仅适用于数组元素 简要说明:这种方式看起来挺优雅的，但实际上性能远远比不上临时变量那种*/arr[0] = arr.splice(2, 1, arr[0])[0] 各种交换方式的性能对比123456789上述列举了几种方式都有一一做过对比分析，基本上可以得出的结论是:还是老老实实的用回临时变量交换吧，经典，优雅，而且保证不会出什么幺蛾子在chrome中运行了一亿次后得出的结论(每次运行100万次,一共100个循环，得到的分析结果)可以看出,tmp变量交换最快,try catch最慢在chrome (支持es6)中运行了100万次后得出的结论(每次运行1万次,一共100个循环，得到的分析结果)可以看出,eval最慢,splice性能较低，tmp变量交换很稳定 Exchange Variables Gracefully tips:javascript是一种弱类型语言，不管声明什么类型的变量，都是用var，并且变量的类型是可以变化的。 12var age = 90;age = "张三"; JavaScript中的数据类型简单(基本、值)数据类型 Number（数字类型）、String（字符串）、Boolean（布尔类型） Undefined、Null（特殊类型） 复杂(引用)数据类型 object 如何查看数据类型使用typeof关键字查看数据类型 12typeof name;typeof(name); Number类型进制123451. 十进制，我们平时使用的就是十进制，进行运算时，八进制和十六进制的值最终都会转换成十进制。2. 八进制，0开头的数值，数值序列：0-73. 十六进制，0x开头的数值，数值序列：0-9A-F进制了解即可，基本都是使用十进制，稍微了解一下进制之间的转换。 浮点数科学计数法： 科学记数法是指把一个数表示成a×10的n次幂的形式（1≤a&lt;10，n 为整数。） 12var num = 5e+3; //5000var num1 = 5e-2; //0.05 浮点数的精度问题： 120.1 + 0.2 = ? //0.300000000000000040.07 * 100 = ? //7.000000000000001 浮点数在运算的时候会出现精度丢失的问题，因此在做比较运算的时候，尽量不要用小数进行比较。 数值范围 javascript不能表示世界上所有的数，因此在javascript中，数值大小是有一定限制的。 1234Number.MIN_VALUE :5e-324Number.MAX_VALUE :1.7976931348623157e+308Infinity :正无穷-Infinity :负无穷 数值判断1231. NaN:表示一个非数值，当无法运算或者运算错误的时候，会得到一个NaN，NaN是number类型，表示一个非数值。2. NaN不等于NaN3. isNaN用来判断是否是一个数字，当返回true的时候，表示不是一个数字，返回false表示是一个数字。 【要求：判断一个数据是不是数字】1234var data = "abc";if(typeof data == "number"&amp;&amp;!isNaN(data))&#123; console.log("是数字"); &#125; String类型字面量字符串的字面量：“abc” 、 ‘abc’ 字符串可以是双引号，也可以是单引号引起来。单双引号可以嵌套使用。 1234//我是一个"正直"的人 //我很喜欢"传'智'播客"console.log('我是一个"正直"的人');console.log('我很喜欢吃"好吃\'的\'东西"'); 字符串长度length属性用来获取字符串的长度 12var str = "abckjdlkfjd";str.length;//字符串的长度 ###字符串的不可变性 什么是不可变性(Immutability)？还是先来看看关于可变性(Mutability)的教条式定义：“liable or subject to change or alteration(译者注：真他妈难翻，就简单理解成’易于改变的’吧)”。在编程领域里，我们用可变性(Mutability)来描述这样一种对象，它在创建之后状态依旧可被改变。那当我们说不可变(Immutable)时，就是可变(Mutable)的对立面了(译者注：原谅我翻的废话又多起来) － 意思是，创建之后，就再也不能被修改了。 如果我说的又让你感到诡异了，原谅我小小的提醒一下，其实我们平时使用的很多东西事实上都是不可变的哦！ var statement = ‘I am an immutable value’;var otherStr = statement.slice(8, 17);我猜没人会吃惊，statement.slice(8, 17)并没有改变statement变量吧(译者注：如果你吃惊了，赶紧去补基本知识吧)？事实上，string对象上的所有方法里，没有一个会修改原string，它们一律返回新的string。原因简单了，因为string就是是不可变的(Immutable) - 它们不能被修改，我们能做的就是基于原string操作后得到一个新string。 注意了，string可不是javascript里唯一内置的不可变(Immutable)数据类型哦。number也是不可变(Immutable)的。否则的话，你试想下这个表达式2 + 3，如果2的含义能被修改，那代码该怎么写啊|_|。听起来荒谬吧，但我们在编程中却常常对object和array做出这种事儿。 字符串拼接拼接字符串使用+号 12345//思考：console.log(11 + 11);console.log("hello" + " world");console.log("100" + "100");console.log("11" + 11); 两边只要有一个是字符串，那么+就是字符串拼接功能 两边如果都是数字，那么就是算术功能。 boolean类型boolean类型只有两个字面量，true和false，区分大小写。 所有类型的值都可以转化成true或者false 1NaN、""、undefined、null、false、0 这6个值可以转换成false，其余的都是true。 undefined类型与null类型123456undefined表示一个声明了没有赋值的变量null表示一个空的对象。undefined派生自null。undefined == null ：trueundefined === null ：false 12345678910111213141516171819/* undefined : var age;//变量声明未赋值 值为undefinedfunction abc(a,b)&#123;&#125; abc(); //形参未接收实参 其值 为undefinedvar arr = new Array(5);//alert(arr[1]);//数组中如果没有值 值为undefinedreturn 在函数内部 默认 返回值无 则返回undefined*//*一个对象 身上没有这个属性 那么这个属性值为undefined*/// js程序当中如果没有值 则默认会给一个undefined 程序自动给的/*alert(a);//报错*//*alert(window.a);*///var student1 = &#123; name:"zhangsan", age:25&#125;alert(student1['name']);var student1 = null;//将这个对象在内存中清除了 在堆内存中空间上清除 console.log(student1.name);// null： 空对象 如果一个对象没有数据 或者说需要清空对象 这是时候人为可以赋值 为null 类型转换如何使用谷歌浏览器，快速的查看数据类型？ 字符串的颜色是黑色的，数值类型是蓝色的，布尔类型也是蓝色的，undefined和null是灰色的，这个在调试过程中时非常有用的。 转换成字符串类型 toString() (undefined和null无法使用此方法) String() /+ “” 转换成数值类型 Number() (尝试将任何数据类型进行转换 如果转不了 返回一个NaN) parseInt parseFloat +num, -0等运算 (隐式转换) 1234567891011121314151617181920212223//10进制转为16进制(10).toString(16) // =&gt;"a"//8进制转为16进制(012).toString(16) // =&gt;"a"//16进制转为10进制(0x16).toString(10) // =&gt;"22"//16进制转为8进制(0x16).toString(8) // =&gt;"26"//10进制转为2进制 //=&gt;(1111).toString(2) // =&gt; "10001010111"//8进制转为2进制 //=&gt;(01111).toString(2) //=&gt;"1001001001"//16进制转为2进制 //=&gt;(0x16).toString(2) // =&gt; "10110"//2进制到10进制；parseInt(10,2) //=&gt;2//2进制到10进制；parseInt(100,2) //=&gt;4//16进制到10进制parseInt(12, 16) //=&gt;18//8进制到10进制parseInt(12,8); //=&gt;10 转换成布尔类型 Boolean (强制类型转换) !! (隐式类型转换)]]></content>
      <categories>
        <category>js基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[JavaScript基础知识（下篇）]]></title>
    <url>%2F2016%2F02%2F10%2FJS%E5%9F%BA%E7%A1%80(%E4%B8%8B%E7%AF%87)%2F</url>
    <content type="text"><![CDATA[操作符@运算符 一元运算符@递增和递减递增++ 递减–a++ 先参与运算 后自加++a 先自加 后参与运算 关系运算符alert(&quot;A&quot;&gt;&quot;a&quot;);//false 65 97 字符串之间进行比较 会按照字符编码进行逐位比较 alert(&quot;15&quot;&gt;&quot;1&quot;);//true 逻辑运算符@逻辑运算符逻辑运算&amp;&amp;和||都采取短路运算，即第一个能够决定结果就不再看第二个了&amp;&amp; 的要求比较严格 要两个都是true才是true 所以看到第一个是false就没有必要继续完后看了 1console.log(false &amp;&amp; 不管了); || 的要求比较宽松 要两个都是false才是false 所以看到第一个是true就没有必要继续完后看了 1console.log(true || 不管了); 短路运算&amp;&amp;和||不但可以操作布尔类型的值，对其他类型的值也可以进行操作，并返回可以决定表达式结果的那个值。 赋值运算符@赋值运算符 1a+=b 等价于 a=a+b @表达式练习 运算符的优先级下表按从最高到最低的优先级列出JavaScript运算符。具有相同优先级的运算符按从左至右的顺序求值。 运算符 描述 . [] () 字段访问、数组下标、函数调用以及表达式分组 ++ – - ~ ! delete new typeof void 一元运算符、返回数据类型、对象创建、未定义值 * / % 乘法、除法、取模 + - + 加法、减法、字符串连接 &lt;&lt; &gt;&gt; &gt;&gt;&gt; 移位 &lt; &lt;= &gt; &gt;= instanceof 小于、小于等于、大于、大于等于、instanceof == != \=== !== 等于、不等于、严格相等、非严格相等 &amp; 按位与 ^ 按位异或 &#124; 按位或 &amp;&amp; 逻辑与 &#124;&#124; 逻辑或 ?: 条件 = oP= 赋值、运算赋值 , 多重求值 一元运算符 ++ -- ! 算数运算符 先* / % 后 + - 关系运算符 &gt; &gt;= &lt; &lt;= 相等运算符 == != === !== 逻辑运算符 先&amp;&amp; 后|| 语句选择语句ifif (condition) { statement1 } else if (condition) { statement2 } else { statement3 } @选择语句If 1234567//判断一个年份是闰年还是平年；四年一润,百年不润;四百年再润var year = 2016;if(year%4==0&amp;&amp;year%100!=0 || year%400==0)&#123; console.log(year+"是闰年");&#125;else&#123; console.log(year+"是平年");&#125; 三元表达式1表达式1 ? 表达式2 : 表达式3 1234567//从三个数中找最大值var num1 = 18;var num2 = 22;var num3 = 12;var result = (num1&gt;num2?num1:num2)&gt;num3?(num1&gt;num2?num1:num2):num3;console.log(result); @三元表达式 选择语句switchswitch (expression) { case value: statement break; case value: statement break; default: statement } 12345678910111213141516171819202122232425//显示星期几 1 2 3 4 5 6 0//var week = new Date().getDay();//3/*alert(week);*/switch(week)&#123; case 1:alert("星期一");break; case 2:alert("星期二");break; case 3:alert("星期三");break; case 4:alert("星期四");break; case 5:alert("星期五");break; case 6:alert("星期六");break; case 0:alert("星期日");break;&#125;/*素质教育（把分数变成ABCDE） A 90 B 80 千万不要写100个case哟*/var score = 76; switch(true)&#123; case score&gt;=90:alert("A");break; case score&gt;=80:alert("B");break; case score&gt;=60:alert("C");break; default:alert("不及格");break;&#125; @选择语句switch 循环语句forfor (initialization; expression; post-loop-expression)｛ statement ｝ 1234567891011//打印99乘法表document.write("&lt;table&gt;"); for(var i=1;i&lt;=9;i++)&#123; document.write("&lt;tr&gt;"); for(var j=1;j&lt;=i;j++)&#123; document.write("&lt;td style='border:1px solid red'&gt;"+j+"x"+i+"="+i*j+"&lt;/td&gt;"); &#125; document.write("&lt;/tr&gt;"); &#125;document.write("&lt;/table&gt;"); initialization表示：初始化表达式expression表示：控制表达式post-loop-expression表示：循环后表达式三者都是可选的@循环语句for break和continuebreak跳出当前循环，执行循环后的语句continue跳出当前循环，继续执行循环@break和continue 循环语句whilewhile语句 先判断后执行 1while(expression) statement 12345678//计算1+2+3+……+100之和。var sum = 0;//定义一个变量 用来求和var i = 1;//循环初始值while(i&lt;=5)&#123;//循环条件 sum+=i;//具体的事情 i++;//循环变量 自增&#125;console.log(sum); do while 语句 先执行后判断 1do &#123;statement&#125; while (expression); @循环语句while 数组数组的声明通过构造函数声明 1var arr = new Array("a", "b", "c") 通过字面量声明（推荐使用这种方法） 1var arr = ["a","b","c"]; 数组的赋值和取值赋值 1数组名[索引号] = 值 //arr[0]=100 取值（通过数组名和索引即可取到对应的值） 1数组名[索引号] //console.log(arr[0]) 数组的遍历（循环 枚举）@数组 数组的索引是从0开始的 数组的长度可以通过arr.length获取 由于数组的索引从0开始，所以最后一个值的索引为arr.length-1 通过for循环遍历数组 123for (var i = 0; i &lt;= arr.length - 1; i++) &#123; console.log(arr[i]);&#125; 可简写为： 123for (var i = 0; i &lt; arr.length; i++) &#123; console.log(arr[i]);&#125; @数组练习 @数组length的应用 往数组中添加新元素，数组的length会增加 通过给arr.length赋值可以改变数组的长度 @数组练习 冒泡排序@冒泡排序 12345678910111213141516171819var arr = [2,1,4,3,5];for(var i=0;i&lt;arr.length-1;i++)&#123;//外层循环控制比较了轮数 //对于轮数的优化 var onOff = true; //优化一下每轮比较次数 for(var j=0;j&lt;arr.length-1-i;j++)&#123;//里面的循环控制的每轮的比较次数 //如果前一项比后面一项大 则交换位置 if(arr[j]&gt;arr[j+1])&#123; var temp = arr[j]; arr[j]=arr[j+1]; arr[j+1]=temp; onOff=false; &#125; &#125; if(onOff)&#123; break; &#125;&#125;console.log(arr); // returns [1, 2, 3, 4, 5] 函数函数的定义 把一个相对独立的完整的功能（代码块）封装起来用函数（包）起来起个名字（函数名），可以多次重复调用 函数的作用 使程序变得更简短而清晰有利于程序维护可以提高程序开发的效率提高了代码的重用性(复用性) 另一个好处 用函数 封装起来 由你来控制它什么时间执行 什么场景执行 函数的写法函数的声明 123function 函数名 () &#123; //函数体 &#125; 函数的分类 123456分类方式1 1.命名函数 2.匿名函数 分类方式2 内置函数 ： 官方提供好的函数 例如 alert() isNaN() parseInt() 自定义函数 ： 用户根据需求 自己定义的函数 函数的调用 函数不会主动执行 需要调用来执行 命名函数调用： 1func() //这是最直接最常见的调用方式，也符合一般人的思维逻辑，但是在某些情况下有一些不足 12345//函数名+()等于函数直接执行 匿名函数不能直接调用function aa()&#123; alert(123); &#125;aa(); 匿名函数调用： 1(function(arg)&#123;&#125;)(window) // 匿名方法调用，在构造命名空间时比较有用，后面的括号中的参数与匿名方法中的入参一一对应。 1234//匿名函数想要执行 可以通过 匿名函数的自调用 来实现(function ()&#123; console.log("哈哈");&#125;)();//匿名函数的自调用 函数的立即执行表达式 bind方式调用 1func.bind(sth)()//mozilla手册中提到bind是在ECMA-262 5th Edition中新增的一个特性，这里单独列出来作为一种调用方式是因为它弥补了直接调用中不能绑定作用域的缺陷。 call &amp; apply方式调用 12func.call()//这是第二种调用方式，每个方法的原型中都定义了call方法，用来执行当前方法。func.apply()//call的双胞胎兄弟。 @函数的声明和调用** 函数的参数 参数是一一对应的参数的个数可以是任意个 有参数的函数的声明（声明中的参数只是一个占位符，没有实际的值，是形式参数，即形参）1234//函数在声明的时候 所写的参数 形参相当于局部变量function 函数名 (参数1,参数2,参数3...) &#123; //函数体&#125; 有参数的函数的调用（调用时传入的参数才是有真正数值的参数，是实际参数，即实参） 12//函数在调用的时候 写的参数 实参函数名(参数1,参数2,参数3...); arguments：（实参的集合列表） arguments:是天然存在在函数里面的 当前函数执行时 传入的实参的集合列表 是一个类数组（类数组 伪数组） 具有数组的长度和下标 但是没有数组的方法 适合在参数个数不确定的情况下使用 123456789101112131415function sum()&#123; /*console.log(c,d);//undefined alert(a+b+c+d);//NaN*/ console.log(arguments);//[36,14] [2,9,4] [-6,5,18,3] console.log(arguments[1]);//14 9 5 console.log(arguments.length);//2 3 4 var sum = 0; for(var i=0;i&lt;arguments.length;i++)&#123; sum+=arguments[i]; &#125; alert(sum);&#125;sum(36,14);sum(2,9,4);sum(-6,5,18,3); @函数的参数 函数的返回值在函数中通过return关键字将要返回值返回 1return 要返回的值; return 详解（三个特点）： 1 return 后面可以返回任何数据类型 2 return 不明写 默认返回undefined 3 return 返回返回值之后 后续代码不执行 直接终止函数 函数高级概念@参数详解在JS中实参的个数和形参的个数可以不一致@返回值详解函数的返回值是什么，调用这个函数就相当于调用什么，如果没有回值则为undefined函数在执行完成return语句后便会退出函数，后面的代码不会执行@两种定义方式函数声明123function fn1() &#123; //函数体&#125; 函数表达式 var fn2 = function () { //函数体 };@匿名函数匿名函数（没有名字的函数） function () { //函数体 }@递归调用程序调用自身的编程技巧称为递归@回调函数函数也是一种普通的数据类型因此函数也可以被当作参数传递被当作参数传递的函数叫做回调函数 @函数的预解析 js的解析器拿到一段代码就会进行预解析 （凡是有作用域 一定有预解析） 预解析： 在当前的作用域下看看有没有声明的变量和声明的函数如果有提前放到预解析环境中，名称如果由冲突 函数比变量级别高 案例求阶乘 123456// 求一个数的阶乘function factorial(num) &#123; return num === 1?num:(num*factorial(num-1))&#125;console.log(factorial(5)) //120 求质数index.js 1234567891011121314151617181920// 1 ----n 之间的质数function isSu(n)&#123; var k =0;x`` if(n==0||n==1)&#123; return n+"既不是素数也不是合数"; &#125; for(var i=1;i&lt;=n;i++)&#123; // 0 1 既不是素数也不是合数 特殊情况特殊处理 if(n%i==0)&#123; k++; &#125; &#125; if(k==2)&#123; return n+"素数"; &#125;else&#123; return n+"合数"; &#125;&#125;for(var i=1;i&lt;=15;i++)&#123; console.log(isSu(i));&#125; 斐波那契数列 123456789/*输出斐波那契数列的前20项(递归) 1 1 2 3 5 8 13 21 */ function qiutuzi(n) &#123; if(n &lt;= 2)&#123; return 1; &#125; return qiutuzi(n-1)+qiutuzi(n-2)&#125;var result = qiutuzi(12);//144 设置盒子 index.js 1234567function $(id) &#123; // 如果某个属性 需要用变量或者形参代替 不能直接跟在.后面 把.去掉 改成[] function setStyle(attr, value) &#123; document.getElementById(id).style[attr] = value &#125; return setStyle &#125; index.html 12&lt;div id="box"&gt;&lt;/div&gt;&lt;button id="btn1" onclick="$('box')('width','200px')"&gt;单击让盒子变宽&lt;/button&gt; 验证码 要求：字母 数字 不重复 12345678910111213//这种写法由于传递的数组的引用，所以每次调用都会修改原数组function getNumber(n) &#123; var selectChar = [0,1,2,3,4,5,6,7,8,9,'a','A','b','B','c','C','d','D','e','E','f','F','g','G','h','H','i','I','j','J','k','K','l','L','m','M','n','N','o','O','p','P','q','Q','r','R','s','S','t','T','u','U','v','V','w','W','x','X','y','Y','z','Z'] var b = [] for (var i = 0; i &lt; n; i++) &#123; var numRandom = Math.floor(Math.random()*selectChar.length) b.push(selectChar[numRandom]) selectChar.splice(numRandom,1) &#125; return b.join('')&#125;console.log(getNumber(4)) 对象从宏观的角度讲，对象是对客观事物的抽象，事物的特征可以用属性表示，事物的行为可以用方法表示从微观的角度讲，对象就是一种数据类型，通过对象可以方便地对变量和函数进行管理 简单来说：JavaScript中的对象：无序属性的集合 var arr = [1,2,3];//特殊的对象 有序 特殊在数组的键名是有序的下标 1.2.1. 键值对键值对就是一种对应关系，通过键能够方便地找到值 1键:值 key:value k:v 对象的声明通过构造函数声明（更加通用） 1var obj= new Object(); 通过字面量声明（更加简便） 1var obj= &#123;&#125;; 对象具有属性和方法属性 用来描述对象的特征 一般是名词 对应变量方法 用来描述对象的行为 一般是动词 对应函数 json格式: javascript object notation js对象标记法轻量级的一种数据交换格式 （目前常用于 前后端数据交互） 1234&#123;"name":"张三","age" : 25&#125; xml :可扩展标记语言 过去老式的重量级的数据交换格式 html 1234&lt;person&gt;&lt;name&gt;张三&lt;/name&gt;&lt;age&gt;25&lt;/age&gt;&lt;/person&gt; 属性属性的定义1对象.属性名 = 值 属性的调用1对象.属性名 变量： 一个自由的变量 通过var 去声明 属性： 如果有一个变量 归属于一个对象下面 那么我们将该变量称为 该对象的一个属性 ​ 方法方法的定义 1对象.方法名 = function()&#123; //函数体 &#125; 方法的调用 1对象.方法名() 函数 一个自由的函数 方法 如果一个函数 归属一个对象下面 那么我们将该函数 称之为该对象的一个方法 只有对象才可以挂载属性和方法 @找对象练习** Math对象Math:js程序当中的一个内置的对象 提供一些方法用于数学计算 //Math.round();//四舍五入 console.log(Math.round(3.9));//4 console.log(Math.round(3.1));//3 console.log(Math.floor(3.9));//3 向下取整 console.log(Math.ceil(3.1));//向上取整4 console.log(Math.ceil(3.0));//向上取整 console.log(Math.max(9,15,3,1));//求最大值 console.log(Math.min(-8,5,1,0));//求最小值 console.log(Math.PI);//常量 无限不循环小数 圆周率 π 3.141592653989793 //console.log(Math.pow(a,b));//求a的b次方 // console.log(Math.sqrt(9));//求平方根 /*console.log(Math.tan());*/ console.log(Math.abs(-7));//取绝对值 //console.log(Math.random());//0--1随机小数 不包含1 [0,1) //求0-100之间的任意随机整数 //Math.round(Math.random()*100);//0--100 [0,100) //30---60 随机整数 // Math.round(Math.random()*30)+30 [30,60) //48---72随机整数 // Math.round(Math.random()*24)+48 [48,72) //求x-y之间的任意随机整数 // Math.round(Math.random()*(y-x))+x; [x,y) Date对象Date对象： js内置的一个日期时间对象 提供一些时间方法 方便我们来获取系统时间 12345678910111213141516171819var mydate = new Date();//获取是当前的系统时间console.log(mydate);//Tue Jun 20 2017 14:40:03 GMT+0800 (中国标准时间)console.log(typeof mydate);//objectvar date2 = new Date("2017-03-22");//创建一个指定日期的日期对象console.log(typeof date2,date2);//object Wed Mar 22 2017 08:00:00 GMT+0800 (中国标准时间)var date3 = new Date("2017-03-22 00:52:34");//创建一个指定日期 小时和分以及秒的日期对象console.log(typeof date3,date3);var mydate = new Date();var strDate = mydate.toString();console.log(typeof strDate,strDate);//将日期对象转换成字符串类型var strDate2 = mydate.toDateString();console.log(typeof strDate2,strDate2);//string Tue Jun 20 2017var strDate3 = mydate.toTimeString();console.log(typeof strDate3,strDate3);//string 14:48:23 GMT+0800 (中国标准时间) 电子时间 123456789101112131415161718192021222324var mydate = new Date();//获取系统时间 var myYear = mydate.getFullYear();//通过这个方法 获取具体的年console.log(myYear);//2017 number类型var myMonth = mydate.getMonth();//通过这个方法 获取具体的月console.log(myMonth);//系统里面的月份 从0开始var myDay = mydate.getDate();//通过这个方法 获取具体几号var h = mydate.getHours();//通过这个方法 获取具体小时数var m = mydate.getMinutes();//通过这个方法 获取具体分钟数var s = mydate.getSeconds();//通过这个方法 获取具体秒数var week = mydate.getDay();//通过这个方法 获取星期几console.log(week);//0--6 0星期日 var ms = mydate.getMilliseconds();//通过这个方法 获取毫秒数console.log(ms);var str = myYear+"年 "+myMonth+"月 "+myDay+"日 "+week+" "+h+":"+m+":"+s+":"+ms;document.write(str); 其他概念对象字面量@对象字面量1234567var o = &#123; name : "zs", age : 18, sayHi : function() &#123; console.log(this.name); &#125;&#125;; 对象标记法@对象标记法JavaScript Object Notation（JavaScript对象标记法）是仿照JS中对象字面量的格式去书写的一串用来记录对象数据的字符串，可以用于数据传输。将来学习AJAX会详细学习。 访问属性的两种方式@访问属性的两种方式点语法（简单）1对象.属性名 中括号（灵活）1对象[“属性名”] 遍历的两种方式@遍历的两种方式通过for可以对集合进行有序的遍历通过forin可以对集合进行有序的遍历123456for(var k in json) &#123; 语句 &#125;//对象的循环或者遍历 需要用for……in循环来遍历for(var k in obj)&#123;//console.log(k);//在for in循环中k变量其实是 这个对象的键名console.log(obj[k]);//对象.键名=键值 对象[代表属性的变量]=键值&#125; k变量代表的是json中的各个属性（key）和 var i = 0中的i是一个意思 名字不同而已 for in 语法遍历一个对象的可枚举属性for 按设置的条件循环执行包含的语句块 1234var mycars = new Array()mycars[0] = "Saab"mycars[2] = "Volvo"mycars[4] = "BMW" 对于数组对象mycars来说其长度为5，有“1”，“2”，“4”这3个可枚举属性所以 123for (y in mycars)&#123;console.log(mycars[y]);&#125; 可输出Saab,Volvo，BMW 而当 123for (y=0;y&lt;mycars.length;y++)&#123; console.log(mycars[y]);&#125; mycars.length值为5，y值分别为0，1，2，3,4mycars[y]相当于在执行mycars[String(y)]1，3下标处没有定义值，为undefined输出结果为Saab,undefind,Volvo,undefined,BMW 对象对象的声明和使用通过构造函数声明（更加通用） 1var obj= new Object(); 通过字面量声明（更加简便） 1var obj= &#123;&#125;; 对象具有属性和方法属性 用来描述对象的特征 一般是名词 对应变量方法 用来描述对象的行为 一般是动词 对应函数属性属性的定义 1对象.属性名 = 值 属性的调用 1对象.属性名 方法方法的定义 1对象.方法名 = function()&#123; //函数体 &#125; 方法的调用 1对象.方法名() 关于this的指向全局上下文全局运行上下文中（在任何函数体外部），this 指代全局对象 函数上下文对象方法中的this指的是该方法所属的对象直接调用中的this指的是全局对象总之，函数上下文中（在函数内部），this指的是当前函数所属的对象 构造函数中当一个函数被作为构造函数使用时（前面加new关键字），new关键字会让this的指向改变，并让其成为当前函数的返回值 批量创建对象工厂模式创建对象为什么要优化创建对象的方式因为对象在项目中被大规模的使用，所以每一点小小的改进都会对项目整体效率带来很大的提升，现阶段同学们还不可能有深刻的体会，只是让大家了解一下，后面讲项目大家自然就明白了。@工厂模式创建对象同类型对象，只是一些属性的值不同，通过对象字面量创建对象每次都要写那么多东西很费劲，我们可以将创建对象的过程封装进一个函数，只把发生变化的属性作为参数传入，从而简化对象创建的过程。但是工厂模式只是创建出来一个普通的对象并将其返回，因此无法判断实例的具体类型。 12345678910111213141516171819202122232425//如何批量创建对象//工厂方式//工厂：// 1 原料// 2 加工// 3 出厂function createStudent(name,age,job)&#123; //1 准备原料 var student1 = new Object(); //2 加工 student1.name=name; student1.age = age; student1.job = job; student1.sayHello=function () &#123; console.log("正在打招呼"); &#125; student1.study=function () &#123; console.log("正在学习js"); &#125; //出厂 return student1;&#125;var stu1 = createStudent("李四",25,"singer");stu1.sayHello();console.log(stu1.age); 构造函数创建对象@this和new利用new 关键字可以声明的对象。new 关键字可以让构造函数中this的指向改变，并让构造函数把this返回。@构造函数构造函数也是函数，只不过会默认返回一个对象。 @构造函数创建对象通过构造函数创建对象更方便（不需要创建对象并返回）。更重要的是可以通过instanceof来判断实例的类型了。 1234567891011121314151617181920212223242526272829//构造函数var arr = new Array();//程序当中定义好的数组的构造函数var mydate = new Date();//程序当中定义好的日期对象的构造函数/*new RegExp();//程序当中 定义好的正则对象*/function CreateStudent(name,age,job)&#123; //1 准备原料 /*var student1 = new Object();*/ //2 加工 // 隐式对象 模型 this.name=name; this.age = age; this.job = job; this.sayHello=function () &#123; console.log("正在打招呼"); &#125; this.study=function () &#123; console.log("正在学习js"); &#125; //出厂 /*return this;*/&#125;var stu1 = new CreateStudent("李四",25,"singer");var stu2 = new CreateStudent("张三",30,"dancer");/*1 通过 new 来调用这个函数那么这个函数是构造函数 （区别于普通函数 专门用来创建对象的） 2 如果外面通过new来调用里面 new Object()省略不写 return 省略不写 将属性和方法挂载到this 身上3 不成文的规定 构造函数的函数名 首字母大写4 通过new 调用构造函数的过程 就是实例化对象的过程 stu1 和stu2 实例化的对象*/ 基本类型和复杂类型分类基本数据类型（值类型）：直接存储值number、string、boolean、undefined、null（基本类型只有这五个）复杂数据类型（引用类型）：存储引用object 基本类型的复制* 复杂类型的复制 基本类型参数 复杂类型参数@复杂类型参数练习]]></content>
      <categories>
        <category>js基础</category>
      </categories>
      <tags>
        <tag>js基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模块化开发]]></title>
    <url>%2F2016%2F01%2F10%2F%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[在前端开发中，起初只需要在&lt;script&gt;&lt;/script&gt;加入很少的代码来实现一些基本的交互效果，后来随着js得到了越发的重视之后，使得前端项目也变得越来越来复杂，需要更好的组织形式来分类、实现业务逻辑，然而，JavaScript本身是没有类（class）的概念的，当然也就没有模块（module）的概念了。 一个模块就是实现特定功能的文件，有了模块，我们就可以更方便地使用别人的代码，想要什么功能，就加载什么模块。模块开发需要遵循一定的规范，否则就都乱套了。 目前，通行的js模块规范主要有两种：CommonJS和AMD。 根据AMD规范，我们可以使用define定义模块，使用require调用模块。 AMD规范 AMD 即Asynchronous Module Definition，中文名是“异步模块定义”的意思。它是一个在浏览器端模块化开发的规范，服务器端的规范是CommonJS 模块将被异步加载，模块加载不影响后面语句的运行。所有依赖某些模块的语句均放置在回调函数中。 AMD 是 RequireJS 在推广过程中对模块定义的规范化的产出。 define() 函数 AMD规范只定义了一个函数 define，它是全局变量。函数的描述为： 1define(id?, dependencies?, factory); 参数说明： id：指定义中模块的名字，可选；如果没有提供该参数，模块的名字应该默认为模块加载器请求的指定脚本的名字。如果提供了该参数，模块名必须是“顶级”的和绝对的（不允许相对名字）。 依赖dependencies：是一个当前模块依赖的，已被模块定义的模块标识的数组字面量。依赖参数是可选的，如果忽略此参数，它应该默认为[“require”, “exports”, “module”]。然而，如果工厂方法的长度属性小于3，加载器会选择以函数的长度属性指定的参数个数调用工厂方法。 工厂方法factory，模块初始化要执行的函数或对象。如果为函数，它应该只被执行一次。如果是对象，此对象应该为模块的输出值。 模块名的格式 模块名用来唯一标识定义中模块，它们同样在依赖性数组中使用： 模块名是用正斜杠分割的有意义单词的字符串单词须为驼峰形式，或者”.”，”..”模块名不允许文件扩展名的形式，如“.js”模块名可以为 “相对的” 或 “顶级的”。如果首字符为“.”或“..”则为相对的模块名顶级的模块名从根命名空间的概念模块解析相对的模块名从 “require” 书写和调用的模块解析 使用 require 和 exports 创建一个名为”alpha”的模块，使用了require，exports，和名为”beta”的模块: 1234567define("alpha", ["require", "exports", "beta"], function (require, exports, beta) &#123; exports.verb = function() &#123; return beta.verb(); //Or: return require("beta").verb(); &#125; &#125;); require API介绍[AMD规范中文版]https://github.com/amdjs/amdjs-api/wiki/AMD-(%E4%B8%AD%E6%96%87%E7%89%88) 目前，实现AMD的库有RequireJS 、rl 、Dojo 、Nodules 等。 *CommonJS规范 CommonJS是服务器端模块的规范，Node.js采用了这个规范。Node.JS首先采用了js模块化的概念。 根据CommonJS规范，一个单独的文件就是一个模块。每一个模块都是一个单独的作用域，也就是说，在该模块内部定义的变量，无法被其他模块读取，除非定义为global对象的属性。 输出模块变量的最好方法是使用module.exports对象。 123456789var i = 1;var max = 30; module.exports = function () &#123; for (i -= 1; i++ &lt; max; ) &#123; console.log(i); &#125; max *= 1.1;&#125;; 上面代码通过module.exports对象，定义了一个函数，该函数就是模块外部与内部通信的桥梁。 加载模块使用require方法，该方法读取一个文件并执行，最后返回文件内部的module.exports对象。 CommonJS 规范：http://javascript.ruanyifeng.com/nodejs/commonjs.html RequireJS和SeaJS RequireJS由James Burke创建，他也是AMD规范的创始人。 define方法用于定义模块，RequireJS要求每个模块放在一个单独的文件里。 RequireJS 和 Sea.js 都是模块加载器，倡导模块化开发理念，核心价值是让 JavaScript 的模块化开发变得简单自然。 SeaJS与RequireJS最大的区别: SeaJS对模块的态度是懒执行, 而RequireJS对模块的态度是预执行 不明白？看这篇图文并茂的文章吧：http://www.douban.com/note/283566440/ RequireJS API:http://www.requirejs.cn/docs/api.html RequireJS的用法：http://www.ruanyifeng.com/blog/2012/11/require_js.html 为什么要用requireJS 试想一下，如果一个网页有很多的js文件，那么浏览器在下载该页面的时候会先加载js文件，从而停止了网页的渲染，如果文件越多，浏览器可能失去响应。其次，要保证js文件的依赖性，依赖性最大的模块（文件）要放在最后加载，当依赖关系很复杂的时候，代码的编写和维护都会变得困难。 RequireJS就是为了解决这两个问题而诞生的： （1）实现js文件的异步加载，避免网页失去响应；（2）管理模块之间的依赖性，便于代码的编写和维护。 RequireJS文件下载：http://www.requirejs.cn/docs/download.html AMD和CMD CMD（Common Module Definition） 通用模块定义。该规范明确了模块的基本书写格式和基本交互规则。该规范是在国内发展出来的。AMD是依赖关系前置，CMD是按需加载。 在 CMD 规范中，一个模块就是一个文件。代码的书写格式如下： 1define(factory); factory 为函数时，表示是模块的构造方法。执行该构造方法，可以得到模块向外提供的接口。factory 方法在执行时，默认会传入三个参数：require、exports 和 module： 123define(function(require, exports, module) &#123; // 模块代码&#125;); require是可以把其他模块导入进来的一个参数，而export是可以把模块内的一些属性和方法导出的。 CMD规范地址：https://github.com/seajs/seajs/issues/242 AMD 是 RequireJS 在推广过程中对模块定义的规范化产出。CMD 是 SeaJS 在推广过程中对模块定义的规范化产出。 对于依赖的模块，AMD 是提前执行，CMD 是延迟执行。 AMD:提前执行（异步加载：依赖先执行）+延迟执行CMD:延迟执行（运行到需加载，根据顺序执行）CMD 推崇依赖就近，AMD 推崇依赖前置。看如下代码： 1234567891011121314151617// CMDdefine(function(require, exports, module) &#123;var a = require('./a')a.doSomething()// 此处略去 100 行var b = require('./b') // 依赖可以就近书写b.doSomething()// ... &#125;) // AMD 默认推荐的是define(['./a', './b'], function(a, b) &#123; // 依赖必须一开始就写好a.doSomething()// 此处略去 100 行b.doSomething()...&#125;) 另外一个区别是： AMD:API根据使用范围有区别，但使用同一个api接口CMD:每个API的职责单一AMD的优点是：异步并行加载，在AMD的规范下，同时异步加载是不会产生错误的。CMD的机制则不同，这种加载方式会产生错误，如果能规范化模块内容形式，也可以 jquery1.7以上版本会自动模块化，支持AMD模式：主要是使用define函数，sea.js虽然是CommonJS规范，但却使用了define来定义模块所以jQuery已经自动模块化了 123456seajs.config(&#123;'base':'/','alias':&#123; 'jquery':'jquery.js'//定义jQuery文件&#125;&#125;); define函数和AMD的define类似： 1234567define(function(require, exports, module&#123; //先要载入jQuery的模块 var $ = require('jquery'); //然后将jQuery对象传给插件模块 require('./cookie')($); //开始使用 $.cookie方法&#125;); sea.js如何使用？ 引入sea.js的库 如何变成模块？ define 3.如何调用模块？ -exports-sea.js.use4.如何依赖模块？ -require 1234567&lt;script type="text/javascript"&gt; define(function (require,exports,module) &#123; //exports : 对外的接口 //requires : 依赖的接口 require('./test.js');//如果地址是一个模块的话，那么require的返回值就是模块中的exports &#125;)&lt;/script&gt; sea.js 开发实例 123456789101112131415161718192021222324252627&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;&lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt;&lt;title&gt;鼠标拖拽的模块化开发实践&lt;/title&gt;&lt;style type="text/css"&gt;#div1&#123; width:200px; height:200px; background:black; position:absolute; display:none;&#125;#div2&#123; width:30px; height:30px; background:yellow; position:absolute; bottom:0; right:0;&#125;#div3&#123; width:100px; height:100px; background:blue; position:absolute; right:0; top:0;&#125;&lt;/style&gt;&lt;script type="text/javascript" src="./sea.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; //A同事 ：seajs.use('./main.js'); &lt;/script&gt;&lt;/head&gt; &lt;body&gt;&lt;input type="button" value="确定" id="input1" /&gt;&lt;div id="div1"&gt; &lt;div id="div2"&gt;&lt;/div&gt;&lt;/div&gt;&lt;div id="div3"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; A同事 123456789101112131415161718//A同事写的main.js: define(function (require,exports,module) &#123; var oInput = document.getElementById('input1'); var oDiv1 = document.getElementById('div1'); var oDiv2 = document.getElementById('div2'); var oDiv3 = document.getElementById('div3'); require('./drag.js').drag(oDiv3); oInput.onclick = function () &#123; oDiv1.style.display = 'block'; require('./scale.js').scale(oDiv1,oDiv2); require.async('./scale.js', function (ex) &#123; ex.scale(oDiv1,oDiv2); &#125;) &#125;&#125;); B同事 12345678910111213141516171819202122232425262728293031323334//B同事写的drag.js: define(function(require,exports,module)&#123; function drag(obj)&#123; var disX = 0; var disY = 0; obj.onmousedown = function(ev)&#123; var ev = ev || window.event; disX = ev.clientX - obj.offsetLeft; disY = ev.clientY - obj.offsetTop; document.onmousemove = function(ev)&#123; var ev = ev || window.event; var L = require('./range.js').range(ev.clientX - disX , document.documentElement.clientWidth - obj.offsetWidth , 0 ); var T = require('./range.js').range(ev.clientY - disY , document.documentElement.clientHeight - obj.offsetHeight , 0 ); obj.style.left = L + 'px'; obj.style.top = T + 'px'; &#125;; document.onmouseup = function()&#123; document.onmousemove = null; document.onmouseup = null; &#125;; return false; &#125;; &#125; exports.drag = drag;//对外提供接口 &#125;); C同事 123456789101112131415161718192021222324252627282930313233343536373839//C同事写的scale.js: define(function(require,exports,module)&#123; function scale(obj1,obj2)&#123; var disX = 0; var disY = 0; var disW = 0; var disH = 0; obj2.onmousedown = function(ev)&#123; var ev = ev || window.event; disX = ev.clientX; disY = ev.clientY; disW = obj1.offsetWidth; disH = obj1.offsetHeight; document.onmousemove = function(ev)&#123; var ev = ev || window.event; var W = require('./range.js').range(ev.clientX - disX + disW , 500 , 100); var H = require('./range.js').range(ev.clientY - disY + disH , 500 , 100); obj1.style.width = W + 'px'; obj1.style.height = H + 'px'; &#125;; document.onmouseup = function()&#123; document.onmousemove = null; document.onmouseup = null; &#125;; return false; &#125;; &#125; exports.scale = scale; &#125;); D同事 123456789101112131415161718192021// D同事的range.js--限定拖拽范围 define(function(require,exports,module)&#123; function range(iNum,iMax,iMin)&#123; if( iNum &gt; iMax )&#123; return iMax; &#125; else if( iNum &lt; iMin )&#123; return iMin; &#125; else&#123; return iNum; &#125; &#125; exports.range = range; &#125;); requirejs开发实例 require.config是用来定义别名的，在paths属性下配置别名。然后通过requirejs(参数一，参数二)；参数一是数组，传入我们需要引用的模块名，第二个参数是个回调函数，回调函数传入一个变量，代替刚才所引入的模块。 main.js文件 12345678910//别名配置requirejs.config(&#123; paths: &#123; jquery: 'jquery.min' //可以省略.js &#125;&#125;);//引入模块，用变量$表示jquery模块requirejs(['jquery'], function ($) &#123; $('body').css('background-color','red');&#125;); 引入模块也可以只写require()。requirejs通过define()定义模块，定义的参数上同。在此模块内的方法和变量外部是无法访问的，只有通过return返回才行. define 模块 1234567define(['jquery'], function ($) &#123;//引入jQuery模块 return &#123; add: function(x,y)&#123; return x + y; &#125; &#125;;&#125;); 将该模块命名为math.js保存。 main.js引入模块方法 123require(['jquery','math'], function ($,math) &#123; console.log(math.add(10,100));//110&#125;); 没有依赖 如果定义的模块不依赖其他模块，则可以： 1234567define(function () &#123; return &#123; name: "trigkit4", age: "21" &#125;&#125;); AMD推荐的风格通过返回一个对象做为模块对象，CommonJS的风格通过对module.exports或exports的属性赋值来达到暴露模块对象的目的。]]></content>
      <categories>
        <category>模块化开发</category>
      </categories>
      <tags>
        <tag>模块化开发</tag>
      </tags>
  </entry>
</search>
