<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[版本控制Git]]></title>
    <url>%2F2017%2F09%2F18%2Fgit%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[操作计算的两种方式 图形界面 命令行 命令行概述 dos（window） shell（Linux–csh ksh bash） 什么是shell在计算机科学中，Shell俗称壳，用来区别于Kernel（核），是指“提供使用者使用界面”的软件（命令解析器）。它类似于DOS下的command和后来的cmd.exe。它接收用户命令，然后调用相应的应用程序。这种类型的版本控制系统，功能比较单一，比如很难实现多人协同开发，所以现在几乎很少使用了。 shell 分类1、图形界面shell：通过提供友好的可视化界面，调用相应应用程序，如windows系列操作系统，Linux系统上的图形化应用程序GNOME、KDE等。 2、命令行shell：通过键盘输入特定命令的方式，调用相应的应用程序，如windows系统的cmd.exe、Windows PowerShell，Linux系统的Bourne shell ( sh)、Bourne Again shell ( bash)等。 认识 bash 这个 shell在window系统下使用bash，需要一个软件，这个软件模拟集成了bash大部分命令。 各个 shell 的功能都差不多， Linux 默认使用 bash ，所以我们主要学习bash的使用。 1. bash 命令格式 命令 [-options][参数]，如：tar zxvf demo.tar.gz 查看帮助：命令 –help 2. bash 常见命令 pwd (Print Working Directory) 查看当前目录 cd (Change Directory) 切换目录，如 cd /etc ls (List) 查看当前目录下内容，如 ls -al mkdir (Make Directory) 创建目录，如 mkdir blog touch 创建文件，如 touch index.html cat 查看文件全部内容，如 cat index.html less 查看文件，如more /etc/passwd、less /etc/passwd rm (remove) 删除文件，如 rm index.html、rm -rf blog rmdir (Remove Directory) 删除文件夹，只能删除空文件夹，不常用 mv (move) 移动文件或重命名，如 mv index.html ./demo/index.html cp (copy) 复制文件，cp index.html ./demo/index.html tab 自动补全，连按两次会将所有匹配内容显示出来 > 和 &gt;&gt;重定向，如echo hello world! &gt; README.md，&gt;覆盖 &gt;&gt;追加 | 管道符可以将多个命令连接使用，上一次（命令）的执行结果当成下一次（命令）的参数。 grep 匹配内容，一般结合管道符使用 版本控制工具的作用 方便团队开发过程中进行代码的合并 能够保留所有的历史记录，方便随时回滚 vi编辑器 如同Windows下的记事本，vi编辑器是Linux下的标配，通过它我们可以创建、编辑文件。它是一个随系统一起安装的文本编辑软件。 vi编辑器的三种模式 vi编辑器提供了3种模式，分别是命令模式、插入模式、底行模式，每种模式下用户所能进行的操作是不一样的。 3种模式的切换如下图所示： 输入模式是不能直接切换到末行模式的，必须要先切回到命令模式（按ESC键) vi/vim常用操作 a)打开/创建文件， vi 文件路径 b) 底行模式 :w保存，:w filenme另存为 c) 底行模式 :q退出 d) 底行模式 :wq保存并退出 e) 底行模式 :e! 撤销更改，返回到上一次保存的状态 f) 底行模式 :q! 不保存强制退出 g) 底行模式 :set nu 设置行号 h) 命令模式 ZZ（大写）保存并退出 i) 命令模式 u辙销操作，可多次使用 j) 命令模式 dd删除当前行 k) 命令模式 yy复制当前行 l) 命令模式 p 粘贴内容 m) 命令模式 ctrl+f向前翻页 n) 命令模式 ctrl+b向后翻页 o) 命令模式 i进入编辑模式，当前光标处插入 p) 命令模式 a进入编辑模式，当前光标后插入 q) 命令模式 A进入编辑模式，光标移动到行尾 r) 命令模式 o进入编辑模式，当前行下面插入新行 s) 命令模式 O进入编辑模式，当前行上面插入新行 当处在编辑模式的情况下，和在Windows编辑器的使用相似。 SSHSSH是一种网络协议，用于计算机之间的加密登录。 SSH只是一种协议，存在多种实现，既有商业实现，也有开源实现。本文针对的是OpenSSH，它是自由软件，应用非常广泛。 如果要在Windows系统中使用SSH，会用到另一种软件PuTTY，我们后面用到的Git客户也集成了SSH 格式：ssh user@host user 代表真实存在的用户host代表要登录的远程计算机 常见有两种加密技术，分别是对称性加密和非对称性加密，SSH属于后者。 对称加密算法在加密和解密时使用的是同一个密钥；而非对称加密算法需要两个密钥来进行加密和解密，这两个秘钥分别是公开密钥（public key，简称公钥）和私有密钥（private key，简称私钥）。 工作原理 公钥和私钥是成对出现，可以通过ssh-keygen -t rsa来创建，既可以通过密钥来加密数据，也可以通过私钥来加密数据，如果是以公钥进行的数据加密，只能与之相对应的私钥才可以解密，相反如果以私钥进行的数据加密，则只能与之对应的公钥才可以将数据进行解密，这样就可以提高信息传递的安全性。 免密码登录（待定） 我们可以将本地机器上的公钥保存到特定的远程计算机上，这样当我们再次登录访问这台远程计算机时就可以实现免密码登录了。 1、ssh-keygen -t rsa会创建公钥和密钥（默认在用户目录/.ssh目录下） 2、ssh-copy-id user@host添加到对应远程主机的用户目录/.ssh目录下 3、也可以登录远程主机，进入到用户目录/.ssh目录下手动创建authorized_keys文件，并将自已的公钥粘入该文件。 关于版本控制版本控制（Version Control Systems）是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。这个系统可以自动帮我们备份文件的每一次更改，并且可以非常方便的恢复到任意的备份（版本）状态。 举例：我们通常都是手动的重命名一个文件进行备份的，index.html改成index1.html或者index.html.bak等形式，然后这种方式对于单个文件我们还能够管理，但是对于整个项目而言，就会成为噩梦了！！！我们不得不借助于软件来实现。 实现版本控制的软件有很多种类，大致可以分为本地版本控制系统、集中式版本控制系统、分布式版本控制系统。 版本控制概述 本地版本控制 借助软件我们可以记录下文件的每一次修改，如下图所示，文件被修改后，记录下了3个版本，这样我们通过版本控制系统（软件）便可以非常方便的恢复到任意版本。 这种类型的版本控制系统，功能比较单一，比如很难实现多人协同开发，所以现在几乎很少使用了。 集中版本控制实际开发环境，一个项目通常是由多人协作共同完成的，如何让在不同终端上的开发者协同工作成了亟待解决的问题，集中式版本控制系统便应运而生了。它通过单一的集中管理的服务器，保存所有文件的修订版本，协同工作的开发者都通过客户端连到这台服务器，取出最新的文件或者提交更新。其代表为SVN，如下图所示。 这种方式很好解决了多人协同开发的问题，但是也有一个弊端，如果集中管理的服务器出现故障，将会导致数据（版本）丢失的风险，另外协同开发者从集中服务器中更新数据时，严重依赖网络，如果网络不佳，也给开发带来诸多不便。 分布式版本控制 分布式版本控制系统，则不需要中央服务器，每个协同开发者都拥有一个完整的版本库，这么一来，任何协同开发者用的服务器发生故障，事后都可以用其它协同开发者本地仓库恢复。 由于版本库在本地计算机，也便不再受网络影响了。如果要将本地的修改，推送给其它协同开发者，还需要一台共享服务器，所有开发者通过这台共享服务器同步和更新数据。如下图所示。 分布式版本控制系统弥补了前面两种版本控制系统的缺陷，成为了版本控制的首选方案。其代表就是Git。 git环境安装 window安装 下载地址，下载后和普通软件安装方式一样 linux安装 CentOS发行版：sudo yum install git Ubuntu发行版：sudo apt-get install git Mac安装 打开Terminal直接输入git命令，会自动提示，按提示引导安装即可 git工作原理git的三个工作区域 工作目录（.git所在的目录，用来存储当前代码） 是对项目的某个版本独立提取出来的内容。这些从Git仓库的压缩数据库中提取出来的文件，放在磁盘上供你使用或修改。 暂存区域（git临时存储代码） 是一个文件，保存了下次将提交的文件列表信息，一般在Git仓库目录中。有时候也被称作“索引”（Index），不过一般说法还是叫暂存区域。 Git仓库（存储整个项目的快照，保存当前的暂存区中的一份代码） 是Git用来保存项目的元数据和对象数据库的地方。 这是Git 中最重要的部分，从其它计算机克隆仓库时，拷贝的就是这里的数据。 git管理文件的4中状态 未追踪untraced（新创建的文件） 已暂存staged（位于暂存区的文件，一般用于存储半成品） 已提交commited（位于本地仓库的文件，一般用于存储成品，该成品最终会上线） 已修改modified（暂存过的文件又被修改了） 基本的Git工作流程1、在工作目录中修改文件。 2、暂存文件，将文件的快照放入暂存区域。 3、提交文件，找到暂存区域的文件，将快照永久性存储到Git仓库目录。 Git本地仓库Git本地仓库指的是开发者计算机中的仓库。 git工作流程-本地创建仓库命令行方式：任意目录（建议开发根目录）右键 &gt; Git Bash Here 配置用户信息 配置用户的意义在于记录开发者信息，以便在版本控制记录开发者的操作行为，如lion于2016-08-24解决了一个bug。 12git config --global user.name "自已的名字"git config --global user.email "自已的邮箱地址" –global 配置当前用户所有仓库注：配置用户只需要执行1次，可以重复使用。 查看用户信息 1git config --list 初始化仓库 如果想要利用git进行版本控制，需要将现有项目初始化为一个仓库，或者将一个已有的使用git进行版本控制的仓库克隆到本地。 1git init git init会在当前项目目录中创建一个名为.git的隐藏目录，这个目录包含了暂存区和仓库两个区域，有了这个隐藏目录就可以使用git来管理项目了，通过ls -al 可以查看。 查看当前仓库的状态 初始化仓库后便可以进行开发了，进入到刚刚创建好并初始为仓库的目录，添加我们开发需要的文件。 通过git status可以检测当前仓库文件的状态（未追踪untracked）。 1git status 注：git会忽略空的目录 把工作目录中的文件添加到暂存区 假设经过一段时间的开发后，需要把已开发的部分暂存起来等待提交，使用git add 添加到暂存区。 git add 文件名/ 文件路径 “*”或-A代表所有 12git add 文件列表git add * 添加所有文件 通过git status再次查看文件状态，放到暂存区的文件被标记成了绿色，等待提交。 注：颜色是工具给添加的，目的是增加可读性并不是git统一的。 撤销更改 继续我们的开发，再次git status可以再次查看仓库状态 被标记了红色，说明index.html被再次修改了。又经过一段时间后发现新开发的部分有Bug，想要回到之前状态，可以使用git checkout 文件名，将上次暂存的文件还原到工作区。 1git checkout index.html 提交文件 经过一个相对较长阶段开发或者一个功能开发完成了，就可以提交到本地仓库了，永久保存了。 git commit -m ‘备注信息’ 1git commit -m 备注信息 将暂存区被标记成绿色的文件，全部提交到本地仓库存储。 这时git status查看状态 没有什么可提交的，变的很干净。 查看提交历史 反反复复开发了很多的功能了，通过git log查看一下提交的历史。 1git log 我们可以查看到一次次的提交记录 再次检测仓库文件状态 隔了好些天后，继续开发 git status 查看状态 又提示有修改，等待重新添加到暂存区。 重新添加暂存区然后提交 123git add index.htmlgit statusgit commit -m '完成了分享功能' 再次查看历史git log 可查到所有提交历史1git log 这时可以查看到更多提交历史。仓库示意图 恢复到以前提交的版本通过commit id值可以回到之前某一次的提交（时光倒流）git reset –hard c888a614e072e2这样便回到了支付功能的状态git log再次查看发现最后一次提交成了支付功能了 仓库示意图 git分支操作分支概述在我们的现实开发中，需求往往是五花八门的，同时开发个需求的情况十分常见，比如当你正在专注开发一个功能时，突然有一个紧急的BUG需要你来修复，这个时候我们当然是希望在能够保存当前任务进度，再去修改这个BUG，等这个BUG修复完成后再继续我们的任务。如何实现呢？ Git通过创建分支来解决实际开发中类似的问题。 在Git的使用过程中一次提交称为历史记录（版本），并且会生成一个唯一的字符串，如下图 这个串可以代表某一个历史版本（实际使用只取前面几位就可以）， 值得注意的是所有的提交（commit）实际上都是在分支（branch）的基础上进行的（只是前面并没有介绍）。 如下图所示： 当我们在初始化仓库的时候（实际上是产生第1次提交时），Git会默认帮我们创建了一个font color=”orange”&gt;master的分支，并且有font color=”orange”&gt;指针（HEAD）指到了末端。 指针（HEAD）用来标明当前处于哪个分支的哪个版本，如上图指的处于master分支的最后1个版本。 1、创建分支git branch 分支名称 当接到一个新任务时，先创建一个分支，例如购物车功能git branch cart 新分支会在当前分支原有历史版本的结点上进行创建，我们称其为子分支， 如下图 新建的子分支会继承父分支的所有提交历史。zh### 2、切换分支git checkout cart(分支名称)上一步只是创建了一个新的分支cart，要开发购物车功能需要切换到cart分支，如下图这时HEAD会指向cart的末端，然后再进行功能开发。### 3、提交操作持续开发购物车功能这次的提交历史版本就会记录在cart这个分支上了，并且HEAD伴随cart在移动。### 4、修复 Bug开发购物车过程中突然需要紧急修复一个bug，这时可以另外建立一个分支来进行修复，先切换到master分支，git checkout master当我们切换回master后，HEAD指向了master分支的末端，并且我们观察发现我们工作目录中并没有购物车功能代码。### 5、创建新分支修复bug修改并提交会在 hotfix 分支上创建新版本，并不会影响到 cart 分支的代码。### 6、继续新的开发修复完 bug 之后切换回 cart 分支，继续开发购物车功能。注：当我们git checkout branchname时，HEAD会自动指向对应分支的末端，工作目录中的源码也会随之发生改变。 这个时候我们就在hotfix这个分支上修复了这个BUG，而我们原来在cart分支上的操作并未受到影响。 思考一个问题： 现在cart这个分支上是否包含了hotfix的修复呢？ 实际上从上图可以看出这时的cart分支并没有包含有hotfix的修复。 7、合并（融合）分支 这时cart会有两个父结点了，cart便包含了hotfix里的修复了} 8、删除分支git branch -d hotfix 这时用来修复bug创建的hotfix分支已经没有用处了，我们可以将它删除。 分支操作 创建分支 切换分支 合并分支 删除分支 Git 远程（共享）仓库通过上面学习我们可以很好的管理本地版本控制了，可是如果我们下班回到家里突然来了灵感觉得有部分代码可以优化，如果能接着公司电脑上的代码继续写该有多好呀！另一种情形，假设项目比较大，不同的功能模块由不同的开发人员完成，不同模块儿之间又难免会依赖关系，这时如果我们的代码互相合并（融合）该有多好呀！所有模块开发完毕后，需要整合到一起，要能做到准确无误该有多好呀！ 借助一个远程仓库，大家可以共享代码、历史版本等数据，便可以解决以上遇到的所有问题，在学习远程仓库前我们先来学习git clone path这个命令。 创建共享仓库Git要求共享仓库是一个以.git结尾的目录。 mkdir repo.git 创建以.git结尾目录 cd repo.git 进入这个目录 git init –bare 初始化一个共享仓库，也叫裸仓库 注意选项–bare 这样我们就建好了一个共享的仓库，但这时这个仓库是一个空的仓库，并且不允在这个仓库中进行任何修改。 向共享仓库共享（同步）内容将自已开发的项目同步到这个目录中，其它开发者就可以共享你开发的项目了。 1、进入到yike目录 2、git push ../repo.git master 这样便把yike中的项目同步进了repo.git中。 从共享仓库里取出内容1、新创建一个目录（模拟另一个开发者） 2、git clone ./repo.git demo 通过repo.git共享仓库，我们轻松得到了一个yike的副本 6、通过 demo 仓库向 repo.git 共享内容进入到 demo 里，我们做一些修改 cd demo git push ../repo.git master 在360仓库从 repo.git 获取共享的内容cd yike git pull ../repo.git master 奇迹似乎发生了，我们轻松的将demo仓库里的内容，通过repo.git共享给了yike仓库。 惊喜不断，问题也总是不断，我们发现我们这个共享的仓库只是放到了本地的，其它人是没有办法从我们这个共享仓库共享内容的！！！ 然而现实是，办法总是有的！！！！ 我们把这个共享的仓库放到一台远程服务器上，问题不就解决了吗？ gitHub 和 gitLab如果我们熟悉服务器的话，我们完全可以将上述的步骤在我们的远程服务器上进行操作，然后再做一些登录权限的设置，就可非常完美的搭建一个共享服务器了。其实为了更好的管理我们的仓库，一些第三方机构开发出了Web版仓库管理程序，通过Web界面形式管理仓库。 gitHub关于它的名气与意义，大家可以自行查阅，我们这里介绍它的使用 注册账号并完善资料创建共享仓库 填写仓库资料 共享仓库 远程地址特别长，我们可以给他起一个别名 git remote add origin git@github.com:Botue/repo.git 这样origin 就代表 git@github.com:Botue/repo.git 当我们通过git clone 从共享仓库获内容时，会自动帮我们添加origin到对应的仓库地址，例如：git clone git@github.com:Botue/repo.git 会自动添加origin 对应 git@github.com:Botue/repo.git 生成密钥ssh-keygen -t rsa 然后一路回车，这里会在当前用户生成了一个.ssh的文件夹 将id_rsa.pub公钥的内容复制 打开gitHub的个人中心 打到SSH keys 到此我们便可以通过gitHub 提供的Web界面来管理我们的仓库了。 我们发现通过gitHub管理仓库实在是太方便了，可是只能免费使用公开仓库，自已公司的代码当然不能公开了，可是私有仓库又是需要交“保护费”的，无耐国人还是比较喜欢免费的，网络界总是有很多雷峰的，比如gitLab!!! gitLab也是一个可以通过Web界面管理仓库的网站程序，我们可以把它架设到公司自已的服务器上，实现仓库私有化，这也是大部分公司通常采用的方法，其使用方法与gitHub十分相似。 我将闲置电脑配置成了一台服务器，上面架设了gitLab程序，我们接下来的练习全部会在gitLab上进行演示。 命令汇总git config配置本地仓库 常用git config –global user.name、git config –global user.email git config –list查看配置详情 git init 初始一个仓库，添加–bare可以初始化一个共享（裸）仓库 git status 可以查看当前仓库的状态 git add“文件” 将工作区中的文件添加到暂存区中，其中file可是一个单独的文件，也可以是一个目录、“*”、-A git commit -m ‘备注信息’ 将暂存区的文件，提交到本地仓库 git log 可以查看本地仓库的提交历史 git branch查看分支 git branch“分支名称” 创建一个新的分支 git checkout“分支名称” 切换分支 git checkout -b deeveloper 他健并切到developer分支 git merge“分支名称” 合并分支 git branch -d “分支名称” 删除分支 git clone “仓库地址”获取已有仓库的副本 git push origin “本地分支名称:远程分支名称”将本地分支推送至远程仓库， git push origin hotfix（通常的写法）相当于 git push origin hotfix:hotfix git push origin hotfix:newfeature 本地仓库分支名称和远程仓库分支名称一样的情况下可以简写成一个，即git push “仓库地址” “分支名称”，如果远程仓库没有对应分支，将会自动创建 git remote add “主机名称” “远程仓库地址”添加远程主机，即给远程主机起个别名，方便使用 git remote 可以查看已添加的远程主机 git remote show “主机名称”可以查看远程主机的信息 1.1 GitLab完整演示没错，Git非常强大！ 但是，如果我们的分支不加以规范管理，也有可能适得其反！ 1、不要有太多的树杈（子分支） 2、要有一个“稳定分支”，即master分支不要轻意被修改 3、要有一个开发分支（developer），保证master分支的稳定性 4、所有的功能分支（feature）从developer创建 5、所有功能开发完成后新建发布分支（release） 冲突解决假如两个开发同时改到同一文件的同一段内容会发生什么事情呢？ 这时就会就会产生冲突了，当冲突产生后，需要开发者进行协商确认冲突的原因，然后将冲突代码删除重新提交就可以了。 Git 高级熟悉掌握以上操作，基本上是可以满足日常开的需要的，但是在解决一些特殊问题时，就又需要我们能够掌握更多的命令。 gitignore忽略文件在项目根目录下创建一个.gitignore文件，可以将不希望提交的罗列在这个文件里，如项目的配置文件、node_modules等 https://github.com/github/gitignore 比较差异当内容被修改，我们无法确定修改哪些内容时，可以通过git diff来进行差异比较。 git difftool 比较的是工作区和暂存的差异 git difftool “SHA”比较与特定提交的差异 git difftool “SHA”“SHA”比较某两次提交的差异 git difftool 分支名称 比较与某个分支的差异 回滚（撤销）操作 HEAD 默认指向当前分支的“末端”，即最后的一次提交，但是我们通过git reset 可以改变HEAD的指向。 看情况解释（稍微复杂一些，理解就好） 1、git reset –hard 工作区会变、历史(HEAD)会变， 暂存区也变 –soft 只会变历史(HEAD) –mixed（默认是这个选项）历史(HEAD)会变、暂存区也变，工作区不变 2、git checkout git checkout SHA – “某个文件”，代表只是从SHA这个版中取出特定的文件， 和git reset 是有区别的，reset 重写了历史，checkout 则没有。 更新仓库在项目开发过程中，经常性的会遇到远程（共享）仓库和本地仓库不一致，我们可以通过git fetch 命令来更新本地仓库，使本地仓库和远程（共享）仓库保持一致。 git fetch “远程主机” 或者 git fetch “远程主机” “分支名称” 我们要注意的是，利用git fetch 获取的更新会保存在本地仓库中，但是并没有体现到我们的工作目录中，需要我们再次利用git merge来将对应的分支合并（融合）到特定分支。如下 git pull origin 某个分支， 上操作相当于下面两步 git fetch git merge origin/某个分支 问题：如何查看远程主机上总共有多少个分支？ git branch -a 便可以查看所有(本地+远程仓库)分支了 其它删除远程分支git push origin –delete 分支名称 删除远程分支git push origin :分支名称 Git命令 配置用户信息 全局配置，软件安装目录C:\Program Files\Git\mingw64\etc\gitconfig 用户配置，用户名目录C:\Users\www.gitconfig 项目配置，项目目录 git config –global user.name zhangsan git config –global user.email “zhangsan@163.com” 查看文件状态 git status 查看提交记录(按q键退出) git log 工作区添加到暂存区 git add 暂存区覆盖工作区内容 git checkout 暂存区提交到本地仓库 git commit -m ‘bug fixed’ 回滚特定版本 git reset –hard \]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2017%2F09%2F15%2FJSDOM01%2F</url>
    <content type="text"><![CDATA[DOM-BOMDOM概念及作用DOM-Document Object ModelDOM（文档对象模型）Document-Object-Model。 文档对象模型:一套操作HTML和XML文档的API，就是操作页面元素。JavaScript最终是要操作Html页面，而操作Html页面就要用到DOM。DOM就是把Html页面模拟成一个对象，如果JavaScript只是执行一些计算、循环等操作，而不能操作Html也就失去了它存在的意义。DOM可以把HTML和XML描述为一个文档,树上的每一个分支都可以视为一个对象，通过DOM可以添加、修改和移除文档上的某一部分。 DOM作用:操作页面中的元素的页面中的元素就是标签 html作用:侧重于展示数据 XML作用:侧重于存储数据 xhtml:写的是html代码,遵循的是xml的规范 DOM作用:操作页面元素 DOM模型 DOM中相关的概念123456789101112131415DOM就是把HTML视为一个层次结构(树形结构)的文档,每一个html文件都可以看成是一个文档对象文档(Document)：就是指HTML或者XML文件节点(Node)：HTML文档中的所有内容都可以称之为节点元素(Element)：页面中的标签,标签就是元素,元素就可以看成是对象,标签也是节点,节点比元素大文档元素(根元素)：文档中的第一个元素，HTML标签文本节点：文字内容属性节点：&lt;html lang=“en”&gt;父节点 : parent子节点 : child兄弟节点 : silbing页面中所有的标签都可以看成是一个对象页面中的顶级对象:document页面中有:标签，属性,文本内容标签节点,属性节点,文本节点事件:事件源,触发和响应 DOM级别介绍DOM的级别（了解）DOM0 初级阶段最初浏览器中为了方便检索界面上的元素提供了非常方便的api，查询页面上的元素。实验性质的api称为DOM0 12document.form[0]document.images[0] 随着JavaScript的普及，不同的浏览器分别扩展了JavaScript，此时程序员就苦逼了. 12document.layers["d1"] //Netscapedocument.all["d1"] //IE DOM1 规定了节点的类型Node为了统一浏览器之间的差异W3C制定了DOM1。比如获取浏览器的元素，不同浏览器下都可以使用 1document.getElementById() DOM2:新增了一些方法,但是很多浏览器并不支持DOM3:大多数浏览器都没有支持事件介绍DOM能做什么? 找对象（元素） 设置元素的属性 设置元素的样式 动态创建和删除元素 事件:有事件源,触发和响应,例如:按钮被点了弹出对话框 事件—触发响应 事件源（事件的触发者） 事件名称 事件响应程序 页面中顶级对象 页面中顶级对象 页面中顶级对象浏览器中有多个选项卡,每个选项卡中都可以显示一个页面在页面中html标签为页面的根元素,但是整个页面视为文档对象.所以,在页面中有一个比html元素范围还要大的一个对象而这个对象就是页面的顶级对象—Document结论:要想获取页面中的元素(标签、对象)都可以通过document对象该对象下有一些方法可以获取元素 DOM案例获取元素如何获取页面的元素:document.getElementById(); document:页面的文档对象，可以理解成是页面中的顶级对象,不是浏览器 id:唯一的标识,不能有重复的id,就和身份证号码一样,为了准确找到这个标签(元素、对象) 为元素注册事件使用匿名函数常用 案例：1.点击按钮弹出对话框2.点击按钮修改超链接的地址和热点文字3.点击(每个)图片弹出对话框4.点击图片设置自身宽和高5.点击按钮修改每个图片的title属性6.点击按钮显示哈哈(排他功能)7.点击按钮显示和隐藏div8.显示和隐藏二维码9.点击按钮修改所有p标签内容10.点击按钮修改所有文本框内容11.点击按钮切换图片12.点击超链接停止跳转页面13.点击小图显示大图14.美女相册15点击按钮选中性别和兴趣16.点击按钮选中下拉框选项17.点击按钮设置列表样式18.点击按钮设置div的宽和高19.点击按钮隐藏列表20.点击按钮显示和隐藏div(类样式)21.网页开关灯效果实现22.多个div的高亮显示效果 07总结案例操作DOM对象的属性DOM对象的属性和HTML的标签属性几乎是一致的 案例中操作html基本标签的基本属性 Width/height/src/title/alt/href 案例中操作html表单标签的基本属性 Value/checked/disabled/selected/innerText 阻止超链接跳转:return false 事件源:按钮 事件名:click 事件处理函数:匿名函数 理解DOM页面中所有的内容(标签,换行,文字)实际上都是字符串如果想要获取某个标签,其实就是要找到这个字符串,如果没有dom,获取方式很麻烦,通过dom,页面上的每一个标签都是对象,这个时候获取就会非常的方便理解:DOM就是把html中的所有的标签模拟成一个树形结构图,然后每一个标签就是一个元素,每一个元素就是一个对象 Dom把html中所有的内容都视为对象。所以,无论是标签还是回车换行还是空白都是对象,标签就更不在话下了.既然如此,我们就可以更方便的控制这些标签(控制这些对象)如果能找到标签(对象),那么就可以控制这个标签 注意:class在js中是关键字,关键字和保留字不能作为变量名使用所以,在dom中class这个属性名做了修改:className 理解DOM操作在页面中通过DOM操作页面中元素的时候,页面中的元素的样式或者显示方式发生了改变,但是并没有修改原来的页面内容,而是修改的当前这个页面的样子,换句话说: 通过网址访问的页面,访问的是服务器端的页面,通过网络,把服务器的页面下载到我们的本地,然后加载到内存中,渲染引擎在加载页面的同时会在内存中生成一个DOM树 所以,DOM操作的是本地内存中的内容,并不会更改服务器端的页面样子简单的理解方式: 自己电脑中DOM操作后影响的是自己的页面,其他人的页面不会受影响分析:上面的案例中是否需要传入参数?不需要 添加事件的三种写法（重点） 三种注册方式中的this 第一种注册方式:this指的是当前的按钮对象 第二种注册方式:第二种在匿名函数中使用的this也是当前的对象 第三种注册方式:第三种fn中使用的this在触发点击事件的时候,this也是按钮对象 理解事件处理中的this就0[是当前对象]]></content>
  </entry>
  <entry>
    <title><![CDATA[JS特效]]></title>
    <url>%2F2017%2F09%2F07%2Fjs%E7%89%B9%E6%95%88%2F</url>
    <content type="text"><![CDATA[js特效元素隐藏消失 特效思路： 1.确定需要出现的div的和样式，为红色的div设置display:none 2.以通过id名的方式获取页面中对应的两个元素 3.为checkbox绑定鼠标进入事件onmouseover，在事件处理函数中将红色div的设置 dom对象.style.display = &quot;block&quot; 4..为checkbox绑定鼠标离开事件onmouseout，在事件处理函数中将红色div的设置 dom对象.style.display = &quot;none&quot; 代码演示 下拉菜单 特效思路： 1.写好html结构和样式，为要隐藏的子元素ul设置 display: none 2.为整个最外层元素设置鼠标进入事件，和鼠标离开事件，分别设置 dom对象.style.display = &quot;block&quot;和 dom对象.style.display = &quot;none&quot; 3.为 li 中的 a 标签设置 a:hover{background:aqua;} 代码演示 点击创建小方块 特效思路： 1.先初始化小方块的样式，宽高以及设置为绝对定位，创建一个颜色数组 arrColor= [&quot;red&quot;, &quot;yellow&quot;, &quot;blue&quot;, &quot;green&quot;] 2.创建一个空字符串用于拼接，进行for循环遍历var left = (i%10)*60+50; //left值的规律 var top = parseInt(i/10)*60+50;//top值的规律 rrColor[i%arrColor.length]//颜色的值 3.获取容器对象通过innerHTML插入到文档中 代码演示 基于jquery的手风琴特效 特效思路： 1.先布置静态结构和样式，获取全部h3标签，绑定鼠标点击事件，为当前h3添加背景为蓝色样式，移除其他兄弟h3.siblings元素的背景色样式 2.为所有h3标签绑定鼠标进入和离开事件，为下一个next元素进行show 显示和hide隐藏 1234//所用到的api函数on() addClass() removeClass() siblings() next() show() hide() //所用到事件click事件 mouseenter事件 mouseleave事件 代码演示 显示当前系统时间 特效思路： 1.利用内置对象Date中的一些api，特别注意要处理一下，getDay()所返回的星期数为0-6，0为星期日 2.封装一个小函数来补零，进行字符串拼接 3.通过setInterval间隔1s调用一次 代码演示 模拟时钟 特效思路： 1.布置布局和样式，将三个div的背景图完全重叠，获取当前的小时分钟秒需要注意的是，秒针每秒转6度，分针每小时转6度，时针每小时转30度。 2.设置三张图片的旋转角度 12345678//360度 60秒 1秒 6度$("ss").style.transform = "rotate(" + ( (s + ms / 1000) * 6) + "deg)";// 分针 转一圈360 60分账 1分钟 6度$("mm").style.transform = "rotate(" + (m * 6 + (s * 6) / 60) + "deg)";// 一圈360度 12小时 1小时 30// var aa = (m*6+(s*6)/60)/360*30var aa = (m * 6 + (s * 6) / 60) / 12;$("hh").style.transform = "rotate(" + (h * 30 + aa) + "deg)"; 代码演示 倒计时效果 特效思路： 1.完成静态布局和样式 2.未来时间减去现在时间的差越来越小最后为0，结束倒计时。 3.通过获取文本框1的value值，来构造未来时间的对象，设置setInterval，设置当前时间对象，做一下差值并换算，每隔1000ms设置一次文本框2的value值， 代码演示 特效思路 1.先把字符串通过charCodeAt()方法转化成对应的unicode 2.unicode统一减去200（任意数值，这里去值为200），把得到的unicode码通过String.fromCharCode()方法转换成对应的字符 代码演示]]></content>
  </entry>
  <entry>
    <title><![CDATA[HTTP API 设计指南]]></title>
    <url>%2F2017%2F09%2F02%2FHTTP%20API%20%E8%AE%BE%E8%AE%A1%E6%8C%87%E5%8D%97%EF%BC%88%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86%EF%BC%89%2F</url>
    <content type="text"><![CDATA[HTTP API 设计指南（基础部分）隔离关注点设计时通过将请求和响应之间的不同部分隔离来让事情变得简单。保持简单的规则让我们能更关注在一些更大的更困难的问题上。 请求和响应将解决一个特定的资源或集合。使用路径（path）来表明身份，body来传输内容（content）还有头信息（header）来传递元数据（metadata）。查询参数同样可以用来传递头信息的内容，但头信息是首选，因为他们更灵活、更能传达不同的信息。 强制使用安全连接（Secure Connections）所有的访问API行为，都需要用 TLS 通过安全连接来访问。没有必要搞清或解释什么情况需要 TLS 什么情况不需要 TLS，直接强制任何访问都要通过 TLS。理想状态下，通过拒绝所有非 TLS 请求，不响应 http 或80端口的请求以避免任何不安全的数据交换。如果现实情况中无法这样做，可以返回403 Forbidden响应。 把非 TLS 的请求重定向(Redirect)至 TLS 连接是不明智的，这种含混/不好的客户端行为不会带来明显好处。依赖于重定向的客户端访问不仅会导致双倍的服务器负载，还会使 TLS 加密失去意义，因为在首次非 TLS 调用时，敏感信息就已经暴露出去了。 强制头信息 Accept 中提供版本号制定版本并在版本之间平缓过渡对于设计和维护一套API是个巨大的挑战。所以，最好在设计之初就使用一些方法来预防可能会遇到的问题。 为了避免API的变动导致用户使用中产生意外结果或调用失败，最好强制要求所有访问都需要指定版本号。请避免提供默认版本号，一旦提供，日后想要修改它会相当困难。 最适合放置版本号的位置是头信息(HTTP Headers)，在 Accept 段中使用自定义类型(content type)与其他元数据(metadata)一起提交。例如: 1Accept: application/vnd.heroku+json; version=3 支持Etag缓存在所有返回的响应中包含ETag头信息，用来标识资源的版本。这让用户对资源进行缓存处理成为可能，在后续的访问请求中把If-None-Match头信息设置为之前得到的ETag值，就可以侦测到已缓存的资源是否需要更新。 为内省而提供 Request-Id为每一个请求响应包含一个Request-Id字段，并使用UUID作为该值。通过在客户端、服务器或任何支持服务上记录该值，它能主我们提供一种机制来跟踪、诊断和调试请求。 通过请求中的范围（Range）拆分大的响应一个大的响应应该通过多个请求使用Range头信息来拆分，并指定如何取得。详细的请求和响应的头信息（header），状态码(status code)，范围(limit)，排序(ordering)和迭代(iteration)等，参考Heroku Platform API discussion of Ranges. HTTP API 设计指南（请求部分）前言这篇指南介绍描述了 HTTP+JSON API 的一种设计模式，最初摘录整理自 Heroku 平台的 API 设计指引 Heroku 平台 API 指引。 这篇指南除了详细介绍现有的 API 外，Heroku 将来新加入的内部 API 也会符合这种设计模式，我们希望非 Heroku 员工的API设计者也能感兴趣。 我们的目标是保持一致性，专注业务逻辑同时避免过度设计。我们一直试图找出一种良好的、一致的、显而易见的 API 设计方法，而并不是所谓的”最终/理想模式”。 我们假设你熟悉基本的 HTTP+JSON API 设计方法，所以本篇指南并不包含所有的 API 设计基础。 我们欢迎你为这篇指南做贡献。 返回合适的状态码为每一次的响应返回合适的HTTP状态码。 好的响应应该使用如下的状态码: 200: GET请求成功，及DELETE或PATCH同步请求完成，或者PUT同步更新一个已存在的资源 201: POST 同步请求完成，或者PUT同步创建一个新的资源 202: POST，PUT，DELETE，或PATCH请求接收，将被异步处理 206: GET 请求成功，但是只返回一部分，参考：上文中范围分页 使用身份认证（authentication）和授权（authorization）错误码时需要注意： 401 Unauthorized: 用户未认证，请求失败 403 Forbidden: 用户无权限访问该资源，请求失败 当用户请求错误时，提供合适的状态码可以提供额外的信息： 422 Unprocessable Entity: 请求被服务器正确解析，但是包含无效字段 429 Too Many Requests: 因为访问频繁，你已经被限制访问，稍后重试 500 Internal Server Error: 服务器错误，确认状态并报告问题 对于用户错误和服务器错误情况状态码，参考： HTTP response code spec 提供全部可用的资源提供全部可显现的资源 (例如： 这个对象的所有属性) ，当响应码为200或是201时返回所有可用资源，包含 PUT/PATCH 和 DELETE请求，例如: 123456789101112$ curl -X DELETE \ https://service.com/apps/1f9b/domains/0fd4HTTP/1.1 200 OKContent-Type: application/json;charset=utf-8...&#123; "created_at": "2012-01-01T12:00:00Z", "hostname": "subdomain.example.com", "id": "01234567-89ab-cdef-0123-456789abcdef", "updated_at": "2012-01-01T12:00:00Z"&#125; 当请求状态码为202时，不返回所有可用资源，例如： 1234567$ curl -X DELETE \ https://service.com/apps/1f9b/dynos/05bdHTTP/1.1 202 AcceptedContent-Type: application/json;charset=utf-8...&#123;&#125; 在请求的body体使用JSON格式数据在 PUT/PATCH/POST 请求的正文（request bodies）中使用JSON格式数据，而不是使用 form 表单形式的数据。这与我们使用JSON格式返回请求相对应，例如: 12345678910111213$ curl -X POST https://service.com/apps \ -H "Content-Type: application/json" \ -d '&#123;"name": "demoapp"&#125;'&#123; "id": "01234567-89ab-cdef-0123-456789abcdef", "name": "demoapp", "owner": &#123; "email": "username@example.com", "id": "01234567-89ab-cdef-0123-456789abcdef" &#125;, ...&#125; 使用统一的资源路径格式资源名（Resource names）使用复数形式为资源命名，除非这个资源在系统中是单例的 (例如，在大多数系统中，给定的用户帐户只有一个)。 这种方式保持了特定资源的统一性。 行为（Actions）好的末尾不需要为资源指定特殊的行为，但在特殊情况下，为某些资源指定行为却是必要的。为了描述清楚，在行为前加上一个标准的actions： 1/resources/:resource/actions/:action 例如： 1/runs/&#123;run_id&#125;/actions/stop 路径和属性要小写为了和域名命名规则保持一致，使用小写字母并用-分割路径名字，例如： 12service-api.com/usersservice-api.com/app-setups 属性也使用小写字母，但是属性名要用下划线_分割，以便在Javascript中省略引号。 例如： 1service_class: "first" 支持方便的无id间接引用在某些情况下，让用户提供ID去定位资源是不方便的。例如，一个用户想取得他在Heroku平台app信息，但是这个app的唯一标识是UUID。这种情况下，你应该支持接口通过名字和ID都能访问，例如: 123$ curl https://service.com/apps/&#123;app_id_or_name&#125;$ curl https://service.com/apps/97addcf0-c182$ curl https://service.com/apps/www-prod 不要只接受使用名字而放弃了使用id。 最小化路径嵌套在一些有父路径/子路径嵌套关系的资源数据模块中，路径可能有非常深的嵌套关系，例如: 1/orgs/&#123;org_id&#125;/apps/&#123;app_id&#125;/dynos/&#123;dyno_id&#125; 推荐在根(root)路径下指定资源来限制路径的嵌套深度。使用嵌套指定范围的资源。在上述例子中，dyno属于app，app属于org可以表示为： 12345/orgs/&#123;org_id&#125;/orgs/&#123;org_id&#125;/apps/apps/&#123;app_id&#125;/apps/&#123;app_id&#125;/dynos/dynos/&#123;dyno_id&#125; HTTP API 设计指南（响应部分）前言这篇指南介绍描述了 HTTP+JSON API 的一种设计模式，最初摘录整理自 Heroku 平台的 API 设计指引 Heroku 平台 API 指引。 这篇指南除了详细介绍现有的 API 外，Heroku 将来新加入的内部 API 也会符合这种设计模式，我们希望非 Heroku 员工的API设计者也能感兴趣。 我们的目标是保持一致性，专注业务逻辑同时避免过度设计。我们一直试图找出一种良好的、一致的、显而易见的 API 设计方法，而并不是所谓的”最终/理想模式”。 我们假设你熟悉基本的 HTTP+JSON API 设计方法，所以本篇指南并不包含所有的 API 设计基础。 我们欢迎你为这篇指南做贡献。 提供资源的(UU)ID在默认情况给每一个资源一个id属性。除非有更好的理由，否则请使用UUID。不要使用那种在服务器上或是资源中不是全局唯一的标识，尤其是自动增长的id。 生成小写的UUID格式 8-4-4-4-12，例如： 1"id": "01234567-89ab-cdef-0123-456789abcdef" 提供标准的时间戳为资源提供默认的创建时间 created_at 和更新时间 updated_at，例如: 123456&#123; ... "created_at": "2012-01-01T12:00:00Z", "updated_at": "2012-01-01T13:00:00Z", ...&#125; 有些资源不需要使用时间戳那么就忽略这两个字段。 使用UTC（世界标准时间）时间，用ISO8601进行格式化在接收和返回时都只使用UTC格式。ISO8601格式的数据，例如: 1"finished_at": "2012-01-01T12:00:00Z" 嵌套外键关系使用嵌套对象序列化外键关联，例如: 1234567&#123; "name": "service-production", "owner": &#123; "id": "5d8201b0..." &#125;, // ...&#125; 而不是像这样: 12345&#123; "name": "service-production", "owner_id": "5d8201b0...", ...&#125; 这种方式尽可能的把相关联的资源信息内联在一起，而不用改变资源的结构，或者引入更多的字段，例如: 123456789&#123; "name": "service-production", "owner": &#123; "id": "5d8201b0...", "name": "Alice", "email": "alice@heroku.com" &#125;, ...&#125; 生成结构化的错误响应错误的时，生成统一的、结构化的错误信息。包含一个机器可读的错误 id，一个人类能识别的错误信息（message），根据情况可以添加一个url来告诉客户端关于这个错误的更多信息以及如何去解决它，例如: 1HTTP/1.1 429 Too Many Requests 12345&#123; "id": "rate_limit", "message": "Account reached its API rate limit.", "url": "https://docs.service.com/rate-limits"&#125; 文档化客户端可能遇到的错误信息格式，以及这些可能的错误信息id。 显示频率限制状态客户端的访问速度限制可以维护服务器的良好状态，保证为其他客户端请求提供高性的服务。你可以使用token bucket algorithm技术量化请求限制。 为每一个带有RateLimit-Remaining响应头的请求，返回预留的请求tokens。 保证响应JSON最小化请求中多余的空格会增加响应大小，而且现在很多的HTTP客户端都会自己输出可读格式（”prettify”）的JSON。所以最好保证响应JSON最小化，例如： 1&#123;"beta":false,"email":"alice@heroku.com","id":"01234567-89ab-cdef-0123-456789abcdef","last_login":"2012-01-01T12:00:00Z","created_at":"2012-01-01T12:00:00Z","updated_at":"2012-01-01T12:00:00Z"&#125; 而不是这样： 12345678&#123; "beta": false, "email": "alice@heroku.com", "id": "01234567-89ab-cdef-0123-456789abcdef", "last_login": "2012-01-01T12:00:00Z", "created_at": "2012-01-01T12:00:00Z", "updated_at": "2012-01-01T12:00:00Z"&#125; 你可以提供可选的方式为客户端提供更详细可读的响应，使用查询参数（例如：?pretty=true）或者通过Accept头信息参数（例如：Accept: application/vnd.heroku+json; version=3; indent=4;） HTTP API 设计指南（结尾）前言这篇指南介绍描述了 HTTP+JSON API 的一种设计模式，最初摘录整理自 Heroku 平台的 API 设计指引 Heroku 平台 API 指引。 这篇指南除了详细介绍现有的 API 外，Heroku 将来新加入的内部 API 也会符合这种设计模式，我们希望非 Heroku 员工的API设计者也能感兴趣。 我们的目标是保持一致性，专注业务逻辑同时避免过度设计。我们一直试图找出一种良好的、一致的、显而易见的 API 设计方法，而并不是所谓的”最终/理想模式”。 我们假设你熟悉基本的 HTTP+JSON API 设计方法，所以本篇指南并不包含所有的 API 设计基础。 我们欢迎你为这篇指南做贡献。 提供机器可读的JSON模式提供一个机器可读的模式来恰当的表现你的API。使用prmd管理你的模式，并且确保用prmd verify验证是有效的。 提供人类可读的文档提供人类可读的文档让客户端开发人员可以理解你的API。 如果你用prmd创建了一个概要并且按上述要求描述，你可以为所有节点很容易的使用prmd doc生成Markdown文档。 除了节点信息，提供一个API概述信息: 验证授权，包含如何取得和如何使用token。API稳定及版本管理，包含如何选择所需要的版本。一般情况下的请求和响应的头信息。错误的序列化格式。不同编程语言客户端使用API的例子。 提供可执行的例子提供可执行的示例让用户可以直接在终端里面看到API的调用情况，最大程度的让这些示例可以简单的使用，以减少用户尝试使用API的工作量。例如: $ export TOKEN=… # acquire from dashboard$ curl -is https://$TOKEN@service.com/users如果你使用prmd生成Markdown文档，每个节点都会自动获取一些示例。 描述稳定性描述您的API的稳定性或是它在各种各样节点环境中的完备性和稳定性，例如：加上 原型版（prototype）/开发版（development）/产品版（production）等标记。 更多关于可能的稳定性和改变管理的方式，查看 Heroku API compatibility policy 一旦你的API宣布产品正式版本及稳定版本时，不要在当前API版本中做一些不兼容的改变。如果你需要，请创建一个新的版本的API。]]></content>
  </entry>
  <entry>
    <title><![CDATA[js设置a标签href不跳转 禁止跳转]]></title>
    <url>%2F2017%2F08%2F10%2Fjs%E8%AE%BE%E7%BD%AEa%E6%A0%87%E7%AD%BEhref%E4%B8%8D%E8%B7%B3%E8%BD%AC%20%E7%A6%81%E6%AD%A2%E8%B7%B3%E8%BD%AC%2F</url>
    <content type="text"><![CDATA[1.方法当页面中a标签不需要任何跳转时，从原理上来讲，可分如下两种方法： 1.标签属性href，使其指向空或不返回任何内容。如： 123&lt;a href="javascript:void(0);" &gt;点此无反应javascript:void(0)&lt;/a&gt;&lt;a href="javascript:;" &gt;点此无反应javascript:&lt;/a&gt;123 2.标签事件onclick，阻止其默认行为。如： 123&lt;a href="" onclick="return false;"&gt;return false;&lt;/a&gt;&lt;a href="#" onclick="return false;"&gt;return false;&lt;/a&gt;123 注意：只有一个href=”#”是不可以的。 2.原理1.标签属性href=”javascript:void(0);” 关键是理解void(0)的含义。javascript中void是一个操作符，该操作符指定要计算一个表达式但是不返回值 用法格式如下： a). javascript:void (expression) b). javascript:void expression 你以使用 void 操作符指定超级链接。表达式会被计算但是不会当前文档处装入任何内容。所以，javascript:void(0) 仅仅表示一个死链接。 只有href=”#”是不可以的，因为#包含了一个位置信息，默认的锚是#top 也就是网页的上端。我理解的锚是指网页中具体位置。 例如： 首先我们在网页body内最上面添加一个 1&lt;span id="top" name="top"&gt;&lt;/span&gt;1 我们再到body内，需要出现点击后转到顶部位置添加， 1&lt;a href="#top"&gt;回到顶部&lt;/a&gt;1 点击回到顶部即可让滚动回到顶部。 标签事件onclick=”return false;” 在HTML代码中，无论你在哪里放置了onclick事件，并且返回值为false时，那么该处的默认行为将不会执行。这里的默认行为是指没有Onclick事件时原本的行为。最后，我们来回顾下a标签的三种用法： 12345&lt;a href="http://www.w3school.com.cn"&gt;W3School&lt;/a&gt;&lt;a href="index.html"&gt; index &lt;/a&gt;&lt;a href="#top"&gt;top&lt;/a&gt;]]></content>
      <categories>
        <category>js知识</category>
      </categories>
      <tags>
        <tag>a标签</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Canvas实现的刮刮乐效果]]></title>
    <url>%2F2017%2F03%2F10%2FCanvas%E5%AE%9E%E7%8E%B0%E5%88%AE%E5%88%AE%E4%B9%90%E6%95%88%E6%9E%9C%2F</url>
    <content type="text"><![CDATA[使用canvas实现的简单刮刮乐效果 index.html 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;刮刮乐&lt;/title&gt; &lt;link rel="stylesheet" href="css/index.css"&gt;&lt;/head&gt;&lt;body&gt; &lt;canvas width="400" height="300"&gt;&lt;/canvas&gt; &lt;script src="js/index.js"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; index.css 12345678910body &#123; margin: 0; padding: 0; &#125;canvas &#123; border: 1px solid #ccc; background: #ccc; margin: 100px auto; display: block;&#125; index.js 12345678910111213141516171819202122232425262728293031var ctx = document.querySelector('canvas').getContext('2d')var img = new Image()img.onload = function () &#123; // 设置填充方案 var pat = ctx.createPattern(img, 'no-repeat') ctx.strokeStyle = pat //设置线的样式 （包括线宽，线帽，拐点） ctx.lineWidth = 25 ctx.lineCap = 'round' ctx.lineJoin = 'round' //设置一个阈值 var isDown = false //绑定鼠标按下事件 ctx.canvas.addEventListener('mousedown', function (e) &#123; ctx.moveTo(e.clientX - ctx.canvas.offsetLeft, e.clientY -ctx.canvas.offsetTop) isDown = true &#125;) //绑定鼠标移动事件 ctx.canvas.addEventListener('mousemove', function (e) &#123; if (isDown) &#123; ctx.lineTo(e.clientX - ctx.canvas.offsetLeft, e.clientY -ctx.canvas.offsetTop) ctx.stroke() &#125; &#125;) //绑定鼠标抬起事件 ctx.canvas.addEventListener('mouseup', function () &#123; isDown = false &#125;)&#125;/* 设置图片资源路径 */img.src = '../images/xiexie.png']]></content>
      <categories>
        <category>canvas</category>
      </categories>
      <tags>
        <tag>canvas</tag>
        <tag>刮刮乐</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Canvas相关知识]]></title>
    <url>%2F2017%2F03%2F10%2Fmycanvas%2F</url>
    <content type="text"><![CDATA[canvas 最早由Apple引入WebKit,用于Mac OS X 的 Dashboard,后来又在Safari和Google Chrome被实现。 基于 Gecko 1.8的浏览器,比如 Firefox 1.5, 同样支持这个元素。&lt;canvas&gt; 元素是WhatWG Web applications 1.0规范的一部分,也包含于HTML 5中。 什么是Canvas？ canvas 是一个 HTML5元素，中文翻译是画布，但是本事没有绘画的功能，需要通过javascript在上面绘制图像。 canvas是一个矩形区域，（算是内联可置换元素在chrome中display默认值为 inline），可以控制其中的每一像素默认大小是 300 * 150 ，浏览器在解析的时候会按图片进行处理 canvas 拥有多种绘制路径、矩形、圆形、字符以及添加图像的方法。 创建Canvas元素向 HTML5 页面添加 canvas 元素。规定元素的 id、宽度和高度：（在style标签中为其设置宽高属性也是起作用的但是并不推荐这么做） 1&lt;canvas id="myCanvas" width="600" height="400"&gt;&lt;/canvas&gt; Canvas坐标系 通过JavaScript来绘制 12345678&lt;!- 为了效果明显，加了一点样式 -&gt;&lt;style&gt; canvas&#123; border: 1px solid #ccc; margin: 0 auto; display: block; &#125;&lt;/style&gt; 12345678910/*获取元素*/var myCanvas = document.querySelector('#myCanvas')/*获取绘图工具（也可以叫做绘制环境）*/var context = myCanvas.getContext('2d')/*设置绘图的起始位置*/context.moveTo(100,100)/*绘制路径*/context.lineTo(200,200)/*描边*/context.stroke() Canvas的基本使用图形绘制需要理解些概念： 路径的概念 路径的绘制 描边 stroke() 填充 fill() 闭合路径 手动闭合 程序闭合 closePath() 填充规则(非零环绕) 开启新的路径 beginPath() 设置样式 画笔的状态 lineWidth 线宽，默认1px lineCap 线末端类型：(butt默认)、round、square lineJoin 相交线的拐点 miter(默认)、round、bevel strokeStyle 线的颜色 fillStyle 填充颜色 setLineDash() 设置虚线 getLineDash() 获取虚线宽度集合 lineDashOffset 设置虚线偏移量（负值向右偏移） 此处的坑 123456/*canvas所绘制的线条本质就是一定数量的默认大小为1px颜色为黑色的像素点的结合，以坐标的中心绘制,但浏览器无发显示0.5px，chrome处理方式是把把线宽扩大到2px但是，毕竟这并不是真正设置2px的线宽，所以做了将颜色变浅以示区分。解决方案：1. 当设置线宽为单数的时候，手动将其y轴方向进行0.5px的增减，换句话说就是把这条线放到浏览器能正常显示的像素格内，避免浏览器进行线条虚化操作。2. 将线宽设置为偶数，但要注意canvas线条位置的渲染方式，计算好真正想让线条出现的位置*/ 实例练习 绘制平行线不同颜色 1234567891011121314151617181920212223/*1.获取canvas元素*/ var canvas = document.querySelector('canvas'); /*2.获取绘制环境 （获取绘制工具）*/ /*content内容 context 上下文 */ var ctx = canvas.getContext('2d'); /*3.设置起始绘图的位置*/ ctx.moveTo(100,100); /*6.设置宽度*/ ctx.lineWidth = 10; /*4.绘制路径 */ ctx.lineTo(200,100); /*7. 设置描边的颜色*/ ctx.strokeStyle = 'red'; /*5.描边*/ ctx.stroke(); /*绿色*/ /*再次绘制的时候 会使用之前设置的样式 设置的样式最后的会生效*/ /*开启新路径*/ ctx.beginPath(); ctx.moveTo(100,200); ctx.lineTo(200,200); ctx.strokeStyle = 'green'; ctx.stroke(); 绘制一个三角形 12345678910111213141516var canvas = document.querySelector('canvas'); /*获取绘图工具*/ var ctx = canvas.getContext('2d'); /*3d目前还不支持*//*webgl*/ /*移动画笔*/ ctx.moveTo(100,100); ctx.lineTo(200,100); ctx.lineTo(200,200); ctx.lineWidth = 10; /*自动闭合*/ ctx.closePath(); // ctx.stroke(); ctx.strokeStyle = 'red'; ctx.stroke(); /*填充*/ ctx.fillStyle = 'orange'; ctx.fill(); 镂空的正方形 12345678910111213141516var canvas = document.querySelector('canvas'); /*获取绘图工具*/ var ctx = canvas.getContext('2d'); /*3d目前还不支持*//*webgl*/ /*移动画笔*/ ctx.moveTo(100,100); ctx.lineTo(200,100); ctx.lineTo(200,200); ctx.lineWidth = 10; /*自动闭合*/ ctx.closePath(); // ctx.stroke(); ctx.strokeStyle = 'red'; ctx.stroke(); /*填充*/ ctx.fillStyle = 'skyblue'; ctx.fill(); 线的两端样式 123456789101112131415161718192021222324var canvas = document.querySelector('canvas'); /*获取绘图工具*/ var ctx = canvas.getContext('2d'); /*3d目前还不支持*//*webgl*/ ctx.lineWidth = 10; ctx.moveTo(100,100); ctx.lineTo(200,100); ctx.strokeStyle = 'red'; ctx.lineCap = 'butt'; ctx.stroke(); ctx.beginPath(); ctx.moveTo(100,200); ctx.lineTo(200,200); ctx.strokeStyle = 'green'; ctx.lineCap = 'round'; ctx.stroke(); ctx.beginPath(); ctx.moveTo(100,300); ctx.lineTo(200,300); ctx.strokeStyle = 'skyblue'; ctx.lineCap = 'square'; ctx.stroke(); 线拐点的样式 123456789101112131415161718192021222324252627var canvas = document.querySelector('canvas'); /*获取绘图工具*/ var ctx = canvas.getContext('2d'); /*3d目前还不支持*//*webgl*/ ctx.lineWidth = 10; ctx.moveTo(100,100); ctx.lineTo(150,150); ctx.lineTo(200,100); ctx.strokeStyle = 'red'; ctx.lineJoin = 'miter'; ctx.stroke(); ctx.beginPath(); ctx.moveTo(100,200); ctx.lineTo(150,250); ctx.lineTo(200,200); ctx.strokeStyle = 'green'; ctx.lineJoin = 'round'; ctx.stroke(); ctx.beginPath(); ctx.moveTo(100,300); ctx.lineTo(150,350); ctx.lineTo(200,300); ctx.strokeStyle = 'pink'; ctx.lineJoin = 'bevel'; ctx.stroke(); 绘制渐变的线 1234567891011121314151617var canvas = document.querySelector('canvas'); /*获取绘图工具*/ var ctx = canvas.getContext('2d'); /*3d目前还不支持*//*webgl*/ /*1.从左到右*/ /*2.起始颜色 白色*/ /*3.结束颜色 红色*/ ctx.lineWidth = 10; for (var i = 0; i &lt; 255; i++) &#123; ctx.beginPath(); ctx.moveTo(99+i,100); ctx.lineTo(100+i,100); var g = 255 - i; var b = 255 - i; ctx.strokeStyle = 'rgb(255,'+g+','+b+')'; ctx.stroke(); &#125; 绘制虚线 12345678910111213141516171819202122232425262728293031323334353637383940var canvas = document.querySelector('canvas'); /*获取绘图工具*/ var ctx = canvas.getContext('2d'); /*3d目前还不支持*//*webgl*/ ctx.moveTo(100,100) ctx.lineTo(500,100) ctx.setLineDash([5]); console.log(ctx.getLineDash()); ctx.stroke(); ctx.beginPath(); ctx.moveTo(100,200); ctx.lineTo(500,200); /*绘制虚线的方法*/ /*传数组 设置虚线长度的*/ ctx.setLineDash([5,10]); /*如果是偶数个数设置 */ /*如果是奇数数个数设置 */ /*获取的不重复的一段*/ console.log(ctx.getLineDash()); ctx.stroke(); ctx.beginPath(); ctx.moveTo(100,300) ctx.lineTo(500,300) ctx.setLineDash([5,10,15]); console.log(ctx.getLineDash()); ctx.stroke();var canvas = document.querySelector('canvas'); /*获取绘图工具*/ var ctx = canvas.getContext('2d'); /*3d目前还不支持*//*webgl*/ ctx.moveTo(100,100); ctx.lineTo(500,100); /*绘制虚线的方法*/ /*传数组 设置虚线长度的*/ ctx.setLineDash([5,10,15]); /*如果是偶数个数设置 */ /*如果是奇数数个数设置 */ /*获取的不重复的一段*/ console.log(ctx.getLineDash()); ctx.stroke(); 绘制坐标系方法一 12345678910111213141516171819202122232425262728293031var canvas = document.querySelector('canvas'); /*获取绘图工具*/ var ctx = canvas.getContext('2d'); /*3d目前还不支持*//*webgl*/ /*1.确定间隔 20 */ var space = 20; /*2.计算原点*/ var width = ctx.canvas.width; var height = ctx.canvas.height; var x0 = 0 + space; var y0 = height - space; /*假设 箭头大小 8px*/ var arrowSize = 10; /*绘制x轴*/ ctx.moveTo(x0,y0); ctx.lineTo(width-space,y0); ctx.lineTo(width-space-arrowSize,y0+arrowSize/2); ctx.lineTo(width-space-arrowSize,y0-arrowSize/2); ctx.lineTo(width-space,y0); ctx.stroke(); ctx.fill(); /*绘制y轴*/ ctx.moveTo(x0,y0); ctx.lineTo(space,space); ctx.lineTo(space+arrowSize/2,space+arrowSize); ctx.lineTo(space-arrowSize/2,space+arrowSize); ctx.lineTo(space,space); ctx.stroke(); ctx.fill(); 方法二:面向对象方式 123456789101112131415161718192021222324252627282930313233343536var DrawAxis = function () &#123; /*绘图工具*/ this.ctx = document.querySelector('canvas').getContext('2d'); /*间距*/ this.space = 20; /*画布的尺寸*/ this.width = this.ctx.canvas.width; this.height = this.ctx.canvas.height; /*原点*/ this.x0 = this.space; this.y0 = this.height - this.space; /*箭头尺寸*/ this.arrowSize = 10; &#125; /*绘制方法*/ DrawAxis.prototype.draw = function () &#123; /*x轴*/ this.ctx.moveTo(this.x0,this.y0); this.ctx.lineTo(this.width-this.space,this.y0); this.ctx.lineTo(this.width-this.space-this.arrowSize,this.y0+this.arrowSize/2); this.ctx.lineTo(this.width-this.space-this.arrowSize,this.y0-this.arrowSize/2); this.ctx.lineTo(this.width-this.space,this.y0); this.ctx.stroke(); this.ctx.fill(); /*y轴*/ this.ctx.moveTo(this.x0,this.y0); this.ctx.lineTo(this.space,this.space); this.ctx.lineTo(this.space+this.arrowSize/2,this.space+this.arrowSize); this.ctx.lineTo(this.space-this.arrowSize/2,this.space+this.arrowSize); this.ctx.lineTo(this.space,this.space); this.ctx.stroke(); this.ctx.fill(); &#125; var drawAxis = new DrawAxis(); drawAxis.draw(); ​ 绘制坐标点 方法一 123456789101112131415161718192021var canvas = document.querySelector('canvas'); /*获取绘图工具*/ var ctx = canvas.getContext('2d'); /*3d目前还不支持*//*webgl*/ /*点坐标*/ var dotted = &#123; x: 200, y: 100 &#125; /*点大小*/ var edge = 8; /*画笔的起始位置*/ ctx.moveTo(dotted.x - edge / 2, dotted.y - edge / 2); ctx.lineTo(dotted.x + edge / 2, dotted.y - edge / 2); ctx.lineTo(dotted.x + edge / 2, dotted.y + edge / 2); ctx.lineTo(dotted.x - edge / 2, dotted.y + edge / 2); ctx.closePath(); ctx.fill(); 方法二：面向对象 12345678910111213141516171819var DrawDotted = function () &#123; this.ctx = document.querySelector('canvas').getContext('2d'); this.edge = 10; &#125; /*dotted 对象 x y 轴坐标*/ DrawDotted.prototype.draw = function (dotted) &#123; this.ctx.beginPath(); this.ctx.moveTo(dotted.x-this.edge/2,dotted.y-this.edge/2); this.ctx.lineTo(dotted.x+this.edge/2,dotted.y-this.edge/2); this.ctx.lineTo(dotted.x+this.edge/2,dotted.y+this.edge/2); this.ctx.lineTo(dotted.x-this.edge/2,dotted.y+this.edge/2); this.ctx.closePath(); this.ctx.fill(); &#125; var drawDotted = new DrawDotted(); drawDotted.draw(&#123;x:100,y:100&#125;); drawDotted.draw(&#123;x:100,y:200&#125;); drawDotted.draw(&#123;x:200,y:200&#125;); ​ 绘制折线图 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586/*假设一组 基于坐标轴的*/ var data = [ &#123;x: 100, y: 80&#125;, &#123;x: 200, y: 120&#125;, &#123;x: 300, y: 250&#125;, &#123;x: 400, y: 340&#125;, &#123;x: 500, y: 230&#125; ]; var LineChart = function () &#123; /*绘制工具*/ this.ctx = document.querySelector('canvas').getContext('2d'); /*坐标原点*/ this.space = 20; this.width = this.ctx.canvas.width; this.height = this.ctx.canvas.height; this.x0 = this.space; this.y0 = this.height - this.space; /*箭头大小*/ this.arrow = 10; /*点相关 点大小*/ this.edge = 10; &#125; /*初始化方法*/ LineChart.prototype.init = function (data) &#123; this.drawAxis(); this.drawDotted(data); &#125; /*绘制坐标轴*/ LineChart.prototype.drawAxis = function () &#123; /*X轴*/ this.ctx.moveTo(this.x0, this.y0); this.ctx.lineTo(this.width - this.space, this.y0); this.ctx.lineTo(this.width - this.space - this.arrow, this.y0 + this.arrow/2); this.ctx.lineTo(this.width - this.space - this.arrow, this.y0 - this.arrow/2); this.ctx.lineTo(this.width - this.space, this.y0); this.ctx.stroke(); this.ctx.fill(); /*Y轴*/ this.ctx.moveTo(this.x0, this.y0); this.ctx.lineTo(this.space, this.space); this.ctx.lineTo(this.space + this.arrow/2, this.space + this.arrow); this.ctx.lineTo(this.space - this.arrow/2, this.space + this.arrow); this.ctx.lineTo(this.space, this.space); this.ctx.stroke(); this.ctx.fill(); &#125; /*转换点坐标*/ LineChart.prototype.formatDot = function (data) &#123; var that = this; var canvasData = []; data.forEach(function(item,i)&#123; var cx = item.x + that.x0; var cy = that.y0 - item.y; canvasData.push(&#123;x:cx,y:cy&#125;); &#125;); return canvasData; &#125; /*绘制多个点*/ LineChart.prototype.drawDotted = function (data) &#123; var that = this; /*转换*/ var canvasData = this.formatDot(data); console.log(canvasData); canvasData.forEach(function (item, i) &#123; that.ctx.beginPath(); that.ctx.moveTo(item.x - that.edge /2 , item.y - that.edge/2); that.ctx.lineTo(item.x + that.edge /2 , item.y - that.edge/2); that.ctx.lineTo(item.x + that.edge /2 , item.y + that.edge/2); that.ctx.lineTo(item.x - that.edge /2 , item.y + that.edge/2); that.ctx.closePath(); that.ctx.fill(); that.ctx.beginPath(); if(i == 0)&#123; that.ctx.moveTo(that.x0,that.y0); &#125;else&#123; that.ctx.moveTo(canvasData[i-1].x,canvasData[i-1].y) &#125; that.ctx.lineTo(item.x,item.y); that.ctx.stroke(); &#125;); &#125; new LineChart().init(data); ​ 参考文档 w3school Canvas_API Canvas图形绘制矩形绘制 rect(x,y,w,h) 没有独立路径 strokeRect(x,y,w,h) 有独立路径，不影响别的绘制 fillRect(x,y,w,h) 有独立路径，不影响别的绘制 clearRect(x,y,w,h) 擦除矩形区域 圆弧绘制 弧度概念 arc() x 圆心横坐标 y 圆心纵坐标 r 半径 startAngle 开始角度 endAngle 结束角度 anticlockwise 是否逆时针方向绘制（默认false表示顺时针；true表示逆时针） 绘制文本 ctx.font = ‘微软雅黑’ 设置字体 strokeText() fillText(text,x,y,maxWidth) text 要绘制的文本 x,y 文本绘制的坐标（文本左下角） maxWidth 设置文本最大宽度，可选参数 ctx.textAlign文本水平对齐方式，相对绘制坐标来说的 left center right start 默认 end direction属性css(rtl ltr) start和end于此相关 如果是ltr,start和left表现一致 如果是rtl,start和right表现一致 ctx.textBaseline 设置基线（垂直对齐方式 ） top 文本的基线处于文本的正上方，并且有一段距离 middle 文本的基线处于文本的正中间 bottom 文本的基线处于文本的证下方，并且有一段距离 hanging 文本的基线处于文本的正上方，并且和文本粘合 alphabetic 默认值，基线处于文本的下方，并且穿过文字 ideographic 和bottom相似，但是不一样 measureText() 获取文本宽度obj.width 实例练习 绘制扇形 绘制圆角矩形 绘制圆 绘制饼图 做动画绘制图片 drawImage() 三个参数drawImage(img,x,y) img 图片对象、canvas对象、video对象 x,y 图片绘制的左上角 五个参数drawImage(img,x,y,w,h) img 图片对象、canvas对象、video对象 x,y 图片绘制的左上角 w,h 图片绘制尺寸设置(图片缩放，不是截取) 九个参数drawImage(img,x,y,w,h,x1,y1,w1,h1) img 图片对象、canvas对象、video对象 x,y,w,h 图片中的一个矩形区域 x1,y1,w1,h1 画布中的一个矩形区域 序列帧动画 绘制精灵图 动起来 控制边界 键盘控制 坐标变换 平移 移动画布的原点 translate(x,y) 参数表示移动目标点的坐标 缩放 scale(x,y) 参数表示宽高的缩放比例 旋转 rotate(angle) 参数表示旋转角度]]></content>
      <categories>
        <category>canvas</category>
      </categories>
      <tags>
        <tag>canvas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript Standard Style(JavaScript 标准编码风格)]]></title>
    <url>%2F2017%2F01%2F20%2FJavaScript%2BStandard%2BStyle(JavaScript%2B%E6%A0%87%E5%87%86%E7%BC%96%E7%A0%81%E9%A3%8E%E6%A0%BC)%2F</url>
    <content type="text"><![CDATA[让我们看一看 @feross 的 JavaScript 标准风格 ，这是一个流行的 JavaScript 风格指南。它可以帮助你减少团队之间的摩擦，增加程序员的幸福感。 这是 一组规则 ，可以使 JavaScript 代码更加一致 ，并且可以防止类似于 tabs缩进 和 空格缩进优缺点这一类无聊的话题讨论。你可以采用多种风格之一，并且与其他 （如 JSLint ， JSHint 和 ESLint ）是同一种类型的 JavaScript 检测器。 如果你还不知道什么是linter (检查工具)，或者为什么需要，请查看我们对 JavaScript 检查(Linting)工具的比较。 风格的重要性如果你已经从事编码工作有一段时间了的话，那你肯定会有一种自己喜欢的风格。当你成百上千次以特定的模式编写代码时，你会发现你的编码方式是令人愉悦的。突然间来了个人，开始把挂在行尾的大括号单起一行。你可能会发牢骚。深呼吸冷静思考一下，你放置括号的位置 或 关键字后加空格 不会让你的程序更加正确，这只是个人喜好。 每种编程语言都有一种主流编码风格，比如像 Python，官方提供的 风格指南 被认为是编写程序的正确方式。那么你是否还会继续讨厌缩进用4个空格的人呢？（注：Python 官方提供的风格指南，建议使用4个空格缩进）。 用主流风格进行编码将有助于你的程序更能适应语言的生态环境。您还会发现，如果您熟悉该语言的主流编码风格，并且一开始就同意这种编码风格，那么您可以更容易地为开源项目贡献代码，同样也更容易让其他人来为你的开源项目贡献代码。 JavaScript 没有官方的编码风格指南，或许 Douglas Crockford 的 The Good Parts 是一个实际上的标准。他的书（注：《JavaScript 语言精粹》）提供了一种编写可靠的方法来 JavaScript 程序，他强调了我们应该积极避免的某些特性。他发布了 JSLint 来支持这些观点，而其他的检查工具也紧随其后。大多数的检查工具是高度可配置的，让你选择最适合你自己的风格，并将其强加于别人或团队！JavaScript Standard Style(注：这个项目名，所以没翻译，意思为 JavaScript 标准编码风格) 则不同。你最喜欢的编码风格无关紧要，重要的是，任何选择都可以让每个人理解和合作。 采用 standard 编码风格意味着 代码清晰性和社区约定的重要性要高于个人的编码风格。这不一定适用于所有项目和开发文化，但是开放项目源码对于新手来说可能非常不适应。建立清晰的、自动的编码风格，满足贡献者期望可以使项目发展更健康。 如果你正在为自己编写一个程序，没有其他人需要为你做贡献，那就使用那些让你最快乐的工具和编码风格。当你在一个团队中工作时，你应该尽量减少摩擦，保持专业，不要因为小事而浪费太多的时间。 在介绍自己的风格之前，花点时间学习现有代码库的风格。 JavaScript Standard Style （JavaScript 标准编码风格） 使用两个空格 – 进行缩进 字符串使用单引号 – 需要转义的地方除外 不再有冗余的变量 – 这是导致 大量 bug 的源头! 无分号 – 这里有3篇文章说明不用分号的好处：文章1文章2文章3 行首不要以 (, [, or ` 开头 这是省略分号时唯一会造成问题的地方 – 工具里已加了自动检测！ [详情][4] 关键字后加空格if (condition) { ... } 函数名后加空格function name (arg) { ... } 坚持使用全等 === 摒弃 == 一但在需要检查 null || undefined 时可以使用 obj == null。 一定要处理 Node.js 中错误回调传递进来的 err 参数。 使用浏览器全局变量时加上 window 前缀 – document 和 navigator 除外 避免无意中使用到了这些命名看上去很普通的全局变量， open, length,event 还有 name。 请参阅 完整的规则列表 最有争议的规则无疑是不用分号。多年来人们一直认为，始终使用分号是避免错误的最佳实践，Crockford 做了很多工作来促进这一点，使用封号有很深的根源，在 C 语言里，分号是严格要求的，否则程序不会运行。 JavaScript Standard Style(JavaScript 标准编码风格) 改变了我的想法，不用分号的 JavaScript 非常好。 分号自动插入是 JavaScript 的一个特性，它可以减少噪点、简化程序，我从来没有遇到过由于缺少分号而导致的bug，我也不相信你会遇到。查看 JavaScript 中有必需使用分号的吗? 以了解更多。 并不是所有人都同意，forks semistandard 和 happiness 有点唱反调，强调使用分号。我发现这些 forks 有点伤感，因为它们错过忽略了整个标准的要点。 如果我不同意某条规则，可以改吗？ 不行。制定这套 standard 规范的目的就是让大家都不必再花时间浪费在无谓的代码风格之争上面了。关于缩进该用制表符还是空格这个问题已经争论了很久了，永远也没有答案。争论这个都可以把需求提前写完了。遵循 standard 规范，你就不用再犹豫了，毕竟不管怎样争论总归会选择一种风格的。希望大家也能在个人语义和普适价值上做一个权衡。 就我个人而言，我已经开始喜欢不使用分号的编码风格了，也许是因为需要编写 Ruby、Python 和 CoffeeScript 的缘故，这些都不使用分号的语法。无论什么原因，当看不到分号的时候，我发现程序更清晰了。 良好的程序层次结构程序员应该重视： 正确性 可读性 幸福感 高效率 事实证明，采用 JavaScript Standard Style(JavaScript 标准编码风格)，对以上每一条都有好处。 正确性在所有程序中使用的任何东西，都必须做你想要的，并且没有错误。 编码风格并不会使程序更正确，但是在发布之前，检查工具可以帮你捕获一些错误。 可读性作为一个专业的开发人员，除了提供一份能正常运行的程序代码之外，代码的可读性是最重要的。阅读和尝试理解程序比编写代码要花费更多的精力和时间，因此请为未来的自己和维护代码的其他人进行可读性优化。 清晰可预测的风格使代码更容易阅读和理解。 程序员的幸福感我喜欢 JavaScript Standard Style(JavaScript 标准编码风格) 的原因之一是，它把重点放在人而不是机器上。程序员的幸福感在这个列表中排名第三的唯一原因是团队合作中更需要可读性，功能代码的正确性应该放在我们自己的幸福感之前，这是毋庸置疑的。 你想享受生活，不是吗？如果你很快就能完成工作，而且你的工作又有趣，那不就是我们想要的享受生活吗？这在一定程度上就是我们生活的目的。你的生活会更加美好。 – Yukihiro Matsumoto （注：松本行弘是一位日本计算机科学家和程序员。他是Ruby程序设计语言的主要设计者和实现者。） 人生苦短，不能因个人偏好的不同而引起意见分歧，设定一个标准并后续推进不是更好吗？如果一个标准的编码风格能够避免团队之间的分歧和摩擦，那么你就会更快乐。 高效率列在最后，但并非最不重要。 如果你必须在这些要点上进行权衡，那么你应该更加重视代码正确性、可读性，并且使程序员对快速编写代码感到愉悦。 计算机处理速度很快。如果程序高效，那就没事了。如果您发现性能不佳，请花时间寻找性能瓶颈并使代码更高效。 人类处理问题的速度相对来说很慢。让事情变得更有效率对我们来说更有价值。采用一种标准编码风格的清晰性使您的代码能够更快地理解并贡献代码。花在分歧上的时间也少了很多，这是最受欢迎的。 实施 JavaScript Standard Style(JavaScript 标准编码风格)你可以不用任何工具就可以采用这个标准，只要通读一下 规则 就可以，特别注意哪些和你以前习惯不同的规则。尝试一个星期，看看你是否喜欢。如果你不是特别反感，那就用它吧！ 还有一个 npm 包，用于检查你的JavaScript代码。 1npm install standard --global 通过这个检测器，运行 standard 将执行目录中的所有 JavaScript 文件。 此外，还有所有常见的 文本编辑器插件 ，这里是如何在 Atom 中安装检测器。 12apm install linterapm install linter-js-standard 就我个人而言，当你正在输入代码的时候，自动打印风格警告提示会让你分心。如果你有同样的感觉，在你完成工作后，再来检查会更好。JavaScript 标准编码风格 命令也有一个自动修复某些风格错误的 flag，这可能会节省一些时间。 1standard --fix 采用 JavaScript Standard Style(JavaScript 标准编码风格)你应该采用 JavaScript Standard Style(JavaScript 标准编码风格) 吗？那么这完全取决于你。 如果你没有合适的风格指南，那就准备好面对分歧和冲突吧。 如果你已经完善了一套理想的规则，并希望在整个代码库中执行它，那么 ESLint 可能就是你最好的选择。 如果你不想浪费时间在无聊的语法细节上，那就请用JavaScript Standard Style(JavaScript 标准编码风格) 吧，欢迎评论说出你的想法。 原文链接：https://www.sitepoint.com/why-use-javascript-style-guide/]]></content>
      <categories>
        <category>标准编码风格</category>
      </categories>
      <tags>
        <tag>标准编码风格</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串编码]]></title>
    <url>%2F2017%2F01%2F10%2F%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%BC%96%E7%A0%81%2F</url>
    <content type="text"><![CDATA[ASCII码在计算机内部，所有的信息最终都表示为一个二进制的字符串。每一个二进制位（bit）有0和1两种状态，因此八个二进制位就可以组合出256种状态，这被称为一个字节（byte）。也就是说，一个字节一共可以用来表示256种不同的状态，每一个状态对应一个符号，就是256个符号，从0000000到11111111。上个世纪60年代，美国制定了一套字符编码，对英语字符与二进制位之间的关系，做了统一规定。这被称为ASCII码，一直沿用至今。ASCII码一共规定了128个字符的编码（0 000 0000–0 111 1111），比如空格”SPACE”是32（二进制00100000），大写的字母A是65（二进制01000001）。这128个符号（包括32个不能打印出来的控制符号），只占用了一个字节的后面7位，最前面的1位统一规定为0。 非ASCII编码英语用128个符号编码就够了，但是用来表示其他语言，128个符号是不够的。比如，在法语中，字母上方有注音符号，它就无法用ASCII码表示。于是，一些欧洲国家就决定，利用字节中闲置的最高位编入新的符号。比如，法语中的é的编码为130（二进制10000010）。这样一来，这些欧洲国家使用的编码体系，可以表示最多256个符号。但是，这里又出现了新的问题。不同的国家有不同的字母，因此，哪怕它们都使用256个符号的编码方式，代表的字母却不一样。比如，130在法语编码中代表了é，在希伯来语编码中却代表了字母Gimel (ג)，在俄语编码中又会代表另一个符号。但是不管怎样，所有这些编码方式中，0–127表示的符号是一样的，不一样的只是128–255的这一段。至于亚洲国家的文字，使用的符号就更多了，汉字就多达10万左右。一个字节只能表示256种符号，肯定是不够的，就必须使用多个字节表达一个符号。比如，简体中文常见的编码方式是GB2312，使用两个字节表示一个汉字，所以理论上最多可以表示256x256=65536个符号。中文编码的问题需要专文讨论，这篇笔记不涉及。这里只指出，虽然都是用多个字节表示一个符号，但是GB类的汉字编码与后文的Unicode和UTF-8是毫无关系的。 3.Unicode（统一码、万国码、单一码）最初的unicode编码是固定长度的，16位，也就是2两个字节代表一个字符，这样一共可以表示65536个字符。显然，这样要表示各种语言中所有的字符是远远不够的。Unicode4.0规范考虑到了这种情况，定义了一组附加字符编码，附加字符编码采用2个16位来表示，这样最多可以定义1048576个附加字符，目前unicode4.0只定义了45960个附加字符。Unicode只是一个编码规范，目前实际实现的unicode编码只要有三种：UTF-8,UCS-2和UTF-16，三种unicode字符集之间可以按照规范进行转换。 正如上面所说，世界上存在着多种编码方式，同一个二进制数字可以被解释成不同的符号。因此，要想打开一个文本文件，就必须知道它的编码方式，否则用错误的编码方式解读，就会出现乱码。为什么电子邮件常常出现乱码？就是因为发信人和收信人使用的编码方式不一样。可以想象，如果有一种编码，将世界上所有的符号都纳入其中。每一个符号都给予一个独一无二的编码，那么乱码问题就会消失。这就是Unicode，就像它的名字都表示的，这是一种所有符号的编码。Unicode当然是一个很大的集合，现在的规模可以容纳100多万个符号。每个符号的编码都不一样，比如，U+0639表示阿拉伯字母Ain，U+0041表示英语的大写字母A，U+4E25表示汉字”严”。具体的符号对应表，可以查询unicode.org，或者专门的汉字对应表。 4. Unicode的问题需要注意的是，Unicode只是一个符号集，它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储。比如，汉字”严”的unicode是十六进制数4E25，转换成二进制数足足有15位（100111000100101），也就是说这个符号的表示至少需要2个字节。表示其他更大的符号，可能需要3个字节或者4个字节，甚至更多。这里就有两个严重的问题，第一个问题是如何才能区别Unicode和ASCII？计算机怎么知道三个字节表示一个符号，而不是分别表示三个符号呢？第二个问题是我们已经知道，英文字母只用一个字节表示就够了，如果Unicode统一规定，每个符号用三个或四个字节表示，那么每个英文字母前都必然有二到三个字节是0，这对于存储来说是极大的浪费，文本文件的大小会因此大出二三倍，这是无法接受的。它们造成的结果是：1）出现了Unicode的多种存储方式，也就是说有许多种不同的二进制格式，可以用来表示Unicode。2）Unicode在很长一段时间内无法推广，直到互联网的出现。 5.UTF-8互联网的普及，强烈要求出现一种统一的编码方式。UTF-8就是在互联网上使用最广的一种Unicode的实现方式。其他实现方式还包括UTF-16（字符用两个字节或四个字节表示）和UTF-32（字符用四个字节表示），不过在互联网上基本不用。重复一遍，这里的关系是，UTF-8是Unicode的实现方式之一。 UTF-8最大的一个特点，就是它是一种变长的编码方式。它可以使用1~6个字节表示一个符号，根据不同的符号而变化字节长度。Unicode编码长度是固定的，无论是数字、英文还是火星文。所以Unicode编码有点浪费空间。UTF8是针对unicode的空间浪费现象，它对字符的长度是动态的。UTF-8的编码规则很简单，只有二条：1）对于单字节的符号，字节的第一位设为0，后面7位为这个符号的unicode码。因此对于英语字母，UTF-8编码和ASCII码是相同的。2）对于n字节的符号（n&gt;1），第一个字节的前n位都设为1，第n+1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的unicode码。 1234567Unicode符号范围 | UTF-8编码方式(十六进制) | （二进制）--------------------+--------------------------------------0000 0000-0000 007F | 0xxxxxxx0000 0080-0000 07FF | 110xxxxx 10xxxxxx0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx1234567 跟据上表，解读UTF-8编码非常简单。如果一个字节的第一位是0，则这个字节单独就是一个字符；如果第一位是1，则连续有多少个1，就表示当前字符占用多少个字节。下面，还是以汉字”严”为例，演示如何实现UTF-8编码。已知”严”的unicode是4E25（100111000100101），根据上表，可以发现4E25处在第三行的范围内（0000 0800-0000 FFFF），因此”严”的UTF-8编码需要三个字节，即格式是”1110xxxx 10xxxxxx 10xxxxxx”。然后，从”严”的最后一个二进制位开始，依次从后向前填入格式中的x，多出的位补0。这样就得到了，”严”的UTF-8编码是”11100100 10111000 10100101”，转换成十六进制就是E4B8A5。 关于UTF-8，汉字占几个字节的问题占2个字节的：〇（〇有两个读音 xīng líng（一） xīng 同“星”。唐武则天所造字，（二） líng 同“零”。） 占3个字节的：基本等同于GBK，含21000多个汉字 占4个字节的：中日韩超大字符集里面的汉字，有5万多个 一个utf8数字占1个字节 一个utf8英文字母占1个字节 在查找 UTF-8 编码资料时发现，很多的帖子说的 UTF-8 编码里，一个汉字占用3个字节，有的还做了个证明，大概是这样的，创建一个没有BOM的UTF-8编码的文本文件，里面保存了几个汉字，然后查看文件的大小。我觉得这样的证明没有一点说服力，因为 UTF-8 是变长的，1-6个字节，少量的汉字检测是不能说明所有的汉字都是的。 后来我又查看了字符映射表－汉语，找到了正确的答案，少数是汉字每个占用3个字节，多数占用4个字节。 占用3个字节的范围 合计： 52156 个 123456U+2E80 - U+2EF3 : 0xE2 0xBA 0x80 - 0xE2 0xBB 0xB3 共 115 个U+2F00 - U+2FD5 : 0xE2 0xBC 0x80 - 0xE2 0xBF 0x95 共 213 个U+3005 - U+3029 : 0xE3 0x80 0x85 - 0xE3 0x80 0xA9 共 36 个U+3038 - U+4DB5 : 0xE3 0x80 0xB8 - 0xE4 0xB6 0xB5 共 7549 个U+4E00 - U+FA6A : 0xE4 0xB8 0x80 - 0xEF 0xA9 0xAA 共 44138 个U+FA70 - U+FAD9 : 0xEF 0xA9 0xB0 - 0xEF 0xAB 0x99 共 105 个123456 占用4个字节的范围 合计： 64029 个 1U+20000 - U+2FA1D : 0xF0 0xA0 0x80 0x80 - 0xF0 0xAF 0xA8 0x9D 共 64029 个1 中日韩超大字符集里面的汉字占用4个字节,但是这些文字很少使用,虽然3个字节的5w多个,4个字节的6w多个,但我估计平常应用中,恐怕,99.9%占用三个字节,后面四个字节的中日韩超大字符集几乎没人用 6. Unicode与UTF-8之间的转换通过上一节的例子，可以看到”严”的Unicode码是4E25，UTF-8编码是E4B8A5，两者是不一样的。它们之间的转换可以通过程序实现。在Windows平台下，有一个最简单的转化方法，就是使用内置的记事本小程序Notepad.exe。打开文件后，点击”文件”菜单中的”另存为”命令，会跳出一个对话框，在最底部有一个”编码”的下拉条。里面有四个选项：ANSI，Unicode，Unicode big endian 和 UTF-8。1）ANSI是默认的编码方式。对于英文文件是ASCII编码，对于简体中文文件是GB2312编码（只针对Windows简体中文版，如果是繁体中文版会采用Big5码）。2）Unicode编码指的是UCS-2编码方式，即直接用两个字节存入字符的Unicode码。这个选项用的little endian格式。3）Unicode big endian编码与上一个选项相对应。我在下一节会解释little endian和big endian的涵义。4）UTF-8编码，也就是上一节谈到的编码方法。选择完”编码方式”后，点击”保存”按钮，文件的编码方式就立刻转换好了。 7. Little endian和Big endian上一节已经提到，Unicode码可以采用UCS-2格式直接存储。以汉字”严”为例，Unicode码是4E25，需要用两个字节存储，一个字节是4E，另一个字节是25。存储的时候，4E在前，25在后，就是Big endian方式；25在前，4E在后，就是Little endian方式。这两个古怪的名称来自英国作家斯威夫特的《格列佛游记》。在该书中，小人国里爆发了内战，战争起因是人们争论，吃鸡蛋时究竟是从大头(Big-Endian)敲开还是从小头(Little-Endian)敲开。为了这件事情，前后爆发了六次战争，一个皇帝送了命，另一个皇帝丢了王位。因此，第一个字节在前，就是”大头方式”（Big endian），第二个字节在前就是”小头方式”（Little endian）。那么很自然的，就会出现一个问题：计算机怎么知道某一个文件到底采用哪一种方式编码？Unicode规范中定义，每一个文件的最前面分别加入一个表示编码顺序的字符，这个字符的名字叫做”零宽度非换行空格”（ZERO WIDTH NO-BREAK SPACE），用FEFF表示。这正好是两个字节，而且FF比FE大1。如果一个文本文件的头两个字节是FE FF，就表示该文件采用大头方式；如果头两个字节是FF FE，就表示该文件采用小头方式。 汉字编码中现在主要用到的有三类，包括GBK，GB2312和Big5。1、GB2312又称国标码，由国家标准总局发布，1981年5月1日实施，通行于大陆。新加坡等地也使用此编码。它是一个简化字的编码规范，当然也包括其他的符号、字母、日文假名等，共7445个图形字符，其中汉字占6763个。我们平时说6768个汉字，实际上里边有5个编码为空白，所以总共有6763个汉字。GB2312规定“对任意一个图形字符都采用两个字节表示，每个字节均采用七位编码表示”，习惯上称第一个字节为“高字节”，第二个字节为“低字节”。GB2312中汉字的编码范围为，第一字节0xB0-0xF7(对应十进 制为176-247)，第二个字节0xA0-0xFE（对应十进制为160-254）。GB2312将代码表分为94个区，对应第一字节（0xa1-0xfe）；每个区94个位（0xa1-0xfe），对应第二字节，两个字节的值分别为区号值和位号值加32（2OH），因此也称为区位码。01-09区为符号、数字区，16-87区为汉字区（0xb0-0xf7），10-15区、88-94区是有待进一步标准化的空白区。 2、Big5又称大五码，主要为香港与台湾使用，即是一个繁体字编码。每个汉字由两个字节构成，第一个字节的范围从0X81－0XFE（即129-255），共126种。第二个字节的范围不连续，分别为0X40－0X7E（即64-126），0XA1－0XFE（即161-254），共157种。 3、GBK是GB2312的扩展，是向上兼容的，因此GB2312中的汉字的编码与GBK中汉字的相同。另外，GBK中还包含繁体字的编码，它与Big5编码之间的关系我还没有弄明白，好像是不一致的。GBK中每个汉字仍然包含两个字节，第一个字节的范围是0x81-0xFE（即129-254），第二个字节的范围是0x40-0xFE（即64-254）。GBK中有码位23940个，包含汉字21003个。 12345678910111213141516171819英文字母和中文汉字在不同字符集编码下的字节数英文字母：字节数 : 1;编码：GB2312字节数 : 1;编码：GBK字节数 : 1;编码：GB18030字节数 : 1;编码：ISO-8859-1 字节数 : 1;编码：UTF-8字节数 : 4;编码：UTF-16字节数 : 2;编码：UTF-16BE字节数 : 2;编码：UTF-16LE 中文汉字：字节数 : 2;编码：GB2312字节数 : 2;编码：GBK字节数 : 2;编码：GB18030字节数 : 1;编码：ISO-8859-1字节数 : 3;编码：UTF-8字节数 : 4;编码：UTF-16字节数 : 2;编码：UTF-16BE字节数 : 2;编码：UTF-16LE 参考1 参考2]]></content>
      <categories>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>字符串</tag>
        <tag>编码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组的常用方法]]></title>
    <url>%2F2017%2F01%2F10%2F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[数组的length属性不同于字符串的length属性可进行读写操作，字符串的length属性可读不可写 push()作用：将一个或者多个元素 往数组的末尾添加进去参数：一个或者多个元素返回值：改变后的数组的长度注意事项： 原数组会发生改变 1234var arr = [1,2,3,4,5]var result = arr.push(6,7)console.log(arr) //[1, 2, 3, 4, 5, 6, 7]console.log(result) //7 unshift()作用：将一个或者多个元素 往数组的最前面添加进去参数：一个或者多个元素返回值: 改变后的数组的长度注意事项：原数组会发生改变 1234var arr = [1,2,3,4,5]var result = arr.unshift(6,7)console.log(arr) //[6, 7, 1, 2, 3, 4, 5]console.log(result) //7 pop()作用：从数组最后面删除一项参数：无返回值：删除的那一项注意事项：原数组会发生改变 1234var arr = [1,2,3,4,5]var result = arr.pop()console.log(arr) //[1, 2, 3, 4]console.log(result) //5 shift()作用：从数组最前面删除一项参数：无返回值：删的那一项注意事项 原数组会发生改变 1234var arr = [1,2,3,4,5]var result = arr.shift()console.log(arr) //[2, 3, 4, 5]console.log(result) //1 reverse()作用：翻转数组参数： 无返回值： 翻转后的数组注意事项： 原数组会发生改变 1234var arr = [1,2,3,4,5]var result = arr.reverse()console.log(arr) //[5, 4, 3, 2, 1]console.log(result) //[5, 4, 3, 2, 1] sort()作用：数组排序原理： 按照字符串的字符编码进行逐位比较 然后排序参数：无 / 函数来实现数字排序（该函数需要两个形参，并返回负值 0 正值）返回值：排序改变后的数组注意事项 原数组会发生改变 1234var arr = [2,8,75,6]var result = arr.sort()console.log(arr); //[2, 6, 75, 8]console.log(result); //[2, 6, 75, 8] 12345678console.log("5"&gt;"21") //truevar arr = [2,8,75,6,46] function fun(a,b)&#123; return b-a&#125;var result = arr.sort(fun)console.log(arr) //[75, 46, 8, 6, 2]console.log(result) //[75, 46, 8, 6, 2] 123456//扩展一下var arr = [1,2,3,4,5] //随机打乱数组arr.sort(function () &#123; return Math.random()-0.5&#125;)console.log(arr) concat()作用： 用来连接数组或者元素参数： 一个或者多个数组或者元素返回值： 连接后的新数组注意事项：原数组不会发生改变 123456var arr = [1, 2, 3, 4, 5]var arr2 = ['a', 'b', 'c', 'd', 'e']var arr3 = ['A', 'B', 'C', 'D', 'E']var newArr = arr.concat('red', arr2, arr3)console.log(newArr) //[1, 2, 3, 4, 5, "red", "a", "b", "c", "d", "e", "A", "B", "C", "D", "E"]console.log(arr) //[1, 2, 3, 4, 5] 1234var arr = [1,2,3];var arr2 = [[[5,6]]];var newArr = arr.concat(4,arr2);console.log(newArr); //[1,2,3,4,[[5,6]]] slice()作用： 用来截取数组的参数：​ 第一个参数：开始截取的位置 如果不写第一个参数 默认从0开始截取​ 第二个参数: 结束截取的位置(不包含结束位置) 如果不写第二个参数 默认截取到最后返回值：截取后的新的数组注意事项：原数组不会发生改变 1234var arr2 = [1, 2, 3, 4, 5]var r = arr2.slice(1)console.log(arr2) //[1, 2, 3, 4, 5]console.log(r) //[2, 3, 4, 5] splice()作用： 删除数组的方法 （可以实现添加 删除 修改）参数：第一个参数：开始删除的位置第二个参数：删除的个数第三个参数： 需要添加的元素返回值： 将删除后的元素组成一个新的数组注意事项： 原数组会发生改变 12345//截取var arr = [1, 2, 3, 4, 5]var r = arr.splice(1,3);console.log(arr); //[1, 5]console.log(r); //[2, 3, 4] 12345//添加var arr = [1, 2, 3, 4, 5]var r = arr.splice(3, 0, "red")console.log(arr) //[1, 2, 3, "red", 4, 5]console.log(r) //[] 12345//删除var arr = [1, 2, 3, 4, 5]var r = arr.splice(1,1);console.log(arr); //[1, 3, 4, 5]console.log(r); //[2] 12345//替换var arr = [1, 2, 3, 4, 5]var r = arr.splice(3,1,"sun");console.log(arr); //[1, 2, 3, "sun", 5]console.log(r); //[4] join()作用：将数组转换成字符串参数：连接符（字符串形式）返回值：连接后的新的字符串注意事项：原数组不会发生改变 1234var arr = [1, 2, 3, 4, 5]var str = arr.join("-")console.log(typeof str,str) //string 1-2-3-4-5console.log(arr) //[1, 2, 3, 4, 5] 123var arr = ["2013","57","01"]var str = arr.join("")console.log(str) //20135701]]></content>
      <categories>
        <category>数组方法</category>
      </categories>
      <tags>
        <tag>数组方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串的常用方法]]></title>
    <url>%2F2017%2F01%2F10%2F%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[字符串slice()截取方法(不会改变原字符串，返回新字符串) 字符串slice截取方法 MDN这样说 slice() 方法提取字符串中的一部分，并返回这个新的字符串。 第一个参数： 开始截取的位置第二个参数： 结束截取的位置（不包含结束位置）支持参数颠倒顺序支持负数 写法112var str = 'The morning is upon us.';console.log(str.slice(2,5)); //returns 'e m' 表示从索引第2个字符开始，截取到索引为5的字符包含2，不包含5;[2，5); 写法2123var str1 = 'The morning is upon us.';var str2 = str1.slice(4,-1); //[4,-1) 表示从索引第4个字符开始，截取到最后一个字符 包含4，不包含-1;console.log(str2); //morning is upon us; 写法31234var str3 = 'The morning is upon us.';str3.slice(-3); // returns 'us.' 表示字符串从右往左数第三个字符截取到最后str3.slice(-3, -1); // returns 'us' 表示字符串从右往左数第三个字符截取到最后一个字符 [3,-1);str3.slice(0, -1); // returns 'The morning is upon us' [0，-1) 写法4123var str4 = 'The morning is upon us.';str4.slice(5, 6); //returns 'o'console.log(str4.slice(5, 2) === '');// true 返回空字符串 字符串substr()方法(不会改变原字符串，返回新字符串) 字符串substr方法 MDN这样说 substr() 方法返回字符串中从指定位置开始到指定长度的子字符串 第一个参数： 开始截取的位置第二个参数： 结束截取的位置（不包含结束位置）支持参数颠倒顺序 自动调整顺序不支持负数 如果碰到负数 当0来处理 12345语法str.substr(start[, length])参数start开始提取字符的位置。如果为负值，则被看作 strLength + start，其中 strLength 为字符串的长度（例如，如果 start 为 -3，则被看作 strLength-3）。参数length可选。提取的字符数。不填则默认截取到最后一个字符。 123456789var sstr1 = "abcdefghij";console.log("(1,2): " + sstr1.substr(1,2)); // (1,2): "bc" 表示从索引为1开始 截取2个字符console.log("(-3,2): " + sstr1.substr(-3,2)); // (-3,2): hi 表示从右往左数第三个开始截取 截取2个字符 （MDN说 如果 start 为 -3，则被看作 strLength-3）10-3=7 从索引为7的字符截取2个console.log("(-3): " + sstr1.substr(-3)); // (-3): hij 表示从右往左数第三个开始截取 截取到最后console.log("(1): " + sstr1.substr(1)); // (1): bcdefghij 表示从索引为1的数字开始 截取到最后console.log("(-10,2): " + sstr1.substr(-10,2)); // (1): ab 表示从索引为0的数字开始 截取到2个console.log("(-21, 2): " + sstr1.substr(-21,2)); // (-21, 2): ab 如果 start 为负值且 abs(start) 大于字符串的长度，则 substr 使用 0 作为开始提取的索引。表示从索引为0的位置截取2个字符//注 字符串substr方法 str.substr(start[, length]) 不支持负的 start 索引 有兼容问题 解决兼容问题见MDN 字符串substring()方法(不改变原字符串，返回新字符串) 字符串substring()方法 返回字符串两个索引之间（或到字符串末尾）的子串。 12345语法 str.substring(indexStart[, indexEnd])参数indexStart 一个 0 到字符串长度之间的整数。indexEnd可选。一个 0 到字符串长度之间的整数。 1234567891011121314151617181920var anyString = "Mozilla";// 输出 "Moz"console.log(anyString.substring(0,3)); //表示从索引为0截取到索引到3的字符串 [0，3）包含索引0 不包含索引3；console.log(anyString.substring(3,0)); // 如果 indexStart 大于 indexEnd，则 substring 的执行效果就像两个参数调换了一样。 所以输出结果同上；// 输出 "lla"console.log(anyString.substring(4,7)); //如果任一参数大于 stringName.length，则被当作 stringName.length。表示从索引为4截取到最后啦。console.log(anyString.substring(7,4)); // 如果 indexStart 大于 indexEnd，则 substring 的执行效果就像两个参数调换了一样。 所以输出结果同上；// 输出 "Mozill"console.log(anyString.substring(0,6)); //[0，6）；// 输出 "Mozilla"console.log(anyString.substring(0,7));//[0，7）console.log(anyString.substring(0,10));//如果任一参数大于 stringName.length，则被当作 stringName.length。//注 如果 indexStart 等于 indexEnd，substring 返回一个空字符串。// 如果省略 indexEnd，substring 提取字符一直到字符串末尾。// 如果任一参数小于 0 或为 NaN，则被当作 0。// 如果任一参数大于 stringName.length，则被当作 stringName.length。 字符串toUpperCase()方法(不改变原字符串，返回新字符串) toUpperCase 将调用该方法的字符串值转换为大写形式，并返回。toUpperCase 方法不影响字符串本身的值。 1console.log( "alphabet".toUpperCase()); // "ALPHABET" 字符串toLowerCase()方法(不改变原字符串，返回新字符串) 字符串toLowerCase() 将调用该方法的字符串值转为小写形式，并返回。 1console.log( "ALPHABET".toLowerCase() ); // "alphabet" 字符串split()方法(不改变原字符串，返回一个新字符串数组) split() 方法通过把字符串分割成子字符串来把一个 String 对象分割成一个字符串数组。 1234语法str.split([separator][, limit])separator 指定用来分割字符串的字符（串）。limit一个整数，限定返回的分割片段数量。split 方法仍然分割每一个匹配的 separator，但是返回的数组只会截取最多 limit 个元素。 12345var myString = "Hello World. How are you doing?";var splits = myString.split(""); //如果 separator 是一个空字符串，则 str 将被转换为由字符串中字符组成的一个数组。console.log(splits); //返回结果["H", "e", "l", "l", "o", " ", "W", "o", "r", "l", "d", ".", " ", "H", "o", "w", " ", "a", "r", "e", " ", "y", "o", "u", " ", "d", "o", "i", "n", "g", "?"] 用心去体会console.log(myString.split()) // 如果忽略 separator，则返回整个字符串的数组形式。 ["Hello World. How are you doing?"]console.log(myString.split(" ")); // 当找到一个 seperator 时，separator 会从字符串中被移除，返回存进一个数组当中的子字符串。["Hello", "World.", "How", "are", "you", "doing?"] 说白了separator就是分割元素； 字符串indexOf() 方法(不改变原字符串，返回一个number类型的值) indexOf() 方法返回指定值在字符串对象中首次出现的位置。从 fromIndex 位置开始查找，如果不存在，则返回 -1。 查找字符串第一个参数： 需要查找的字符第二个参数： 开始查找的位置 如果第二个参数不写默认从0开始返回 找的字符的对应下标如果找不到 返回-112345678语法 str.indexOf(searchValue[, fromIndex])参数searchValue一个字符串表示被查找的值。fromIndex 可选表示调用该方法的字符串中开始查找的位置。可以是任意整数。默认值为 0。如果 fromIndex &lt; 0 则查找整个字符串（如同传进了 0）。如果 fromIndex &gt;= str.length，则该方法返回 -1，除非被查找的字符串是一个空字符串，此时返回 str.length。描述字符串中的字符被从左向右索引。首字符的索引（index）为 0，字符串 stringName 的最后一个字符的索引是 stringName.length - 1。 1234567"Blue Whale".indexOf("Blue"); // returns 0"Blue Whale".indexOf("Blute"); // returns -1"Blue Whale".indexOf("Blute"); // returns -1"Blue Whale".indexOf("Whale", 5); // returns 5"Blue Whale".indexOf("", 9); // returns 9"Blue Whale".indexOf("", 10); // returns 10"Blue Whale".indexOf("", 11); // returns 10 lastIndexOf() lastIndexOf() 方法可返回一个指定的字符串值最后出现的位置，在一个字符串中的指定位置从后向前搜索。 提示和注释 注释：lastIndexOf() 方法对大小写敏感！ 注释：如果要检索的字符串值没有出现，则该方法返回 -1。 1stringObject.lastIndexOf(searchvalue,fromindex) 参数 描述 searchvalue 必需。规定需检索的字符串值。 fromindex 可选的整数参数。规定在字符串中开始检索的位置。它的合法取值是 0 到 stringObject.length - 1。如省略该参数，则将从字符串的最后一个字符处开始检索。 返回值 如果在 stringObject 中的 fromindex 位置之前存在 searchvalue，则返回的是出现的最后一个 searchvalue 的位置。 12345678var str="Hello world!"document.write(str.lastIndexOf("Hello") + "&lt;br /&gt;")document.write(str.lastIndexOf("World") + "&lt;br /&gt;")document.write(str.lastIndexOf("world"))//输出 //0//-1//6 字符串charAt()方法(不改变原字符串，返回一个字符) 语法 str.charAt(index) charAt() 方法返回字符串中指定位置的字符。字符串中的字符从左向右索引，第一个字符的索引值为 0，最后一个字符（假设该字符位于字符串 stringName 中）的索引值为 stringName.length - 1。如果指定的 index 值超出了该范围，则返回一个空字符串。 123456789101112131415var anyString = "Brave new world";console.log("The character at index 0 is '" + anyString.charAt(0) + "'");console.log("The character at index 1 is '" + anyString.charAt(1) + "'");console.log("The character at index 2 is '" + anyString.charAt(2) + "'");console.log("The character at index 3 is '" + anyString.charAt(3) + "'");console.log("The character at index 4 is '" + anyString.charAt(4) + "'");console.log("The character at index 999 is '" + anyString.charAt(999) + "'");//上面代码的输出为：// The character at index 0 is 'B'// The character at index 1 is 'r'// The character at index 2 is 'a'// The character at index 3 is 'v'// The character at index 4 is 'e'// The character at index 999 is '' charCodeAt() str.charCodeAt(index) 返回指定索引处字符的 Unicode 数值（Unicode 编码单元 &gt; 0x10000 的除外）。 Unicode 编码单元（code points）的范围从 0 到 1,114,111。开头的 128 个 Unicode 编码单元和 ASCII 字符编码一样。如果指定的 index 小于 0 或大于字符串的长度，则 charCodeAt 返回 NaN。 大于255为中文 1"ABC".charCodeAt(0) // returns 65 12345678910111213141516171819英文字母和中文汉字在不同字符集编码下的字节数英文字母：字节数 : 1;编码：GB2312字节数 : 1;编码：GBK字节数 : 1;编码：GB18030字节数 : 1;编码：ISO-8859-1 字节数 : 1;编码：UTF-8字节数 : 4;编码：UTF-16字节数 : 2;编码：UTF-16BE字节数 : 2;编码：UTF-16LE 中文汉字：字节数 : 2;编码：GB2312字节数 : 2;编码：GBK字节数 : 2;编码：GB18030字节数 : 1;编码：ISO-8859-1字节数 : 3;编码：UTF-8字节数 : 4;编码：UTF-16字节数 : 2;编码：UTF-16BE字节数 : 2;编码：UTF-16LE fromCharCode() String.fromCharCode(num1, …, numN)String.fromCharCode() 静态方法根据指定的 Unicode 编码中的序号值来返回一个字符串。 1String.fromCharCode(65,66,67) //"ABC" 一个简单应用已知有字符串foo=“get-element-by-id”,写一个function将其转化成驼峰表示法“getElementById”。 12345678910111213var foo = 'get-element-by-id'console.log(createCamel(foo))function createCamel(str) &#123; var arr = str.split('-') var str2 = '' for (var i = 0; i &lt; arr.length; i++) &#123; if (i) &#123; arr[i] = arr[i].charAt(0).toUpperCase()+arr[i].substring(1) &#125; str2 += arr[i] &#125; return str2;&#125;]]></content>
      <categories>
        <category>字符串方法</category>
      </categories>
      <tags>
        <tag>字符串方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[白话原型和原型链]]></title>
    <url>%2F2017%2F01%2F10%2F%E7%99%BD%E8%AF%9D%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE%2F</url>
    <content type="text"><![CDATA[关于原型和原型链的介绍，网上数不胜数，但能讲清楚这两个概念的很少，大多数都是介绍各种对象、属性之间如何指来指去，最后的结果就是箭头满天飞，大脑一团糟。本文将从这两个概念的命名入手，用通俗易懂的语言，帮助你理解这两个东西到底是何方神圣。 一. 背景知识JavaScript和Java、C++等传统面向对象的编程语言不同，它是没有类（class）的概念的（ES6 中的class也只不过是语法糖，并非真正意义上的类），而在JavaScript中，一切皆是对象（object）。在基于类的传统面向对象的编程语言中，对象由类实例化而来，实例化的过程中，类的属性和方法会拷贝到这个对象中；对象的继承实际上是类的继承，在定义子类继承于父类时，子类会将父类的属性和方法拷贝到自身当中。因此，这类语言中，对象创建和继承行为都是通过拷贝完成的。但在JavaScript中，对象的创建、对象的继承（更好的叫法是对象的代理，因为它并不是传统意义上的继承）是不存在拷贝行为的。现在让我们忘掉类、忘掉继承，这一切都不属于JavaScript。 二. 原型和原型链其实，原型这个名字本身就很容易产生误解，原型在百度词条中的释义是：指原来的类型或模型。按照这个定义解释的话，对象的原型是对象创建自身的模子，模子具备的特点对象都要具有，这俨然就是拷贝的概念。我们已经说过， JavaScript的对象创建不存在拷贝，对象的原型实际上也是一个对象，它和对象本身是完全独立的两个对象。既然如此，原型存在的意义又是什么呢？原型是为了共享多个对象之间的一些共有特性（属性或方法），这个功能也是任何一门面向对象的编程语言必须具备的。A、B两个对象的原型相同，那么它们必然有一些相同的特征。 JavaScript中的对象，都有一个内置属性[[Prototype]]，指向这个对象的原型对象。当查找一个属性或方法时，如果在当前对象中找不到定义，会继续在当前对象的原型对象中查找；如果原型对象中依然没有找到，会继续在原型对象的原型中查找（原型也是对象，也有它自己的原型）；如此继续，直到找到为止，或者查找到最顶层的原型对象中也没有找到，就结束查找，返回undefined。可以看出，这个查找过程是一个链式的查找，每个对象都有一个到它自身原型对象的链接，这些链接组件的整个链条就是原型链。拥有相同原型的多个对象，他们的共同特征正是通过这种查找模式体现出来的。 在上面的查找过程，我们提到了最顶层的原型对象，这个对象就是Object.prototype，这个对象中保存了最常用的方法，如toString、valueOf、hasOwnProperty等，因此我们才能在任何对象中使用这些方法。 1.字面量方式当通过字面量方式创建对象时，它的原型就是Object.prototype。虽然我们无法直接访问内置属性[[Prototype]]，但我们可以通过Object.getPrototypeOf()或对象的__proto__（不是标准属性，但几乎所有浏览器都实现了该属性）获取对象的原型。123var obj = &#123;&#125;;Object.getPrototypeOf(obj) === Object.prototype; // trueobj.__proto__ === Object.prototype; // true 2.函数的构造调用通过函数的构造调用（注意，我们不把它叫做构造函数，因为JavaScript中同样没有构造函数的概念，所有的函数都是平等的，只不过用来创建对象时，函数的调用方式不同而已）也是一种常用的创建对象的方式。基于同一个函数创建出来的对象，理应可以共享一些相同的属性或方法，但这些属性或方法如果放在Object.prototype里，那么所有的对象都可以使用它们了，作用域太大，显然不合适。于是，JavaScript在定义一个函数时，同时为这个函数定义了一个 默认的prototype属性，所有共享的属性或方法，都放到这个属性所指向的对象中。由此看出，通过一个函数的构造调用创建的对象，它的原型就是这个函数的prototype指向的对象。12345var f = function(name) &#123; this.name = name &#125;;f.prototype.getName = function() &#123; return this.name; &#125; //在prototype下存放所有对象的共享方法var obj = new f('JavaScript');obj.getName(); // JavaScriptobj.__proto__ === f.prototype; // true 3.Object.create（）第三种常用的创建对象的方式是使用Object.create()。这个方法会以你传入的对象作为创建出来的对象的原型。123var obj = &#123;&#125;;var obj2 = Object.create(obj);obj2.__proto__ === obj; // true 这种方式还可以模拟对象的“继承”行为。1234567891011121314151617181920212223242526272829function Foo(name) &#123; this.name = name;&#125;Foo.prototype.myName = function() &#123; return this.name;&#125;;function Bar(name,label) &#123; Foo.call( this, name ); // this.label = label;&#125;// temp对象的原型是Foo.prototypevar temp = Object.create( Foo.prototype ); // 通过new Bar() 创建的对象，其原型是temp, 而temp的原型是Foo.prototype，// 从而两个原型对象Bar.prototype和Foo.prototype 有了"继承"关系Bar.prototype = temp;Bar.prototype.myLabel = function() &#123; return this.label;&#125;;var a = new Bar( "a", "obj a" );a.myName(); // "a"a.myLabel(); // "obj a"a.__proto__.__proto__ === Foo.prototype; //true 三. __proto__和prototype这是容易混淆的两个属性。__proto__指向当前对象的原型，prototype是函数才具有的属性，默认情况下，new 一个函数创建出的对象，其原型都指向这个函数的prototype属性。 四. 三种特殊情况1.对于JavaScript中的内置对象，如String、Number、Array、Object、Function等，因为他们是native代码实现的，他们的原型打印出来都是ƒ () { [native code] }。 2.内置对象本质上也是函数，所以可以通过他们创建对象，创建出的对象的原型指向对应内置对象的prototype属性，最顶层的原型对象依然指向Object.prototype。1234567891011121314151617'abc'.__proto__ === String.prototype; // true new String('abc').__proto__ === String.prototype; //truenew Number(1).__proto__ ==== Number.prototype; // true[1,2,3].__proto__ === Array.prototype; // truenew Array(1,2,3).__proto__ === Array.prototype; // truevar obj = &#123;&#125;;obj.__proto__ === Object.prototype; // true (再次印证字面量创建的对象原型是Object.prototype)&#123;&#125;.__proto__ === Object.prototype; //chrome下报错，谁知道原因的告诉声new Object(&#123;&#125;).__proto__ === Object.prototype; // truevar f = function() &#123;&#125;;f.__proto__ === Function.prototype; // truevar f = new Function('&#123;&#125;');f.__proto__ === Function.prototype; // true 3.Object.create(null) 创建出的对象，不存在原型。12var a = Object.create(null); a.__proto__; // undefined 此外，函数的prototype中还有一个constructor方法，建议大家就当它不存在，它的存在让JavaScript原型的概念变得更加混乱，而且这个方法也几乎没有作用。]]></content>
      <categories>
        <category>原型</category>
      </categories>
      <tags>
        <tag>prototype</tag>
        <tag>原型链</tag>
        <tag>原型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用SVG + CSS实现动态霓虹灯文字效果]]></title>
    <url>%2F2017%2F01%2F01%2F%E4%BD%BF%E7%94%A8SVG%20%2B%20CSS%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81%E9%9C%93%E8%99%B9%E7%81%AF%E6%96%87%E5%AD%97%E6%95%88%E6%9E%9C%2F</url>
    <content type="text"><![CDATA[早上无意间进入一个网站，看到他们的LOGO效果略屌，如图： 刚开始以为是gif动画之类的，审查元素发现居然是用SVG + CSS3动画实现的，顿时激起了我的(hao)欲(qi)望(xin)，决定要一探究竟，查看代码之后，发现原理居然是如此简单：多个SVG描边动画使用不同的animation-delay即可！ 对于一个形状SVG元素或文本SVG元素，可以使用stroke-dasharray来控制描边的间隔样式，并且可以用stroke-dashoffset来控制描边的偏移量，借此可以实现描边动画效果，更具体的资料可以看看张大神的《纯CSS实现帅气的SVG路径描边动画效果》 我们先实现一个简单的文字描边动画： 12345&lt;svg width="100%" height="100"&gt; &lt;text text-anchor="middle" x="50%" y="50%" class="text"&gt; segmentfault.com &lt;/text&gt;&lt;/svg&gt; 123456789101112131415.text&#123; font-size: 64px; font-weight: bold; text-transform: uppercase; fill: none; stroke: #3498db; stroke-width: 2px; stroke-dasharray: 90 310; animation: stroke 6s infinite linear;&#125;@keyframes stroke &#123; 100% &#123; stroke-dashoffset: -400; &#125;&#125; 演示地址：http://output.jsbin.com/demic… 然后我们同时使用多个描边动画，并设置不同的animation-delay： 1234567891011121314&lt;svg width="100%" height="100"&gt; &lt;text text-anchor="middle" x="50%" y="50%" class="text text-1"&gt; segmentfault.com &lt;/text&gt; &lt;text text-anchor="middle" x="50%" y="50%" class="text text-2"&gt; segmentfault.com &lt;/text&gt; &lt;text text-anchor="middle" x="50%" y="50%" class="text text-3"&gt; segmentfault.com &lt;/text&gt; &lt;text text-anchor="middle" x="50%" y="50%" class="text text-4"&gt; segmentfault.com &lt;/text&gt;&lt;/svg&gt; 注意：要使用多少种颜色，就放多少个text 1234567891011121314151617181920212223242526272829303132333435.text&#123; font-size: 64px; font-weight: bold; text-transform: uppercase; fill: none; stroke-width: 2px; stroke-dasharray: 90 310; animation: stroke 6s infinite linear;&#125;.text-1&#123; stroke: #3498db; text-shadow: 0 0 5px #3498db; animation-delay: -1.5s;&#125;.text-2&#123; stroke: #f39c12; text-shadow: 0 0 5px #f39c12; animation-delay: -3s;&#125;.text-3&#123; stroke: #e74c3c; text-shadow: 0 0 5px #e74c3c; animation-delay: -4.5s;&#125;.text-4&#123; stroke: #9b59b6; text-shadow: 0 0 5px #9b59b6; animation-delay: -6s;&#125;@keyframes stroke &#123; 100% &#123; stroke-dashoffset: -400; &#125;&#125; 大功告成，演示地址：http://output.jsbin.com/vuyuv… 需要注意的几个点： 各个元素的animation-delay与animation的总时长的设置要协调 stroke-dashoffset与stroke-dasharray的设置要协调]]></content>
      <categories>
        <category>css案例</category>
      </categories>
      <tags>
        <tag>霓虹灯效果</tag>
        <tag>svg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript基础知识（上篇）]]></title>
    <url>%2F2016%2F06%2F12%2FJS%E5%9F%BA%E7%A1%80(%E4%B8%8A%E7%AF%87)%2F</url>
    <content type="text"><![CDATA[JS前置知识浏览器以及网站相关介绍 浏览器定义：可以显示网页服务器或者文件系统的HTML文件内容，并让用户与这些文件交互的一种软件 我们常规使用的五大浏览器：chorme，firefox，IE，Safari以及Oprea 从内核来看：有webkit，gecko，trident，presto 1、Trident内核代表产品Internet Explorer，又称其为IE内核。Trident（又称为MSHTML），是微软开发的一种排版引擎。使用Trident渲染引擎的浏览器包括：IE、傲游、世界之窗浏览器、Avant、腾讯TT、Netscape 8、NetCaptor、Sleipnir、GOSURF、GreenBrowser和KKman等。 2、Gecko内核代表作品Mozilla FirefoxGecko是一套开放源代码的、以C++编写的网页排版引擎。Gecko是最流行的排版引擎之一，仅次于Trident。使用它的最著名浏览器有Firefox、Netscape6至9。 3、WebKit内核代表作品Safari、Chromewebkit 是一个开源项目，包含了来自KDE项目和苹果公司的一些组件，主要用于Mac OS系统，它的特点在于源码结构清晰、渲染速度极快。缺点是对网页代码的兼容性不高，导致一些编写不标准的网页无法正常显示。主要代表作品有Safari和Google的浏览器Chrome。 4、Presto内核代表作品OperaPresto是由Opera Software开发的浏览器排版引擎，供Opera 7.0及以上使用。它取代了旧版Opera 4至6版本使用的Elektra排版引擎，包括加入动态功能，例如网页或其部分可随着DOM及Script语法的事件而重新排版。 各主流浏览器内核介绍 了解四大主流浏览器内核 主流浏览器内核介绍 1浏览器工作原理的介绍 说明： 1、User Interface 用户界面，我们所看到的浏览器 2、Browser engine 浏览器引擎，用来查询和操作渲染引擎 3、Rendering engine 用来显示请求的内容，负责解析HTML、CSS 4、Networking 网络，负责发送网络请求 5、JavaScript Interpreter(解析者) JavaScript解析器，负责执行JavaScript的代码 6、UI Backend UI后端，用来绘制类似组合框和弹出窗口 7、Data Persistence(持久化) 数据持久化，数据存储 cookie、HTML5中的sessionStorage 2网站工作原理的简单介绍 为什么要有js？js设计的最初目的 - 判断客户端表单输入验证(以前的网速慢) - 后来被一度用于小广告 js现在的意义 -页面特效（pc端的网页特效） -移动端（移动web和app） -异步和服务器交互 ajax -服务器端开发（nodeJs） -数据库甚至烤面包机都可以运行js了 （mongodb 嵌入式开发） js的历史总结： -javascript诞生于1995年 -javascript的是由网景公司的布兰登艾奇开发的 -javascript的前名叫livescript 什么是JS语言？ javascript是一种运行在客户端 的脚本语言 客户端：即接受服务的一端，与服务端相对应，在前端开发中，通常客户端指的就是浏览器。 脚本语言：也叫解释型语言，特点是执行一行，解释一行，如果发现报错，代码就停止执行 。 tips：脚本语言一般会有一个宿主环境（当前脚本运行并且起作用一个环境） 类似的有：as（actionScript flash宿主环境） javascript的三个组成部分：ECMAScript、BOM、DOM ECMAScript：定义了javascript的语法规范，是js语法的基础核心。 BOM：定义一套操作浏览器功能的API，通过这些api能够更好的操作浏览器行为。 DOM：定义一套操作页面元素的API，通过使用这些api来操作页面元素。 script标签 书写Javascript代码有三种方式，第一种是直接在script标签中书写，第二种是将代码写在js文件中，通过script进行引入。第三种为内嵌入html结构中书写js，但不利于后期代码开发和维护，不推荐； 直接在script中书写javascript代码： 123&lt;script&gt; alert("今天天气真好呀");&lt;/script&gt; 通过script标签引入一个JS文件，需要指定src属性 1&lt;script src="test.js"&gt;&lt;/script&gt; 通过在html标签中内嵌入html结构执行(但这种方式并不推荐 不利于后期代码开发和维护) 1&lt;div onclick="alert('今天天气不错！')"&gt;&lt;/div&gt; tips：如果script标签指定了src属性，说明是想要引入一个js文件，这个时候不能继续在script标签中写JS代码，即便写了，也不会执行。 script标签的书写位置，原则上来说，可以在页面中的任意位置书写script标签。 写在head标签中，style标签之后。 写在&lt;//body&gt;标签的前面。 写在的后面，即页面的最后面。 script的一些属性 1&lt;script language=JavaScript type="text/javascript"&gt; language已废弃,用于说明代码使用的脚本语言 src 表示要引入的外部文件 type 表示脚本语言的类型(type=”text/javascript” 在html5的结构可以省略不写) async(了解) async=”async” 值可以省略，立即异步下载外部JS下载完毕立即执行 defer(了解) defer=”defer” 值可以省略，脚本延迟到文档完全被解析和显示后再执行 1234&lt;script src="myJs.js" async="async"&gt;&lt;/script&gt;&lt;!--async立即异步下载外部JS,JS下载完毕立即执行--&gt;&lt;!--defer立即异步下载外部JS,JS下载完毕延迟到最后执行--&gt;&lt;!--这两个属性可以省略属性值--&gt; 输入输出语句 在实际开发，常用1和3，并且1在控制台输出不影响页面正常显示，不会阻塞代码运行，灵活操作，在实际开发中用于代码调试较多。 console.log 控制台输出日志 document.write 往页面中写入内容 alert 弹框警告[^注释] confirm 确认框[^注释] prompt 输入框[^注释] 1234567console.log("内容");//在控制台打印输出内容document.write("内容");//在页面书写内容alert("内容");//弹窗显示内容console.warn("警告框 一般系统在使用");console.error("错误提示信息，一般系统在使用");console.info("输出信息");confirm("请回答是或者否"); [^注释]: window 是全局对象 是浏览器中的顶级对象 window.alert()中的window 可以省略不写 注释 不被程序执行的代码。用于程序员标记代码，在后期的修改，以及他人的学习时有所帮助，在JS中，分为单行注释和多行注释 1234//这是单行注释，只能注释一行/* 这是多行注释，不能嵌套*/ 注释的作用： 1. 模块划分，方便代码查找和维护 2. 用于解释复杂代码的逻辑，方便维护和后期开发。 永无bug.js 变量 什么是变量变量是计算机内存中存储数据的标识符，根据变量名称可以获取到内存中存储的数据 为什么要使用变量使用变量可以方便的获取或者修改内存中的数据 如何使用变量 var声明变量 1var age; //声明未赋值 其值为未定义undefined 变量的赋值 12var age;age = 18; 同时声明多个变量 123var age, name, sex;age = 10;name = 'zs'; 同时声明多个变量并赋值 1var age = 10, name = 'zs'; 变量在内存中的存储后续通过交换值变量来演示 变量的命名规则与规范1234567命名规则（必须遵守）：1.由字母、数字、下划线、$符号组成，开头不能是数字。2.不能是关键字和保留字3.区分大小写命名规范（建议遵守）：1. 命名要有意义2. 遵守驼峰命名法。首字母小写，后面单词的首字母需要大写。 1var userName; var borderTopColor; 变量练习第一种方式：普通临时变量交换方式12345678910/* 适用性: 适用于所有类型 简要说明: 这是用到的最广泛的一种方式，经实战测试分析，性能也很高 (在JS中,这种方式效率确实很高，而且就算是其它语言中，只要tmp变量提前创建，性能也不会很低，反而是一些杂技派和少数派性能方面很低) 基本上可以说: 经典的才是最优雅的*/tmp = aa = bb = tmp 第二种:利用一个新的对象来进行数据交换12345678/* 适用性: 适用于所有类型 简要说明:这种方式在实战中应用的很少*/a = &#123;a : b, b : a&#125;b = a.ba = a.a 第三种:利用一个新的数组来进行数据交换123456/* 适用性: 适用于所有类型 简要说明:这种方式在各大论坛中都有看到有人使用，但经测试实际性能并不高*/a = [b, b=a][0] 第四种:利用数组交换变量(需EJS支持)123456/* 适用性: 适用于所有类型 简要说明:这也是在ES6出来后看到有人用的，实际在现有的浏览器中测试，性能很低*/[a, b] = [b, a] 第五种:利用try catch交换123456789/* 适用性: 适用于所有类型 简要说明:这种方法应该是基本没人使用的，也没有什么实用性，而且性能也是属于在各种方法中垫底的*/a=(function()&#123; try&#123;return b&#125; finally&#123;b=a&#125;&#125;)() 第六种:异或操作交换变量第一种方式123456/* 适用性: 适用于数字或字符串 简要说明:异或方法在数字或字符串时用到的比较普遍，而且性能也不低*/a = (b = (a ^= b) ^ b) ^ a 第七种:异或操作交换变量第二种方式12345678/* 适用性: 适用于数字或字符串 简要说明:异或方法在数字或字符串时用到的比较普遍，而且性能也不低*/a ^=bb ^=aa ^=b 第八种:数字之间的加减运算来实现，第一种加减方式12345678/* 适用性: 仅适用于数字 简要说明:这种用法在只用于数字间的交换时，性能也不弱*/a = a + b;b = a - b; a = a - b; 第九种:数字之间的加减运算来实现，第一种加减方式123456/* 适用性: 仅适用于数字 简要说明:这种用法在只用于数字间的交换时，性能也不弱*/a = b -a +(b = a) 第十种:利用eval计算1234567/* 适用性: 仅适用于数字和字符串 简要说明:这种方式仅用于研究，实战慎用这种模式执行一万次耗时等于其它执行一亿次...*/eval("a="+b+";b="+a); 第十一种:数组中，利用splice交换两个元素的位置123456/* 适用性: 仅适用于数组元素 简要说明:这种方式看起来挺优雅的，但实际上性能远远比不上临时变量那种*/arr[0] = arr.splice(2, 1, arr[0])[0] 各种交换方式的性能对比123456789上述列举了几种方式都有一一做过对比分析，基本上可以得出的结论是:还是老老实实的用回临时变量交换吧，经典，优雅，而且保证不会出什么幺蛾子在chrome中运行了一亿次后得出的结论(每次运行100万次,一共100个循环，得到的分析结果)可以看出,tmp变量交换最快,try catch最慢在chrome (支持es6)中运行了100万次后得出的结论(每次运行1万次,一共100个循环，得到的分析结果)可以看出,eval最慢,splice性能较低，tmp变量交换很稳定 Exchange Variables Gracefully tips:javascript是一种弱类型语言，不管声明什么类型的变量，都是用var，并且变量的类型是可以变化的。 12var age = 90;age = "张三"; JavaScript中的数据类型简单(基本、值)数据类型 Number（数字类型）、String（字符串）、Boolean（布尔类型） Undefined、Null（特殊类型） 复杂(引用)数据类型 object 如何查看数据类型使用typeof关键字查看数据类型 12typeof name;typeof(name); Number类型进制123451. 十进制，我们平时使用的就是十进制，进行运算时，八进制和十六进制的值最终都会转换成十进制。2. 八进制，0开头的数值，数值序列：0-73. 十六进制，0x开头的数值，数值序列：0-9A-F进制了解即可，基本都是使用十进制，稍微了解一下进制之间的转换。 浮点数科学计数法： 科学记数法是指把一个数表示成a×10的n次幂的形式（1≤a&lt;10，n 为整数。） 12var num = 5e+3; //5000var num1 = 5e-2; //0.05 浮点数的精度问题： 120.1 + 0.2 = ? //0.300000000000000040.07 * 100 = ? //7.000000000000001 浮点数在运算的时候会出现精度丢失的问题，因此在做比较运算的时候，尽量不要用小数进行比较。 数值范围 javascript不能表示世界上所有的数，因此在javascript中，数值大小是有一定限制的。 1234Number.MIN_VALUE :5e-324Number.MAX_VALUE :1.7976931348623157e+308Infinity :正无穷-Infinity :负无穷 数值判断1231. NaN:表示一个非数值，当无法运算或者运算错误的时候，会得到一个NaN，NaN是number类型，表示一个非数值。2. NaN不等于NaN3. isNaN用来判断是否是一个数字，当返回true的时候，表示不是一个数字，返回false表示是一个数字。 【要求：判断一个数据是不是数字】1234var data = "abc";if(typeof data == "number"&amp;&amp;!isNaN(data))&#123; console.log("是数字"); &#125; String类型字面量字符串的字面量：“abc” 、 ‘abc’ 字符串可以是双引号，也可以是单引号引起来。单双引号可以嵌套使用。 1234//我是一个"正直"的人 //我很喜欢"传'智'播客"console.log('我是一个"正直"的人');console.log('我很喜欢吃"好吃\'的\'东西"'); 字符串长度length属性用来获取字符串的长度 12var str = "abckjdlkfjd";str.length;//字符串的长度 ###字符串的不可变性 什么是不可变性(Immutability)？还是先来看看关于可变性(Mutability)的教条式定义：“liable or subject to change or alteration(译者注：真他妈难翻，就简单理解成’易于改变的’吧)”。在编程领域里，我们用可变性(Mutability)来描述这样一种对象，它在创建之后状态依旧可被改变。那当我们说不可变(Immutable)时，就是可变(Mutable)的对立面了(译者注：原谅我翻的废话又多起来) － 意思是，创建之后，就再也不能被修改了。 如果我说的又让你感到诡异了，原谅我小小的提醒一下，其实我们平时使用的很多东西事实上都是不可变的哦！ var statement = ‘I am an immutable value’;var otherStr = statement.slice(8, 17);我猜没人会吃惊，statement.slice(8, 17)并没有改变statement变量吧(译者注：如果你吃惊了，赶紧去补基本知识吧)？事实上，string对象上的所有方法里，没有一个会修改原string，它们一律返回新的string。原因简单了，因为string就是是不可变的(Immutable) - 它们不能被修改，我们能做的就是基于原string操作后得到一个新string。 注意了，string可不是javascript里唯一内置的不可变(Immutable)数据类型哦。number也是不可变(Immutable)的。否则的话，你试想下这个表达式2 + 3，如果2的含义能被修改，那代码该怎么写啊|_|。听起来荒谬吧，但我们在编程中却常常对object和array做出这种事儿。 字符串拼接拼接字符串使用+号 12345//思考：console.log(11 + 11);console.log("hello" + " world");console.log("100" + "100");console.log("11" + 11); 两边只要有一个是字符串，那么+就是字符串拼接功能 两边如果都是数字，那么就是算术功能。 boolean类型boolean类型只有两个字面量，true和false，区分大小写。 所有类型的值都可以转化成true或者false 1NaN、""、undefined、null、false、0 这6个值可以转换成false，其余的都是true。 undefined类型与null类型123456undefined表示一个声明了没有赋值的变量null表示一个空的对象。undefined派生自null。undefined == null ：trueundefined === null ：false 12345678910111213141516171819/* undefined : var age;//变量声明未赋值 值为undefinedfunction abc(a,b)&#123;&#125; abc(); //形参未接收实参 其值 为undefinedvar arr = new Array(5);//alert(arr[1]);//数组中如果没有值 值为undefinedreturn 在函数内部 默认 返回值无 则返回undefined*//*一个对象 身上没有这个属性 那么这个属性值为undefined*/// js程序当中如果没有值 则默认会给一个undefined 程序自动给的/*alert(a);//报错*//*alert(window.a);*///var student1 = &#123; name:"zhangsan", age:25&#125;alert(student1['name']);var student1 = null;//将这个对象在内存中清除了 在堆内存中空间上清除 console.log(student1.name);// null： 空对象 如果一个对象没有数据 或者说需要清空对象 这是时候人为可以赋值 为null 类型转换如何使用谷歌浏览器，快速的查看数据类型？ 字符串的颜色是黑色的，数值类型是蓝色的，布尔类型也是蓝色的，undefined和null是灰色的，这个在调试过程中时非常有用的。 转换成字符串类型 toString() (undefined和null无法使用此方法) String() /+ “” 转换成数值类型 Number() (尝试将任何数据类型进行转换 如果转不了 返回一个NaN) parseInt parseFloat +num, -0等运算 (隐式转换) 1234567891011121314151617181920212223//10进制转为16进制(10).toString(16) // =&gt;"a"//8进制转为16进制(012).toString(16) // =&gt;"a"//16进制转为10进制(0x16).toString(10) // =&gt;"22"//16进制转为8进制(0x16).toString(8) // =&gt;"26"//10进制转为2进制 //=&gt;(1111).toString(2) // =&gt; "10001010111"//8进制转为2进制 //=&gt;(01111).toString(2) //=&gt;"1001001001"//16进制转为2进制 //=&gt;(0x16).toString(2) // =&gt; "10110"//2进制到10进制；parseInt(10,2) //=&gt;2//2进制到10进制；parseInt(100,2) //=&gt;4//16进制到10进制parseInt(12, 16) //=&gt;18//8进制到10进制parseInt(12,8); //=&gt;10 转换成布尔类型 Boolean (强制类型转换) !! (隐式类型转换)]]></content>
      <categories>
        <category>js基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[JavaScript基础知识（下篇）]]></title>
    <url>%2F2016%2F02%2F10%2FJS%E5%9F%BA%E7%A1%80(%E4%B8%8B%E7%AF%87)%2F</url>
    <content type="text"><![CDATA[操作符@运算符 一元运算符@递增和递减递增++ 递减–a++ 先参与运算 后自加++a 先自加 后参与运算 关系运算符alert(&quot;A&quot;&gt;&quot;a&quot;);//false 65 97 字符串之间进行比较 会按照字符编码进行逐位比较 alert(&quot;15&quot;&gt;&quot;1&quot;);//true 逻辑运算符@逻辑运算符逻辑运算&amp;&amp;和||都采取短路运算，即第一个能够决定结果就不再看第二个了&amp;&amp; 的要求比较严格 要两个都是true才是true 所以看到第一个是false就没有必要继续完后看了 1console.log(false &amp;&amp; 不管了); || 的要求比较宽松 要两个都是false才是false 所以看到第一个是true就没有必要继续完后看了 1console.log(true || 不管了); 短路运算&amp;&amp;和||不但可以操作布尔类型的值，对其他类型的值也可以进行操作，并返回可以决定表达式结果的那个值。 赋值运算符@赋值运算符 1a+=b 等价于 a=a+b @表达式练习 运算符的优先级下表按从最高到最低的优先级列出JavaScript运算符。具有相同优先级的运算符按从左至右的顺序求值。 运算符 描述 . [] () 字段访问、数组下标、函数调用以及表达式分组 ++ – - ~ ! delete new typeof void 一元运算符、返回数据类型、对象创建、未定义值 * / % 乘法、除法、取模 + - + 加法、减法、字符串连接 &lt;&lt; &gt;&gt; &gt;&gt;&gt; 移位 &lt; &lt;= &gt; &gt;= instanceof 小于、小于等于、大于、大于等于、instanceof == != \=== !== 等于、不等于、严格相等、非严格相等 &amp; 按位与 ^ 按位异或 &#124; 按位或 &amp;&amp; 逻辑与 &#124;&#124; 逻辑或 ?: 条件 = oP= 赋值、运算赋值 , 多重求值 一元运算符 ++ -- ! 算数运算符 先* / % 后 + - 关系运算符 &gt; &gt;= &lt; &lt;= 相等运算符 == != === !== 逻辑运算符 先&amp;&amp; 后|| 语句选择语句ifif (condition) { statement1 } else if (condition) { statement2 } else { statement3 } @选择语句If 1234567//判断一个年份是闰年还是平年；四年一润,百年不润;四百年再润var year = 2016;if(year%4==0&amp;&amp;year%100!=0 || year%400==0)&#123; console.log(year+"是闰年");&#125;else&#123; console.log(year+"是平年");&#125; 三元表达式1表达式1 ? 表达式2 : 表达式3 1234567//从三个数中找最大值var num1 = 18;var num2 = 22;var num3 = 12;var result = (num1&gt;num2?num1:num2)&gt;num3?(num1&gt;num2?num1:num2):num3;console.log(result); @三元表达式 选择语句switchswitch (expression) { case value: statement break; case value: statement break; default: statement } 12345678910111213141516171819202122232425//显示星期几 1 2 3 4 5 6 0//var week = new Date().getDay();//3/*alert(week);*/switch(week)&#123; case 1:alert("星期一");break; case 2:alert("星期二");break; case 3:alert("星期三");break; case 4:alert("星期四");break; case 5:alert("星期五");break; case 6:alert("星期六");break; case 0:alert("星期日");break;&#125;/*素质教育（把分数变成ABCDE） A 90 B 80 千万不要写100个case哟*/var score = 76; switch(true)&#123; case score&gt;=90:alert("A");break; case score&gt;=80:alert("B");break; case score&gt;=60:alert("C");break; default:alert("不及格");break;&#125; @选择语句switch 循环语句forfor (initialization; expression; post-loop-expression)｛ statement ｝ 1234567891011//打印99乘法表document.write("&lt;table&gt;"); for(var i=1;i&lt;=9;i++)&#123; document.write("&lt;tr&gt;"); for(var j=1;j&lt;=i;j++)&#123; document.write("&lt;td style='border:1px solid red'&gt;"+j+"x"+i+"="+i*j+"&lt;/td&gt;"); &#125; document.write("&lt;/tr&gt;"); &#125;document.write("&lt;/table&gt;"); initialization表示：初始化表达式expression表示：控制表达式post-loop-expression表示：循环后表达式三者都是可选的@循环语句for break和continuebreak跳出当前循环，执行循环后的语句continue跳出当前循环，继续执行循环@break和continue 循环语句whilewhile语句 先判断后执行 1while(expression) statement 12345678//计算1+2+3+……+100之和。var sum = 0;//定义一个变量 用来求和var i = 1;//循环初始值while(i&lt;=5)&#123;//循环条件 sum+=i;//具体的事情 i++;//循环变量 自增&#125;console.log(sum); do while 语句 先执行后判断 1do &#123;statement&#125; while (expression); @循环语句while 数组数组的声明通过构造函数声明 1var arr = new Array("a", "b", "c") 通过字面量声明（推荐使用这种方法） 1var arr = ["a","b","c"]; 数组的赋值和取值赋值 1数组名[索引号] = 值 //arr[0]=100 取值（通过数组名和索引即可取到对应的值） 1数组名[索引号] //console.log(arr[0]) 数组的遍历（循环 枚举）@数组 数组的索引是从0开始的 数组的长度可以通过arr.length获取 由于数组的索引从0开始，所以最后一个值的索引为arr.length-1 通过for循环遍历数组 123for (var i = 0; i &lt;= arr.length - 1; i++) &#123; console.log(arr[i]);&#125; 可简写为： 123for (var i = 0; i &lt; arr.length; i++) &#123; console.log(arr[i]);&#125; @数组练习 @数组length的应用 往数组中添加新元素，数组的length会增加 通过给arr.length赋值可以改变数组的长度 @数组练习 冒泡排序@冒泡排序 12345678910111213141516171819var arr = [2,1,4,3,5];for(var i=0;i&lt;arr.length-1;i++)&#123;//外层循环控制比较了轮数 //对于轮数的优化 var onOff = true; //优化一下每轮比较次数 for(var j=0;j&lt;arr.length-1-i;j++)&#123;//里面的循环控制的每轮的比较次数 //如果前一项比后面一项大 则交换位置 if(arr[j]&gt;arr[j+1])&#123; var temp = arr[j]; arr[j]=arr[j+1]; arr[j+1]=temp; onOff=false; &#125; &#125; if(onOff)&#123; break; &#125;&#125;console.log(arr); // returns [1, 2, 3, 4, 5] 函数函数的定义 把一个相对独立的完整的功能（代码块）封装起来用函数（包）起来起个名字（函数名），可以多次重复调用 函数的作用 使程序变得更简短而清晰有利于程序维护可以提高程序开发的效率提高了代码的重用性(复用性) 另一个好处 用函数 封装起来 由你来控制它什么时间执行 什么场景执行 函数的写法函数的声明 123function 函数名 () &#123; //函数体 &#125; 函数的分类 123456分类方式1 1.命名函数 2.匿名函数 分类方式2 内置函数 ： 官方提供好的函数 例如 alert() isNaN() parseInt() 自定义函数 ： 用户根据需求 自己定义的函数 函数的调用 函数不会主动执行 需要调用来执行 命名函数调用： 1func() //这是最直接最常见的调用方式，也符合一般人的思维逻辑，但是在某些情况下有一些不足 12345//函数名+()等于函数直接执行 匿名函数不能直接调用function aa()&#123; alert(123); &#125;aa(); 匿名函数调用： 1(function(arg)&#123;&#125;)(window) // 匿名方法调用，在构造命名空间时比较有用，后面的括号中的参数与匿名方法中的入参一一对应。 1234//匿名函数想要执行 可以通过 匿名函数的自调用 来实现(function ()&#123; console.log("哈哈");&#125;)();//匿名函数的自调用 函数的立即执行表达式 bind方式调用 1func.bind(sth)()//mozilla手册中提到bind是在ECMA-262 5th Edition中新增的一个特性，这里单独列出来作为一种调用方式是因为它弥补了直接调用中不能绑定作用域的缺陷。 call &amp; apply方式调用 12func.call()//这是第二种调用方式，每个方法的原型中都定义了call方法，用来执行当前方法。func.apply()//call的双胞胎兄弟。 @函数的声明和调用** 函数的参数 参数是一一对应的参数的个数可以是任意个 有参数的函数的声明（声明中的参数只是一个占位符，没有实际的值，是形式参数，即形参）1234//函数在声明的时候 所写的参数 形参相当于局部变量function 函数名 (参数1,参数2,参数3...) &#123; //函数体&#125; 有参数的函数的调用（调用时传入的参数才是有真正数值的参数，是实际参数，即实参） 12//函数在调用的时候 写的参数 实参函数名(参数1,参数2,参数3...); arguments：（实参的集合列表） arguments:是天然存在在函数里面的 当前函数执行时 传入的实参的集合列表 是一个类数组（类数组 伪数组） 具有数组的长度和下标 但是没有数组的方法 适合在参数个数不确定的情况下使用 123456789101112131415function sum()&#123; /*console.log(c,d);//undefined alert(a+b+c+d);//NaN*/ console.log(arguments);//[36,14] [2,9,4] [-6,5,18,3] console.log(arguments[1]);//14 9 5 console.log(arguments.length);//2 3 4 var sum = 0; for(var i=0;i&lt;arguments.length;i++)&#123; sum+=arguments[i]; &#125; alert(sum);&#125;sum(36,14);sum(2,9,4);sum(-6,5,18,3); @函数的参数 函数的返回值在函数中通过return关键字将要返回值返回 1return 要返回的值; return 详解（三个特点）： 1 return 后面可以返回任何数据类型 2 return 不明写 默认返回undefined 3 return 返回返回值之后 后续代码不执行 直接终止函数 函数高级概念@参数详解在JS中实参的个数和形参的个数可以不一致@返回值详解函数的返回值是什么，调用这个函数就相当于调用什么，如果没有回值则为undefined函数在执行完成return语句后便会退出函数，后面的代码不会执行@两种定义方式函数声明123function fn1() &#123; //函数体&#125; 函数表达式 var fn2 = function () { //函数体 };@匿名函数匿名函数（没有名字的函数） function () { //函数体 }@递归调用程序调用自身的编程技巧称为递归@回调函数函数也是一种普通的数据类型因此函数也可以被当作参数传递被当作参数传递的函数叫做回调函数 @函数的预解析 js的解析器拿到一段代码就会进行预解析 （凡是有作用域 一定有预解析） 预解析： 在当前的作用域下看看有没有声明的变量和声明的函数如果有提前放到预解析环境中，名称如果由冲突 函数比变量级别高 案例求阶乘 123456// 求一个数的阶乘function factorial(num) &#123; return num === 1?num:(num*factorial(num-1))&#125;console.log(factorial(5)) //120 求质数index.js 1234567891011121314151617181920// 1 ----n 之间的质数function isSu(n)&#123; var k =0;x`` if(n==0||n==1)&#123; return n+"既不是素数也不是合数"; &#125; for(var i=1;i&lt;=n;i++)&#123; // 0 1 既不是素数也不是合数 特殊情况特殊处理 if(n%i==0)&#123; k++; &#125; &#125; if(k==2)&#123; return n+"素数"; &#125;else&#123; return n+"合数"; &#125;&#125;for(var i=1;i&lt;=15;i++)&#123; console.log(isSu(i));&#125; 斐波那契数列 123456789/*输出斐波那契数列的前20项(递归) 1 1 2 3 5 8 13 21 */ function qiutuzi(n) &#123; if(n &lt;= 2)&#123; return 1; &#125; return qiutuzi(n-1)+qiutuzi(n-2)&#125;var result = qiutuzi(12);//144 设置盒子 index.js 1234567function $(id) &#123; // 如果某个属性 需要用变量或者形参代替 不能直接跟在.后面 把.去掉 改成[] function setStyle(attr, value) &#123; document.getElementById(id).style[attr] = value &#125; return setStyle &#125; index.html 12&lt;div id="box"&gt;&lt;/div&gt;&lt;button id="btn1" onclick="$('box')('width','200px')"&gt;单击让盒子变宽&lt;/button&gt; 验证码 要求：字母 数字 不重复 12345678910111213//这种写法由于传递的数组的引用，所以每次调用都会修改原数组function getNumber(n) &#123; var selectChar = [0,1,2,3,4,5,6,7,8,9,'a','A','b','B','c','C','d','D','e','E','f','F','g','G','h','H','i','I','j','J','k','K','l','L','m','M','n','N','o','O','p','P','q','Q','r','R','s','S','t','T','u','U','v','V','w','W','x','X','y','Y','z','Z'] var b = [] for (var i = 0; i &lt; n; i++) &#123; var numRandom = Math.floor(Math.random()*selectChar.length) b.push(selectChar[numRandom]) selectChar.splice(numRandom,1) &#125; return b.join('')&#125;console.log(getNumber(4)) 对象从宏观的角度讲，对象是对客观事物的抽象，事物的特征可以用属性表示，事物的行为可以用方法表示从微观的角度讲，对象就是一种数据类型，通过对象可以方便地对变量和函数进行管理 简单来说：JavaScript中的对象：无序属性的集合 var arr = [1,2,3];//特殊的对象 有序 特殊在数组的键名是有序的下标 1.2.1. 键值对键值对就是一种对应关系，通过键能够方便地找到值 1键:值 key:value k:v 对象的声明通过构造函数声明（更加通用） 1var obj= new Object(); 通过字面量声明（更加简便） 1var obj= &#123;&#125;; 对象具有属性和方法属性 用来描述对象的特征 一般是名词 对应变量方法 用来描述对象的行为 一般是动词 对应函数 json格式: javascript object notation js对象标记法轻量级的一种数据交换格式 （目前常用于 前后端数据交互） 1234&#123;"name":"张三","age" : 25&#125; xml :可扩展标记语言 过去老式的重量级的数据交换格式 html 1234&lt;person&gt;&lt;name&gt;张三&lt;/name&gt;&lt;age&gt;25&lt;/age&gt;&lt;/person&gt; 属性属性的定义1对象.属性名 = 值 属性的调用1对象.属性名 变量： 一个自由的变量 通过var 去声明 属性： 如果有一个变量 归属于一个对象下面 那么我们将该变量称为 该对象的一个属性 ​ 方法方法的定义 1对象.方法名 = function()&#123; //函数体 &#125; 方法的调用 1对象.方法名() 函数 一个自由的函数 方法 如果一个函数 归属一个对象下面 那么我们将该函数 称之为该对象的一个方法 只有对象才可以挂载属性和方法 @找对象练习** Math对象Math:js程序当中的一个内置的对象 提供一些方法用于数学计算 //Math.round();//四舍五入 console.log(Math.round(3.9));//4 console.log(Math.round(3.1));//3 console.log(Math.floor(3.9));//3 向下取整 console.log(Math.ceil(3.1));//向上取整4 console.log(Math.ceil(3.0));//向上取整 console.log(Math.max(9,15,3,1));//求最大值 console.log(Math.min(-8,5,1,0));//求最小值 console.log(Math.PI);//常量 无限不循环小数 圆周率 π 3.141592653989793 //console.log(Math.pow(a,b));//求a的b次方 // console.log(Math.sqrt(9));//求平方根 /*console.log(Math.tan());*/ console.log(Math.abs(-7));//取绝对值 //console.log(Math.random());//0--1随机小数 不包含1 [0,1) //求0-100之间的任意随机整数 //Math.round(Math.random()*100);//0--100 [0,100) //30---60 随机整数 // Math.round(Math.random()*30)+30 [30,60) //48---72随机整数 // Math.round(Math.random()*24)+48 [48,72) //求x-y之间的任意随机整数 // Math.round(Math.random()*(y-x))+x; [x,y) Date对象Date对象： js内置的一个日期时间对象 提供一些时间方法 方便我们来获取系统时间 12345678910111213141516171819var mydate = new Date();//获取是当前的系统时间console.log(mydate);//Tue Jun 20 2017 14:40:03 GMT+0800 (中国标准时间)console.log(typeof mydate);//objectvar date2 = new Date("2017-03-22");//创建一个指定日期的日期对象console.log(typeof date2,date2);//object Wed Mar 22 2017 08:00:00 GMT+0800 (中国标准时间)var date3 = new Date("2017-03-22 00:52:34");//创建一个指定日期 小时和分以及秒的日期对象console.log(typeof date3,date3);var mydate = new Date();var strDate = mydate.toString();console.log(typeof strDate,strDate);//将日期对象转换成字符串类型var strDate2 = mydate.toDateString();console.log(typeof strDate2,strDate2);//string Tue Jun 20 2017var strDate3 = mydate.toTimeString();console.log(typeof strDate3,strDate3);//string 14:48:23 GMT+0800 (中国标准时间) 电子时间 123456789101112131415161718192021222324var mydate = new Date();//获取系统时间 var myYear = mydate.getFullYear();//通过这个方法 获取具体的年console.log(myYear);//2017 number类型var myMonth = mydate.getMonth();//通过这个方法 获取具体的月console.log(myMonth);//系统里面的月份 从0开始var myDay = mydate.getDate();//通过这个方法 获取具体几号var h = mydate.getHours();//通过这个方法 获取具体小时数var m = mydate.getMinutes();//通过这个方法 获取具体分钟数var s = mydate.getSeconds();//通过这个方法 获取具体秒数var week = mydate.getDay();//通过这个方法 获取星期几console.log(week);//0--6 0星期日 var ms = mydate.getMilliseconds();//通过这个方法 获取毫秒数console.log(ms);var str = myYear+"年 "+myMonth+"月 "+myDay+"日 "+week+" "+h+":"+m+":"+s+":"+ms;document.write(str); 其他概念对象字面量@对象字面量1234567var o = &#123; name : "zs", age : 18, sayHi : function() &#123; console.log(this.name); &#125;&#125;; 对象标记法@对象标记法JavaScript Object Notation（JavaScript对象标记法）是仿照JS中对象字面量的格式去书写的一串用来记录对象数据的字符串，可以用于数据传输。将来学习AJAX会详细学习。 访问属性的两种方式@访问属性的两种方式点语法（简单）1对象.属性名 中括号（灵活）1对象[“属性名”] 遍历的两种方式@遍历的两种方式通过for可以对集合进行有序的遍历通过forin可以对集合进行有序的遍历123456for(var k in json) &#123; 语句 &#125;//对象的循环或者遍历 需要用for……in循环来遍历for(var k in obj)&#123;//console.log(k);//在for in循环中k变量其实是 这个对象的键名console.log(obj[k]);//对象.键名=键值 对象[代表属性的变量]=键值&#125; k变量代表的是json中的各个属性（key）和 var i = 0中的i是一个意思 名字不同而已 for in 语法遍历一个对象的可枚举属性for 按设置的条件循环执行包含的语句块 1234var mycars = new Array()mycars[0] = "Saab"mycars[2] = "Volvo"mycars[4] = "BMW" 对于数组对象mycars来说其长度为5，有“1”，“2”，“4”这3个可枚举属性所以 123for (y in mycars)&#123;console.log(mycars[y]);&#125; 可输出Saab,Volvo，BMW 而当 123for (y=0;y&lt;mycars.length;y++)&#123; console.log(mycars[y]);&#125; mycars.length值为5，y值分别为0，1，2，3,4mycars[y]相当于在执行mycars[String(y)]1，3下标处没有定义值，为undefined输出结果为Saab,undefind,Volvo,undefined,BMW 对象对象的声明和使用通过构造函数声明（更加通用） 1var obj= new Object(); 通过字面量声明（更加简便） 1var obj= &#123;&#125;; 对象具有属性和方法属性 用来描述对象的特征 一般是名词 对应变量方法 用来描述对象的行为 一般是动词 对应函数属性属性的定义 1对象.属性名 = 值 属性的调用 1对象.属性名 方法方法的定义 1对象.方法名 = function()&#123; //函数体 &#125; 方法的调用 1对象.方法名() 关于this的指向全局上下文全局运行上下文中（在任何函数体外部），this 指代全局对象 函数上下文对象方法中的this指的是该方法所属的对象直接调用中的this指的是全局对象总之，函数上下文中（在函数内部），this指的是当前函数所属的对象 构造函数中当一个函数被作为构造函数使用时（前面加new关键字），new关键字会让this的指向改变，并让其成为当前函数的返回值 批量创建对象工厂模式创建对象为什么要优化创建对象的方式因为对象在项目中被大规模的使用，所以每一点小小的改进都会对项目整体效率带来很大的提升，现阶段同学们还不可能有深刻的体会，只是让大家了解一下，后面讲项目大家自然就明白了。@工厂模式创建对象同类型对象，只是一些属性的值不同，通过对象字面量创建对象每次都要写那么多东西很费劲，我们可以将创建对象的过程封装进一个函数，只把发生变化的属性作为参数传入，从而简化对象创建的过程。但是工厂模式只是创建出来一个普通的对象并将其返回，因此无法判断实例的具体类型。 12345678910111213141516171819202122232425//如何批量创建对象//工厂方式//工厂：// 1 原料// 2 加工// 3 出厂function createStudent(name,age,job)&#123; //1 准备原料 var student1 = new Object(); //2 加工 student1.name=name; student1.age = age; student1.job = job; student1.sayHello=function () &#123; console.log("正在打招呼"); &#125; student1.study=function () &#123; console.log("正在学习js"); &#125; //出厂 return student1;&#125;var stu1 = createStudent("李四",25,"singer");stu1.sayHello();console.log(stu1.age); 构造函数创建对象@this和new利用new 关键字可以声明的对象。new 关键字可以让构造函数中this的指向改变，并让构造函数把this返回。@构造函数构造函数也是函数，只不过会默认返回一个对象。 @构造函数创建对象通过构造函数创建对象更方便（不需要创建对象并返回）。更重要的是可以通过instanceof来判断实例的类型了。 1234567891011121314151617181920212223242526272829//构造函数var arr = new Array();//程序当中定义好的数组的构造函数var mydate = new Date();//程序当中定义好的日期对象的构造函数/*new RegExp();//程序当中 定义好的正则对象*/function CreateStudent(name,age,job)&#123; //1 准备原料 /*var student1 = new Object();*/ //2 加工 // 隐式对象 模型 this.name=name; this.age = age; this.job = job; this.sayHello=function () &#123; console.log("正在打招呼"); &#125; this.study=function () &#123; console.log("正在学习js"); &#125; //出厂 /*return this;*/&#125;var stu1 = new CreateStudent("李四",25,"singer");var stu2 = new CreateStudent("张三",30,"dancer");/*1 通过 new 来调用这个函数那么这个函数是构造函数 （区别于普通函数 专门用来创建对象的） 2 如果外面通过new来调用里面 new Object()省略不写 return 省略不写 将属性和方法挂载到this 身上3 不成文的规定 构造函数的函数名 首字母大写4 通过new 调用构造函数的过程 就是实例化对象的过程 stu1 和stu2 实例化的对象*/ 基本类型和复杂类型分类基本数据类型（值类型）：直接存储值number、string、boolean、undefined、null（基本类型只有这五个）复杂数据类型（引用类型）：存储引用object 基本类型的复制* 复杂类型的复制 基本类型参数 复杂类型参数@复杂类型参数练习]]></content>
      <categories>
        <category>js基础</category>
      </categories>
      <tags>
        <tag>js基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模块化开发]]></title>
    <url>%2F2016%2F01%2F10%2F%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[在前端开发中，起初只需要在&lt;script&gt;&lt;/script&gt;加入很少的代码来实现一些基本的交互效果，后来随着js得到了越发的重视之后，使得前端项目也变得越来越来复杂，需要更好的组织形式来分类、实现业务逻辑，然而，JavaScript本身是没有类（class）的概念的，当然也就没有模块（module）的概念了。 一个模块就是实现特定功能的文件，有了模块，我们就可以更方便地使用别人的代码，想要什么功能，就加载什么模块。模块开发需要遵循一定的规范，否则就都乱套了。 目前，通行的js模块规范主要有两种：CommonJS和AMD。 根据AMD规范，我们可以使用define定义模块，使用require调用模块。 AMD规范 AMD 即Asynchronous Module Definition，中文名是“异步模块定义”的意思。它是一个在浏览器端模块化开发的规范，服务器端的规范是CommonJS 模块将被异步加载，模块加载不影响后面语句的运行。所有依赖某些模块的语句均放置在回调函数中。 AMD 是 RequireJS 在推广过程中对模块定义的规范化的产出。 define() 函数 AMD规范只定义了一个函数 define，它是全局变量。函数的描述为： 1define(id?, dependencies?, factory); 参数说明： id：指定义中模块的名字，可选；如果没有提供该参数，模块的名字应该默认为模块加载器请求的指定脚本的名字。如果提供了该参数，模块名必须是“顶级”的和绝对的（不允许相对名字）。 依赖dependencies：是一个当前模块依赖的，已被模块定义的模块标识的数组字面量。依赖参数是可选的，如果忽略此参数，它应该默认为[“require”, “exports”, “module”]。然而，如果工厂方法的长度属性小于3，加载器会选择以函数的长度属性指定的参数个数调用工厂方法。 工厂方法factory，模块初始化要执行的函数或对象。如果为函数，它应该只被执行一次。如果是对象，此对象应该为模块的输出值。 模块名的格式 模块名用来唯一标识定义中模块，它们同样在依赖性数组中使用： 模块名是用正斜杠分割的有意义单词的字符串单词须为驼峰形式，或者”.”，”..”模块名不允许文件扩展名的形式，如“.js”模块名可以为 “相对的” 或 “顶级的”。如果首字符为“.”或“..”则为相对的模块名顶级的模块名从根命名空间的概念模块解析相对的模块名从 “require” 书写和调用的模块解析 使用 require 和 exports 创建一个名为”alpha”的模块，使用了require，exports，和名为”beta”的模块: 1234567define("alpha", ["require", "exports", "beta"], function (require, exports, beta) &#123; exports.verb = function() &#123; return beta.verb(); //Or: return require("beta").verb(); &#125; &#125;); require API介绍[AMD规范中文版]https://github.com/amdjs/amdjs-api/wiki/AMD-(%E4%B8%AD%E6%96%87%E7%89%88) 目前，实现AMD的库有RequireJS 、rl 、Dojo 、Nodules 等。 *CommonJS规范 CommonJS是服务器端模块的规范，Node.js采用了这个规范。Node.JS首先采用了js模块化的概念。 根据CommonJS规范，一个单独的文件就是一个模块。每一个模块都是一个单独的作用域，也就是说，在该模块内部定义的变量，无法被其他模块读取，除非定义为global对象的属性。 输出模块变量的最好方法是使用module.exports对象。 123456789var i = 1;var max = 30; module.exports = function () &#123; for (i -= 1; i++ &lt; max; ) &#123; console.log(i); &#125; max *= 1.1;&#125;; 上面代码通过module.exports对象，定义了一个函数，该函数就是模块外部与内部通信的桥梁。 加载模块使用require方法，该方法读取一个文件并执行，最后返回文件内部的module.exports对象。 CommonJS 规范：http://javascript.ruanyifeng.com/nodejs/commonjs.html RequireJS和SeaJS RequireJS由James Burke创建，他也是AMD规范的创始人。 define方法用于定义模块，RequireJS要求每个模块放在一个单独的文件里。 RequireJS 和 Sea.js 都是模块加载器，倡导模块化开发理念，核心价值是让 JavaScript 的模块化开发变得简单自然。 SeaJS与RequireJS最大的区别: SeaJS对模块的态度是懒执行, 而RequireJS对模块的态度是预执行 不明白？看这篇图文并茂的文章吧：http://www.douban.com/note/283566440/ RequireJS API:http://www.requirejs.cn/docs/api.html RequireJS的用法：http://www.ruanyifeng.com/blog/2012/11/require_js.html 为什么要用requireJS 试想一下，如果一个网页有很多的js文件，那么浏览器在下载该页面的时候会先加载js文件，从而停止了网页的渲染，如果文件越多，浏览器可能失去响应。其次，要保证js文件的依赖性，依赖性最大的模块（文件）要放在最后加载，当依赖关系很复杂的时候，代码的编写和维护都会变得困难。 RequireJS就是为了解决这两个问题而诞生的： （1）实现js文件的异步加载，避免网页失去响应；（2）管理模块之间的依赖性，便于代码的编写和维护。 RequireJS文件下载：http://www.requirejs.cn/docs/download.html AMD和CMD CMD（Common Module Definition） 通用模块定义。该规范明确了模块的基本书写格式和基本交互规则。该规范是在国内发展出来的。AMD是依赖关系前置，CMD是按需加载。 在 CMD 规范中，一个模块就是一个文件。代码的书写格式如下： 1define(factory); factory 为函数时，表示是模块的构造方法。执行该构造方法，可以得到模块向外提供的接口。factory 方法在执行时，默认会传入三个参数：require、exports 和 module： 123define(function(require, exports, module) &#123; // 模块代码&#125;); require是可以把其他模块导入进来的一个参数，而export是可以把模块内的一些属性和方法导出的。 CMD规范地址：https://github.com/seajs/seajs/issues/242 AMD 是 RequireJS 在推广过程中对模块定义的规范化产出。CMD 是 SeaJS 在推广过程中对模块定义的规范化产出。 对于依赖的模块，AMD 是提前执行，CMD 是延迟执行。 AMD:提前执行（异步加载：依赖先执行）+延迟执行CMD:延迟执行（运行到需加载，根据顺序执行）CMD 推崇依赖就近，AMD 推崇依赖前置。看如下代码： 1234567891011121314151617// CMDdefine(function(require, exports, module) &#123;var a = require('./a')a.doSomething()// 此处略去 100 行var b = require('./b') // 依赖可以就近书写b.doSomething()// ... &#125;) // AMD 默认推荐的是define(['./a', './b'], function(a, b) &#123; // 依赖必须一开始就写好a.doSomething()// 此处略去 100 行b.doSomething()...&#125;) 另外一个区别是： AMD:API根据使用范围有区别，但使用同一个api接口CMD:每个API的职责单一AMD的优点是：异步并行加载，在AMD的规范下，同时异步加载是不会产生错误的。CMD的机制则不同，这种加载方式会产生错误，如果能规范化模块内容形式，也可以 jquery1.7以上版本会自动模块化，支持AMD模式：主要是使用define函数，sea.js虽然是CommonJS规范，但却使用了define来定义模块所以jQuery已经自动模块化了 123456seajs.config(&#123;'base':'/','alias':&#123; 'jquery':'jquery.js'//定义jQuery文件&#125;&#125;); define函数和AMD的define类似： 1234567define(function(require, exports, module&#123; //先要载入jQuery的模块 var $ = require('jquery'); //然后将jQuery对象传给插件模块 require('./cookie')($); //开始使用 $.cookie方法&#125;); sea.js如何使用？ 引入sea.js的库 如何变成模块？ define 3.如何调用模块？ -exports-sea.js.use4.如何依赖模块？ -require 1234567&lt;script type="text/javascript"&gt; define(function (require,exports,module) &#123; //exports : 对外的接口 //requires : 依赖的接口 require('./test.js');//如果地址是一个模块的话，那么require的返回值就是模块中的exports &#125;)&lt;/script&gt; sea.js 开发实例 123456789101112131415161718192021222324252627&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;&lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt;&lt;title&gt;鼠标拖拽的模块化开发实践&lt;/title&gt;&lt;style type="text/css"&gt;#div1&#123; width:200px; height:200px; background:black; position:absolute; display:none;&#125;#div2&#123; width:30px; height:30px; background:yellow; position:absolute; bottom:0; right:0;&#125;#div3&#123; width:100px; height:100px; background:blue; position:absolute; right:0; top:0;&#125;&lt;/style&gt;&lt;script type="text/javascript" src="./sea.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; //A同事 ：seajs.use('./main.js'); &lt;/script&gt;&lt;/head&gt; &lt;body&gt;&lt;input type="button" value="确定" id="input1" /&gt;&lt;div id="div1"&gt; &lt;div id="div2"&gt;&lt;/div&gt;&lt;/div&gt;&lt;div id="div3"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; A同事 123456789101112131415161718//A同事写的main.js: define(function (require,exports,module) &#123; var oInput = document.getElementById('input1'); var oDiv1 = document.getElementById('div1'); var oDiv2 = document.getElementById('div2'); var oDiv3 = document.getElementById('div3'); require('./drag.js').drag(oDiv3); oInput.onclick = function () &#123; oDiv1.style.display = 'block'; require('./scale.js').scale(oDiv1,oDiv2); require.async('./scale.js', function (ex) &#123; ex.scale(oDiv1,oDiv2); &#125;) &#125;&#125;); B同事 12345678910111213141516171819202122232425262728293031323334//B同事写的drag.js: define(function(require,exports,module)&#123; function drag(obj)&#123; var disX = 0; var disY = 0; obj.onmousedown = function(ev)&#123; var ev = ev || window.event; disX = ev.clientX - obj.offsetLeft; disY = ev.clientY - obj.offsetTop; document.onmousemove = function(ev)&#123; var ev = ev || window.event; var L = require('./range.js').range(ev.clientX - disX , document.documentElement.clientWidth - obj.offsetWidth , 0 ); var T = require('./range.js').range(ev.clientY - disY , document.documentElement.clientHeight - obj.offsetHeight , 0 ); obj.style.left = L + 'px'; obj.style.top = T + 'px'; &#125;; document.onmouseup = function()&#123; document.onmousemove = null; document.onmouseup = null; &#125;; return false; &#125;; &#125; exports.drag = drag;//对外提供接口 &#125;); C同事 123456789101112131415161718192021222324252627282930313233343536373839//C同事写的scale.js: define(function(require,exports,module)&#123; function scale(obj1,obj2)&#123; var disX = 0; var disY = 0; var disW = 0; var disH = 0; obj2.onmousedown = function(ev)&#123; var ev = ev || window.event; disX = ev.clientX; disY = ev.clientY; disW = obj1.offsetWidth; disH = obj1.offsetHeight; document.onmousemove = function(ev)&#123; var ev = ev || window.event; var W = require('./range.js').range(ev.clientX - disX + disW , 500 , 100); var H = require('./range.js').range(ev.clientY - disY + disH , 500 , 100); obj1.style.width = W + 'px'; obj1.style.height = H + 'px'; &#125;; document.onmouseup = function()&#123; document.onmousemove = null; document.onmouseup = null; &#125;; return false; &#125;; &#125; exports.scale = scale; &#125;); D同事 123456789101112131415161718192021// D同事的range.js--限定拖拽范围 define(function(require,exports,module)&#123; function range(iNum,iMax,iMin)&#123; if( iNum &gt; iMax )&#123; return iMax; &#125; else if( iNum &lt; iMin )&#123; return iMin; &#125; else&#123; return iNum; &#125; &#125; exports.range = range; &#125;); requirejs开发实例 require.config是用来定义别名的，在paths属性下配置别名。然后通过requirejs(参数一，参数二)；参数一是数组，传入我们需要引用的模块名，第二个参数是个回调函数，回调函数传入一个变量，代替刚才所引入的模块。 main.js文件 12345678910//别名配置requirejs.config(&#123; paths: &#123; jquery: 'jquery.min' //可以省略.js &#125;&#125;);//引入模块，用变量$表示jquery模块requirejs(['jquery'], function ($) &#123; $('body').css('background-color','red');&#125;); 引入模块也可以只写require()。requirejs通过define()定义模块，定义的参数上同。在此模块内的方法和变量外部是无法访问的，只有通过return返回才行. define 模块 1234567define(['jquery'], function ($) &#123;//引入jQuery模块 return &#123; add: function(x,y)&#123; return x + y; &#125; &#125;;&#125;); 将该模块命名为math.js保存。 main.js引入模块方法 123require(['jquery','math'], function ($,math) &#123; console.log(math.add(10,100));//110&#125;); 没有依赖 如果定义的模块不依赖其他模块，则可以： 1234567define(function () &#123; return &#123; name: "trigkit4", age: "21" &#125;&#125;); AMD推荐的风格通过返回一个对象做为模块对象，CommonJS的风格通过对module.exports或exports的属性赋值来达到暴露模块对象的目的。]]></content>
      <categories>
        <category>模块化开发</category>
      </categories>
      <tags>
        <tag>模块化开发</tag>
      </tags>
  </entry>
</search>
