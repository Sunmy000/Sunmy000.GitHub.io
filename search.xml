<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JS基础知识]]></title>
    <url>%2F2017%2F06%2F11%2FJS%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[JS前置知识浏览器以及网站相关介绍 浏览器定义：可以显示网页服务器或者文件系统的HTML文件内容，并让用户与这些文件交互的一种软件 我们常规使用的五大浏览器：chorme，firefox，IE，Safari以及Oprea 从内核来看：有webkit，gecko，trident，presto 1、Trident内核代表产品Internet Explorer，又称其为IE内核。Trident（又称为MSHTML），是微软开发的 一种排版引擎。使用Trident渲染引擎的浏览器包括：IE、傲游、世界之窗浏览器、Avant、腾讯TT、Netscape 8、NetCaptor、Sleipnir、GOSURF、GreenBrowser和KKman等。 2、Gecko内核代表作品Mozilla FirefoxGecko是一套开放源代码的、以C++编写的网页排版引擎。Gecko是最 流行的排版引擎之一，仅次于Trident。使用它的最著名浏览器有Firefox、Netscape6至9。 3、WebKit内核代表作品Safari、Chromewebkit 是一个开源项目，包含了来自KDE项目和苹果公司的一些组件 ，主要用于Mac OS系统，它的特点在于源码结构清晰、渲染速度极快。缺点是对网页代码的兼容性不高，导致一 些编写不标准的网页无法正常显示。主要代表作品有Safari和Google的浏览器Chrome。 4、Presto内核代表作品OperaPresto是由Opera Software开发的浏览器排版引擎，供Opera 7.0及以上使用。 它取代了旧版Opera 4至6版本使用的Elektra排版引擎，包括加入动态功能，例如网页或其部分可随着DOM及 Script语法的事件而重新排版。 各主流浏览器内核介绍 了解四大主流浏览器内核 主流浏览器内核介绍 1浏览器工作原理的介绍12345678说明： 1、User Interface 用户界面，我们所看到的浏览器 2、Browser engine 浏览器引擎，用来查询和操作渲染引擎 3、Rendering engine 用来显示请求的内容，负责解析HTML、CSS 4、Networking 网络，负责发送网络请求 5、JavaScript Interpreter(解析者) JavaScript解析器，负责执行JavaScript的代码 6、UI Backend UI后端，用来绘制类似组合框和弹出窗口 7、Data Persistence(持久化) 数据持久化，数据存储 cookie、HTML5中的sessionStorage 2网站工作原理的简单介绍 为什么要有js？js设计的最初目的 - 判断客户端表单输入验证(以前的网速慢) - 后来被一度用于小广告 js现在的意义 -页面特效（pc端的网页特效） -移动端（移动web和app） -异步和服务器交互 ajax -服务器端开发（nodeJs） -数据库甚至烤面包机都可以运行js了 （mongodb 嵌入式开发） -另外还可以抢月饼（阿里巴巴月饼事件） js的历史总结： - javascript诞生于1995年 -javascript的是由网景公司的布兰登艾奇开发的 -javascript的前名叫livescript 什么是JS语言？ javascript是一种运行在客户端 的脚本语言 客户端：即接受服务的一端，与服务端相对应，在前端开发中，通常客户端指的就是浏览器。 脚本语言：也叫解释型语言，特点是执行一行，解释一行，如果发现报错，代码就停止执行 。 12tips：脚本语言一般会有一个宿主环境（当前脚本运行并且起作用一个环境）类似的有：as（actionScript flash宿主环境） javascript的三个组成部分：ECMAScript、BOM、DOM ECMAScript：定义了javascript的语法规范，是js语法的基础核心。 BOM：定义一套操作浏览器功能的API，通过这些api能够更好的操作浏览器行为。 DOM：定义一套操作页面元素的API，通过使用这些api来操作页面元素。 挑选一把称手的工具 txt,Nodpad++, Editplus Dreamweaver Hbuilder，WebStorm,MyEclipse, Visual Studio Sublime，bracket,Atom,vscode Vim gvim …… script标签 书写Javascript代码有三种方式，第一种是直接在script标签中书写，第二种是将代码写在js文件中，通过script进行引入。第三种为内嵌入html结构中书写js，但不利于后期代码开发和维护，不推荐； 直接在script中书写javascript代码： 123&lt;script&gt; alert("今天天气真好呀");&lt;/script&gt; 通过script标签引入一个JS文件，需要指定src属性 1&lt;script src="test.js"&gt;&lt;/script&gt; 通过在html标签中内嵌入脚本执行1&lt;div onclick="alert('今天天气不错！')"&gt;&lt;/div&gt; tips：如果script标签指定了src属性，说明是想要引入一个js文件，这个时候不能继续在script标签中写JS代码，即便写了，也不会执行。 script标签的书写位置，原则上来说，可以在页面中的任意位置书写script标签。 写在head标签中，style标签之后。 写在&lt;//body&gt;标签的前面。 写在的后面，即页面的最后面。 script的一些属性 language已废弃 src 表示要引入的外部文件 type 表示脚本语言的类型 async(了解) async=”async” 值可以省略，立即异步下载外部JS下载完毕立即执行 defer(了解) defer=”defer” 值可以省略，脚本延迟到文档完全被解析和显示后再执行 输入输出语句 在实际开发，常用1和3，并且1在控制台输出不影响页面正常显示，不会阻塞代码运行，灵活操作，在实际开发中用于代码调试较多。 console.log 控制台输出日志 document.write 往页面中写入内容 alert 弹框警告[^注释] confirm 确认框[^注释] prompt 输入框[^注释] [^注释]: window 是全局对象 是浏览器中的顶级对象 window.alert()中的window 可以省略不写 注释 不被程序执行的代码。用于程序员标记代码，在后期的修改，以及他人的学习时有所帮助，在JS中，分为单行注释和多行注释 1234//这是单行注释，只能注释一行/* 这是多行注释，不能嵌套*/ 注释的作用： 1. 模块划分，方便代码查找和维护 2. 用于解释复杂代码的逻辑，方便维护和后期开发。 要求：写代码的时候必须要写注释 不加注释是不道德的 【永无bug.js】 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150//// _ooOoo_// o8888888o// 88" . "88// (| -_- |)// O\ = /O// ____/`---'\____// .' \\| |// `.// / \\||| : |||// \// / _||||| -:- |||||- \// | | \\\ - /// | |// | \_| ''\---/'' | |// \ .-\__ `-` ___/-. /// ___`. .' /--.--\ `. . __// ."" '&lt; `.___\_&lt;|&gt;_/___.' &gt;'"".// | | : `- \`.;`\ _ /`;.`/ - ` : | |// \ \ `-. \_ __\ /__ _/ .-` / /// ======`-.____`-.___\_____/___.-`____.-'======// `=---='// ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^// 佛祖保佑 永无BUG// ┏┛┻━━━━━┛┻┓// ┃ ┃// ┃ ┃// ┃ ┳┛ ┗┳ ┃// ┃ ┃// ┃ ┻ ┃// ┃ ┃// ┗━┓ ┏━━━┛// ┃ ┃ 神兽保佑// ┃ ┃ 代码无BUG！// ┃ ┗━━━━━━━━━┓// ┃ ┣┓// ┃ ┏┛// ┗━┓ ┓ ┏━━━┳ ┓ ┏━┛// ┃ ┫ ┫ ┃ ┫ ┫// ┗━┻━┛ ┗━┻━┛// ━━━━━━感觉萌萌哒━━━━━━/*code is far away from bug with the animal protecting * ┏┓ ┏┓ *┏┛┻━━━┛┻┓ *┃ ┃ *┃ ━ ┃ *┃ ┳┛ ┗┳ ┃ *┃ ┃ *┃ ┻ ┃ *┃ ┃ *┗━┓ ┏━┛ * ┃ ┃神兽保佑 * ┃ ┃代码无BUG！ * ┃ ┗━━━┓ * ┃ ┣┓ * ┃ ┏┛ * ┗┓┓┏━┳┓┏┛ * ┃┫┫ ┃┫┫ * ┗┻┛ ┗┻┛ * */ /****----------Dragon be here!----------/ ┏┓ ┏┓ ┏┛┻━━━┛┻┓ ┃ ┃ ┃ ━ ┃ ┃ ┳┛ ┗┳ ┃ ┃ ┃ ┃ ┻ ┃ ┃ ┃ ┗━┓ ┏━┛ ┃ ┃ ┃ ┃ ┃ ┗━━━┓ ┃ ┣┓ ┃ ┏┛ ┗┓┓┏━┳┓┏┛ ┃┫┫ ┃┫┫ ┗┻┛ ┗┻┛━━━━━━神兽出没━━━━━━ *//** ┏┓ ┏┓ ┏┛┻━━━┛┻┓ ┃ ┃ ┃ ━ ┃ ┃ ＞ ＜ ┃ ┃ ┃ ┃... ⌒ ... ┃ ┃ ┃ ┗━┓ ┏━┛ ┃ ┃ Code is far away from bug with the animal protecting ┃ ┃ 神兽保佑,代码无bug ┃ ┃ ┃ ┃ ┃ ┃ ┃ ┃ ┃ ┗━━━┓ ┃ ┣┓ ┃ ┏┛ ┗┓┓┏━┳┓┏┛ ┃┫┫ ┃┫┫ ┗┻┛ ┗┻┛ */ /*** ┏┓ ┏┓+ +* ┏┛┻━━━┛┻┓ + +* ┃ ┃ * ┃ ━ ┃ ++ + + +* ████━████ ┃+* ┃ ┃ +* ┃ ┻ ┃* ┃ ┃ + +* ┗━┓ ┏━┛* ┃ ┃ * ┃ ┃ + + + +* ┃ ┃ Code is far away from bug with the animal protecting * ┃ ┃ + 神兽保佑,代码无bug * ┃ ┃* ┃ ┃ + * ┃ ┗━━━┓ + +* ┃ ┣┓* ┃ ┏┛* ┗┓┓┏━┳┓┏┛ + + + +* ┃┫┫ ┃┫┫* ┗┻┛ ┗┻┛+ + + +*///// █████▒█ ██ ▄████▄ ██ ▄█▀ ██████╗ ██╗ ██╗ ██████╗// ▓██ ▒ ██ ▓██▒▒██▀ ▀█ ██▄█▒ ██╔══██╗██║ ██║██╔════╝// ▒████ ░▓██ ▒██░▒▓█ ▄ ▓███▄░ ██████╔╝██║ ██║██║ ███╗// ░▓█▒ ░▓▓█ ░██░▒▓▓▄ ▄██▒▓██ █▄ ██╔══██╗██║ ██║██║ ██║// ░▒█░ ▒▒█████▓ ▒ ▓███▀ ░▒██▒ █▄ ██████╔╝╚██████╔╝╚██████╔╝// ▒ ░ ░▒▓▒ ▒ ▒ ░ ░▒ ▒ ░▒ ▒▒ ▓▒ ╚═════╝ ╚═════╝ ╚═════╝// ░ ░░▒░ ░ ░ ░ ▒ ░ ░▒ ▒░// ░ ░ ░░░ ░ ░ ░ ░ ░░ ░// ░ ░ ░ ░ ░// 变量 什么是变量变量是计算机内存中存储数据的标识符，根据变量名称可以获取到内存中存储的数据 为什么要使用变量使用变量可以方便的获取或者修改内存中的数据 如何使用变量 var声明变量 1var age; //声明未赋值 其值为未定义undefined 变量的赋值 12var age;age = 18; 同时声明多个变量 123var age, name, sex;age = 10;name = 'zs'; 同时声明多个变量并赋值 1var age = 10, name = 'zs'; 变量在内存中的存储后续通过交换值变量来演示 变量的命名规则与规范1234567命名规则（必须遵守）：1.由字母、数字、下划线、$符号组成，开头不能是数字。2.不能是关键字和保留字3.区分大小写命名规范（建议遵守）：1. 命名要有意义2. 遵守驼峰命名法。首字母小写，后面单词的首字母需要大写。 1var userName; var borderTopColor; 变量练习121. 交换两个变量的值（掌握）2. 不使用临时变量，交换两个数值变量的值（了解） 掌握： 扩展： tips:javascript是一种弱类型语言，不管声明什么类型的变量，都是用var，并且变量的类型是可以变化的。 12var age = 90;age = "张三"; 数据类型学习目标： 掌握四种常用的数据类型 JavaScript中的数据类型简单(基本、值)数据类型 Number（数字类型）、String（字符串）、Boolean（布尔类型） Undefined、Null（特殊类型） 复杂(引用)数据类型（暂时了解） object 如何查看数据类型使用typeof关键字查看数据类型 12typeof name;typeof(name); Number类型进制123451. 十进制，我们平时使用的就是十进制，进行运算时，八进制和十六进制的值最终都会转换成十进制。2. 八进制，0开头的数值，数值序列：0-73. 十六进制，0x开头的数值，数值序列：0-9A-F进制了解即可，基本都是使用十进制，稍微了解一下进制之间的转换。 浮点数科学计数法： 123var num = 5e+3;var num1 = 5e-2;//如何表示0.003和20000？ 浮点数的精度问题： 120.1 + 0.2 = ?0.07 * 100 = ? 浮点数在运算的时候会出现精度丢失的问题，因此在做比较运算的时候，尽量不要用小数进行比较。 数值范围 javascript不能表示世界上所有的数，因此在javascript中，数值大小是有一定限制的。 1234Number.MIN_VALUE :5e-324Number.MAX_VALUE :1.7976931348623157e+308Infinity :正无穷-Infinity ：负无穷 数值判断1231. NaN:表示一个非数值，当无法运算或者运算错误的时候，会得到一个NaN，NaN是number类型，表示一个非数值。2. NaN不等于NaN3. isNaN用来判断是否是一个数字，当返回true的时候，表示不是一个数字，返回false表示是一个数字。 【案例：判断一个数据是不是数字】1234var data = "abc";if(typeof data == "number"&amp;&amp;!isNaN(data))&#123; console.log("是数字"); &#125; String类型字面量字符串的字面量：“abc” 、 ‘abc’ 字符串可以是双引号，也可以是单引号引起来。 123思考：如何打印以下字符串。我是一个"正直"的人 我很喜欢"传'智'播客" 字符串长度length属性用来获取字符串的长度 12var str = "abckjdlkfjd";str.length;//字符串的长度 ###字符串的不可变性 字符串拼接拼接字符串使用+号 12345//思考：console.log(11 + 11);console.log("hello" + " world");console.log("100" + "100");console.log("11" + 11); 两边只要有一个是字符串，那么+就是字符串拼接功能 两边如果都是数字，那么就是算术功能。 boolean类型boolean类型只有两个字面量，true和false，区分大小写。 所有类型的值都可以转化成true或者false 1NaN、""、undefined、null、false、0 这6个值可以转换成false，其余的都是true。 undefined类型与null类型123456undefined表示一个声明了没有赋值的变量null表示一个空的对象。undefined派生自null。undefined == null ：trueundefined === null ：false 类型转换如何使用谷歌浏览器，快速的查看数据类型？ 字符串的颜色是黑色的，数值类型是蓝色的，布尔类型也是蓝色的，undefined和null是灰色的，这个在调试过程中时非常有用的。 转换成字符串类型 toString() String() /+ “” 转换成数值类型 Number() parseInt parseFloat +num, -0等运算 转换成布尔类型学习目标： 1 转换成字符串类型 2 转换成数值类型 3 转换成布尔类型 Boolean !!]]></content>
  </entry>
  <entry>
    <title><![CDATA[Canvas实现的刮刮乐效果]]></title>
    <url>%2F2017%2F03%2F10%2FCanvas%E5%AE%9E%E7%8E%B0%E5%88%AE%E5%88%AE%E4%B9%90%E6%95%88%E6%9E%9C%2F</url>
    <content type="text"><![CDATA[使用canvas实现的简单刮刮乐效果 index.html 由于效果很简单所以放到一个html中了。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;刮刮乐&lt;/title&gt; &lt;style&gt; body &#123; margin: 0; padding: 0; &#125; canvas &#123; border: 1px solid #ccc; background: #ccc; margin: 100px auto; display: block; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;canvas width="400" height="300"&gt;&lt;/canvas&gt; &lt;script&gt; var ctx = document.querySelector('canvas').getContext('2d') var img = new Image() img.onload = function () &#123; // 设置填充方案 var pat = ctx.createPattern(img, 'no-repeat') ctx.strokeStyle = pat //设置线的样式 （包括线宽，线帽，拐点） ctx.lineWidth = 25 ctx.lineCap = 'round' ctx.lineJoin = 'round' //设置一个阈值 var isDown = false ctx.canvas.addEventListener('mousedown', function (e) &#123; ctx.moveTo(e.clientX - ctx.canvas.offsetLeft, e.clientY -ctx.canvas.offsetTop) isDown = true &#125;) ctx.canvas.addEventListener('mousemove', function (e) &#123; if (isDown) &#123; ctx.lineTo(e.clientX - ctx.canvas.offsetLeft, e.clientY -ctx.canvas.offsetTop) ctx.stroke() &#125; &#125;) ctx.canvas.addEventListener('mouseup', function () &#123; isDown = false &#125;) &#125; /* 设置图片资源路径 */ img.src = '../images/xiexie.png' &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>canvas</category>
      </categories>
      <tags>
        <tag>canvas</tag>
        <tag>刮刮乐</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Canvas相关知识]]></title>
    <url>%2F2017%2F03%2F10%2Fmycanvas%2F</url>
    <content type="text"><![CDATA[canvas 最早由Apple引入WebKit,用于Mac OS X 的 Dashboard,后来又在Safari和Google Chrome被实现。 基于 Gecko 1.8的浏览器,比如 Firefox 1.5, 同样支持这个元素。&lt;canvas&gt; 元素是WhatWG Web applications 1.0规范的一部分,也包含于HTML 5中。 什么是Canvas？ canvas 是一个 HTML5元素，中文翻译是画布，但是本事没有绘画的功能，需要通过javascript在上面绘制图像。 canvas是一个矩形区域，（算是内联可置换元素在chrome中display默认值为 inline），可以控制其中的每一像素默认大小是 300 * 150 ，浏览器在解析的时候会按图片进行处理 canvas 拥有多种绘制路径、矩形、圆形、字符以及添加图像的方法。 创建Canvas元素向 HTML5 页面添加 canvas 元素。规定元素的 id、宽度和高度：（在style标签中为其设置宽高属性也是起作用的但是并不推荐这么做） 1&lt;canvas id="myCanvas" width="600" height="400"&gt;&lt;/canvas&gt; Canvas坐标系 通过JavaScript来绘制 12345678&lt;!- 为了效果明显，加了一点样式 -&gt;&lt;style&gt; canvas&#123; border: 1px solid #ccc; margin: 0 auto; display: block; &#125;&lt;/style&gt; 12345678910/*获取元素*/var myCanvas = document.querySelector('#myCanvas')/*获取绘图工具（也可以叫做绘制环境）*/var context = myCanvas.getContext('2d')/*设置绘图的起始位置*/context.moveTo(100,100)/*绘制路径*/context.lineTo(200,200)/*描边*/context.stroke() Canvas的基本使用图形绘制需要理解些概念： 路径的概念 路径的绘制 描边 stroke() 填充 fill() 闭合路径 手动闭合 程序闭合 closePath() 填充规则(非零环绕) 开启新的路径 beginPath() 设置样式 画笔的状态 lineWidth 线宽，默认1px lineCap 线末端类型：(butt默认)、round、square lineJoin 相交线的拐点 miter(默认)、round、bevel strokeStyle 线的颜色 fillStyle 填充颜色 setLineDash() 设置虚线 getLineDash() 获取虚线宽度集合 lineDashOffset 设置虚线偏移量（负值向右偏移） 此处的坑 123456/*canvas所绘制的线条本质就是一定数量的默认大小为1px颜色为黑色的像素点的结合，以坐标的中心绘制,但浏览器无发显示0.5px，chrome处理方式是把把线宽扩大到2px但是，毕竟这并不是真正设置2px的线宽，所以做了将颜色变浅以示区分。解决方案：1. 当设置线宽为单数的时候，手动将其y轴方向进行0.5px的增减，换句话说就是把这条线放到浏览器能正常显示的像素格内，避免浏览器进行线条虚化操作。2. 将线宽设置为偶数，但要注意canvas线条位置的渲染方式，计算好真正想让线条出现的位置*/ 实例练习 绘制平行线不同颜色 1234567891011121314151617181920212223/*1.获取canvas元素*/ var canvas = document.querySelector('canvas'); /*2.获取绘制环境 （获取绘制工具）*/ /*content内容 context 上下文 */ var ctx = canvas.getContext('2d'); /*3.设置起始绘图的位置*/ ctx.moveTo(100,100); /*6.设置宽度*/ ctx.lineWidth = 10; /*4.绘制路径 */ ctx.lineTo(200,100); /*7. 设置描边的颜色*/ ctx.strokeStyle = 'red'; /*5.描边*/ ctx.stroke(); /*绿色*/ /*再次绘制的时候 会使用之前设置的样式 设置的样式最后的会生效*/ /*开启新路径*/ ctx.beginPath(); ctx.moveTo(100,200); ctx.lineTo(200,200); ctx.strokeStyle = 'green'; ctx.stroke(); 绘制一个三角形 12345678910111213141516var canvas = document.querySelector('canvas'); /*获取绘图工具*/ var ctx = canvas.getContext('2d'); /*3d目前还不支持*//*webgl*/ /*移动画笔*/ ctx.moveTo(100,100); ctx.lineTo(200,100); ctx.lineTo(200,200); ctx.lineWidth = 10; /*自动闭合*/ ctx.closePath(); // ctx.stroke(); ctx.strokeStyle = 'red'; ctx.stroke(); /*填充*/ ctx.fillStyle = 'orange'; ctx.fill(); 镂空的正方形 12345678910111213141516var canvas = document.querySelector('canvas'); /*获取绘图工具*/ var ctx = canvas.getContext('2d'); /*3d目前还不支持*//*webgl*/ /*移动画笔*/ ctx.moveTo(100,100); ctx.lineTo(200,100); ctx.lineTo(200,200); ctx.lineWidth = 10; /*自动闭合*/ ctx.closePath(); // ctx.stroke(); ctx.strokeStyle = 'red'; ctx.stroke(); /*填充*/ ctx.fillStyle = 'skyblue'; ctx.fill(); 线的两端样式 123456789101112131415161718192021222324var canvas = document.querySelector('canvas'); /*获取绘图工具*/ var ctx = canvas.getContext('2d'); /*3d目前还不支持*//*webgl*/ ctx.lineWidth = 10; ctx.moveTo(100,100); ctx.lineTo(200,100); ctx.strokeStyle = 'red'; ctx.lineCap = 'butt'; ctx.stroke(); ctx.beginPath(); ctx.moveTo(100,200); ctx.lineTo(200,200); ctx.strokeStyle = 'green'; ctx.lineCap = 'round'; ctx.stroke(); ctx.beginPath(); ctx.moveTo(100,300); ctx.lineTo(200,300); ctx.strokeStyle = 'skyblue'; ctx.lineCap = 'square'; ctx.stroke(); 线拐点的样式 123456789101112131415161718192021222324252627var canvas = document.querySelector('canvas'); /*获取绘图工具*/ var ctx = canvas.getContext('2d'); /*3d目前还不支持*//*webgl*/ ctx.lineWidth = 10; ctx.moveTo(100,100); ctx.lineTo(150,150); ctx.lineTo(200,100); ctx.strokeStyle = 'red'; ctx.lineJoin = 'miter'; ctx.stroke(); ctx.beginPath(); ctx.moveTo(100,200); ctx.lineTo(150,250); ctx.lineTo(200,200); ctx.strokeStyle = 'green'; ctx.lineJoin = 'round'; ctx.stroke(); ctx.beginPath(); ctx.moveTo(100,300); ctx.lineTo(150,350); ctx.lineTo(200,300); ctx.strokeStyle = 'pink'; ctx.lineJoin = 'bevel'; ctx.stroke(); 绘制渐变的线 1234567891011121314151617var canvas = document.querySelector('canvas'); /*获取绘图工具*/ var ctx = canvas.getContext('2d'); /*3d目前还不支持*//*webgl*/ /*1.从左到右*/ /*2.起始颜色 白色*/ /*3.结束颜色 红色*/ ctx.lineWidth = 10; for (var i = 0; i &lt; 255; i++) &#123; ctx.beginPath(); ctx.moveTo(99+i,100); ctx.lineTo(100+i,100); var g = 255 - i; var b = 255 - i; ctx.strokeStyle = 'rgb(255,'+g+','+b+')'; ctx.stroke(); &#125; 绘制虚线 12345678910111213141516171819202122232425262728293031323334353637383940var canvas = document.querySelector('canvas'); /*获取绘图工具*/ var ctx = canvas.getContext('2d'); /*3d目前还不支持*//*webgl*/ ctx.moveTo(100,100) ctx.lineTo(500,100) ctx.setLineDash([5]); console.log(ctx.getLineDash()); ctx.stroke(); ctx.beginPath(); ctx.moveTo(100,200); ctx.lineTo(500,200); /*绘制虚线的方法*/ /*传数组 设置虚线长度的*/ ctx.setLineDash([5,10]); /*如果是偶数个数设置 */ /*如果是奇数数个数设置 */ /*获取的不重复的一段*/ console.log(ctx.getLineDash()); ctx.stroke(); ctx.beginPath(); ctx.moveTo(100,300) ctx.lineTo(500,300) ctx.setLineDash([5,10,15]); console.log(ctx.getLineDash()); ctx.stroke();var canvas = document.querySelector('canvas'); /*获取绘图工具*/ var ctx = canvas.getContext('2d'); /*3d目前还不支持*//*webgl*/ ctx.moveTo(100,100); ctx.lineTo(500,100); /*绘制虚线的方法*/ /*传数组 设置虚线长度的*/ ctx.setLineDash([5,10,15]); /*如果是偶数个数设置 */ /*如果是奇数数个数设置 */ /*获取的不重复的一段*/ console.log(ctx.getLineDash()); ctx.stroke(); 绘制坐标系方法一 12345678910111213141516171819202122232425262728293031var canvas = document.querySelector('canvas'); /*获取绘图工具*/ var ctx = canvas.getContext('2d'); /*3d目前还不支持*//*webgl*/ /*1.确定间隔 20 */ var space = 20; /*2.计算原点*/ var width = ctx.canvas.width; var height = ctx.canvas.height; var x0 = 0 + space; var y0 = height - space; /*假设 箭头大小 8px*/ var arrowSize = 10; /*绘制x轴*/ ctx.moveTo(x0,y0); ctx.lineTo(width-space,y0); ctx.lineTo(width-space-arrowSize,y0+arrowSize/2); ctx.lineTo(width-space-arrowSize,y0-arrowSize/2); ctx.lineTo(width-space,y0); ctx.stroke(); ctx.fill(); /*绘制y轴*/ ctx.moveTo(x0,y0); ctx.lineTo(space,space); ctx.lineTo(space+arrowSize/2,space+arrowSize); ctx.lineTo(space-arrowSize/2,space+arrowSize); ctx.lineTo(space,space); ctx.stroke(); ctx.fill(); 方法二:面向对象方式 123456789101112131415161718192021222324252627282930313233343536var DrawAxis = function () &#123; /*绘图工具*/ this.ctx = document.querySelector('canvas').getContext('2d'); /*间距*/ this.space = 20; /*画布的尺寸*/ this.width = this.ctx.canvas.width; this.height = this.ctx.canvas.height; /*原点*/ this.x0 = this.space; this.y0 = this.height - this.space; /*箭头尺寸*/ this.arrowSize = 10; &#125; /*绘制方法*/ DrawAxis.prototype.draw = function () &#123; /*x轴*/ this.ctx.moveTo(this.x0,this.y0); this.ctx.lineTo(this.width-this.space,this.y0); this.ctx.lineTo(this.width-this.space-this.arrowSize,this.y0+this.arrowSize/2); this.ctx.lineTo(this.width-this.space-this.arrowSize,this.y0-this.arrowSize/2); this.ctx.lineTo(this.width-this.space,this.y0); this.ctx.stroke(); this.ctx.fill(); /*y轴*/ this.ctx.moveTo(this.x0,this.y0); this.ctx.lineTo(this.space,this.space); this.ctx.lineTo(this.space+this.arrowSize/2,this.space+this.arrowSize); this.ctx.lineTo(this.space-this.arrowSize/2,this.space+this.arrowSize); this.ctx.lineTo(this.space,this.space); this.ctx.stroke(); this.ctx.fill(); &#125; var drawAxis = new DrawAxis(); drawAxis.draw(); ​ 绘制坐标点 方法一 123456789101112131415161718192021var canvas = document.querySelector('canvas'); /*获取绘图工具*/ var ctx = canvas.getContext('2d'); /*3d目前还不支持*//*webgl*/ /*点坐标*/ var dotted = &#123; x: 200, y: 100 &#125; /*点大小*/ var edge = 8; /*画笔的起始位置*/ ctx.moveTo(dotted.x - edge / 2, dotted.y - edge / 2); ctx.lineTo(dotted.x + edge / 2, dotted.y - edge / 2); ctx.lineTo(dotted.x + edge / 2, dotted.y + edge / 2); ctx.lineTo(dotted.x - edge / 2, dotted.y + edge / 2); ctx.closePath(); ctx.fill(); 方法二：面向对象 12345678910111213141516171819var DrawDotted = function () &#123; this.ctx = document.querySelector('canvas').getContext('2d'); this.edge = 10; &#125; /*dotted 对象 x y 轴坐标*/ DrawDotted.prototype.draw = function (dotted) &#123; this.ctx.beginPath(); this.ctx.moveTo(dotted.x-this.edge/2,dotted.y-this.edge/2); this.ctx.lineTo(dotted.x+this.edge/2,dotted.y-this.edge/2); this.ctx.lineTo(dotted.x+this.edge/2,dotted.y+this.edge/2); this.ctx.lineTo(dotted.x-this.edge/2,dotted.y+this.edge/2); this.ctx.closePath(); this.ctx.fill(); &#125; var drawDotted = new DrawDotted(); drawDotted.draw(&#123;x:100,y:100&#125;); drawDotted.draw(&#123;x:100,y:200&#125;); drawDotted.draw(&#123;x:200,y:200&#125;); ​ 绘制折线图 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586/*假设一组 基于坐标轴的*/ var data = [ &#123;x: 100, y: 80&#125;, &#123;x: 200, y: 120&#125;, &#123;x: 300, y: 250&#125;, &#123;x: 400, y: 340&#125;, &#123;x: 500, y: 230&#125; ]; var LineChart = function () &#123; /*绘制工具*/ this.ctx = document.querySelector('canvas').getContext('2d'); /*坐标原点*/ this.space = 20; this.width = this.ctx.canvas.width; this.height = this.ctx.canvas.height; this.x0 = this.space; this.y0 = this.height - this.space; /*箭头大小*/ this.arrow = 10; /*点相关 点大小*/ this.edge = 10; &#125; /*初始化方法*/ LineChart.prototype.init = function (data) &#123; this.drawAxis(); this.drawDotted(data); &#125; /*绘制坐标轴*/ LineChart.prototype.drawAxis = function () &#123; /*X轴*/ this.ctx.moveTo(this.x0, this.y0); this.ctx.lineTo(this.width - this.space, this.y0); this.ctx.lineTo(this.width - this.space - this.arrow, this.y0 + this.arrow/2); this.ctx.lineTo(this.width - this.space - this.arrow, this.y0 - this.arrow/2); this.ctx.lineTo(this.width - this.space, this.y0); this.ctx.stroke(); this.ctx.fill(); /*Y轴*/ this.ctx.moveTo(this.x0, this.y0); this.ctx.lineTo(this.space, this.space); this.ctx.lineTo(this.space + this.arrow/2, this.space + this.arrow); this.ctx.lineTo(this.space - this.arrow/2, this.space + this.arrow); this.ctx.lineTo(this.space, this.space); this.ctx.stroke(); this.ctx.fill(); &#125; /*转换点坐标*/ LineChart.prototype.formatDot = function (data) &#123; var that = this; var canvasData = []; data.forEach(function(item,i)&#123; var cx = item.x + that.x0; var cy = that.y0 - item.y; canvasData.push(&#123;x:cx,y:cy&#125;); &#125;); return canvasData; &#125; /*绘制多个点*/ LineChart.prototype.drawDotted = function (data) &#123; var that = this; /*转换*/ var canvasData = this.formatDot(data); console.log(canvasData); canvasData.forEach(function (item, i) &#123; that.ctx.beginPath(); that.ctx.moveTo(item.x - that.edge /2 , item.y - that.edge/2); that.ctx.lineTo(item.x + that.edge /2 , item.y - that.edge/2); that.ctx.lineTo(item.x + that.edge /2 , item.y + that.edge/2); that.ctx.lineTo(item.x - that.edge /2 , item.y + that.edge/2); that.ctx.closePath(); that.ctx.fill(); that.ctx.beginPath(); if(i == 0)&#123; that.ctx.moveTo(that.x0,that.y0); &#125;else&#123; that.ctx.moveTo(canvasData[i-1].x,canvasData[i-1].y) &#125; that.ctx.lineTo(item.x,item.y); that.ctx.stroke(); &#125;); &#125; new LineChart().init(data); ​ 参考文档 w3school Canvas_API Canvas图形绘制矩形绘制 rect(x,y,w,h) 没有独立路径 strokeRect(x,y,w,h) 有独立路径，不影响别的绘制 fillRect(x,y,w,h) 有独立路径，不影响别的绘制 clearRect(x,y,w,h) 擦除矩形区域 圆弧绘制 弧度概念 arc() x 圆心横坐标 y 圆心纵坐标 r 半径 startAngle 开始角度 endAngle 结束角度 anticlockwise 是否逆时针方向绘制（默认false表示顺时针；true表示逆时针） 绘制文本 ctx.font = ‘微软雅黑’ 设置字体 strokeText() fillText(text,x,y,maxWidth) text 要绘制的文本 x,y 文本绘制的坐标（文本左下角） maxWidth 设置文本最大宽度，可选参数 ctx.textAlign文本水平对齐方式，相对绘制坐标来说的 left center right start 默认 end direction属性css(rtl ltr) start和end于此相关 如果是ltr,start和left表现一致 如果是rtl,start和right表现一致 ctx.textBaseline 设置基线（垂直对齐方式 ） top 文本的基线处于文本的正上方，并且有一段距离 middle 文本的基线处于文本的正中间 bottom 文本的基线处于文本的证下方，并且有一段距离 hanging 文本的基线处于文本的正上方，并且和文本粘合 alphabetic 默认值，基线处于文本的下方，并且穿过文字 ideographic 和bottom相似，但是不一样 measureText() 获取文本宽度obj.width 实例练习 绘制扇形 绘制圆角矩形 绘制圆 绘制饼图 做动画绘制图片 drawImage() 三个参数drawImage(img,x,y) img 图片对象、canvas对象、video对象 x,y 图片绘制的左上角 五个参数drawImage(img,x,y,w,h) img 图片对象、canvas对象、video对象 x,y 图片绘制的左上角 w,h 图片绘制尺寸设置(图片缩放，不是截取) 九个参数drawImage(img,x,y,w,h,x1,y1,w1,h1) img 图片对象、canvas对象、video对象 x,y,w,h 图片中的一个矩形区域 x1,y1,w1,h1 画布中的一个矩形区域 序列帧动画 绘制精灵图 动起来 控制边界 键盘控制 坐标变换 平移 移动画布的原点 translate(x,y) 参数表示移动目标点的坐标 缩放 scale(x,y) 参数表示宽高的缩放比例 旋转 rotate(angle) 参数表示旋转角度]]></content>
      <categories>
        <category>canvas</category>
      </categories>
      <tags>
        <tag>canvas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript Standard Style(JavaScript 标准编码风格)]]></title>
    <url>%2F2017%2F01%2F20%2FJavaScript%2BStandard%2BStyle(JavaScript%2B%E6%A0%87%E5%87%86%E7%BC%96%E7%A0%81%E9%A3%8E%E6%A0%BC)%2F</url>
    <content type="text"><![CDATA[让我们看一看 @feross 的 JavaScript 标准风格 ，这是一个流行的 JavaScript 风格指南。它可以帮助你减少团队之间的摩擦，增加程序员的幸福感。 这是 一组规则 ，可以使 JavaScript 代码更加一致 ，并且可以防止类似于 tabs缩进 和 空格缩进优缺点这一类无聊的话题讨论。你可以采用多种风格之一，并且与其他 （如 JSLint ， JSHint 和 ESLint ）是同一种类型的 JavaScript 检测器。 如果你还不知道什么是linter (检查工具)，或者为什么需要，请查看我们对 JavaScript 检查(Linting)工具的比较。 风格的重要性如果你已经从事编码工作有一段时间了的话，那你肯定会有一种自己喜欢的风格。当你成百上千次以特定的模式编写代码时，你会发现你的编码方式是令人愉悦的。突然间来了个人，开始把挂在行尾的大括号单起一行。你可能会发牢骚。深呼吸冷静思考一下，你放置括号的位置 或 关键字后加空格 不会让你的程序更加正确，这只是个人喜好。 每种编程语言都有一种主流编码风格，比如像 Python，官方提供的 风格指南 被认为是编写程序的正确方式。那么你是否还会继续讨厌缩进用4个空格的人呢？（注：Python 官方提供的风格指南，建议使用4个空格缩进）。 用主流风格进行编码将有助于你的程序更能适应语言的生态环境。您还会发现，如果您熟悉该语言的主流编码风格，并且一开始就同意这种编码风格，那么您可以更容易地为开源项目贡献代码，同样也更容易让其他人来为你的开源项目贡献代码。 JavaScript 没有官方的编码风格指南，或许 Douglas Crockford 的 The Good Parts 是一个实际上的标准。他的书（注：《JavaScript 语言精粹》）提供了一种编写可靠的方法来 JavaScript 程序，他强调了我们应该积极避免的某些特性。他发布了 JSLint 来支持这些观点，而其他的检查工具也紧随其后。大多数的检查工具是高度可配置的，让你选择最适合你自己的风格，并将其强加于别人或团队！JavaScript Standard Style(注：这个项目名，所以没翻译，意思为 JavaScript 标准编码风格) 则不同。你最喜欢的编码风格无关紧要，重要的是，任何选择都可以让每个人理解和合作。 采用 standard 编码风格意味着 代码清晰性和社区约定的重要性要高于个人的编码风格。这不一定适用于所有项目和开发文化，但是开放项目源码对于新手来说可能非常不适应。建立清晰的、自动的编码风格，满足贡献者期望可以使项目发展更健康。 如果你正在为自己编写一个程序，没有其他人需要为你做贡献，那就使用那些让你最快乐的工具和编码风格。当你在一个团队中工作时，你应该尽量减少摩擦，保持专业，不要因为小事而浪费太多的时间。 在介绍自己的风格之前，花点时间学习现有代码库的风格。 JavaScript Standard Style （JavaScript 标准编码风格） 使用两个空格 – 进行缩进 字符串使用单引号 – 需要转义的地方除外 不再有冗余的变量 – 这是导致 大量 bug 的源头! 无分号 – 这里有3篇文章说明不用分号的好处：文章1文章2文章3 行首不要以 (, [, or ` 开头 这是省略分号时唯一会造成问题的地方 – 工具里已加了自动检测！ [详情][4] 关键字后加空格if (condition) { ... } 函数名后加空格function name (arg) { ... } 坚持使用全等 === 摒弃 == 一但在需要检查 null || undefined 时可以使用 obj == null。 一定要处理 Node.js 中错误回调传递进来的 err 参数。 使用浏览器全局变量时加上 window 前缀 – document 和 navigator 除外 避免无意中使用到了这些命名看上去很普通的全局变量， open, length,event 还有 name。 请参阅 完整的规则列表 最有争议的规则无疑是不用分号。多年来人们一直认为，始终使用分号是避免错误的最佳实践，Crockford 做了很多工作来促进这一点，使用封号有很深的根源，在 C 语言里，分号是严格要求的，否则程序不会运行。 JavaScript Standard Style(JavaScript 标准编码风格) 改变了我的想法，不用分号的 JavaScript 非常好。 分号自动插入是 JavaScript 的一个特性，它可以减少噪点、简化程序，我从来没有遇到过由于缺少分号而导致的bug，我也不相信你会遇到。查看 JavaScript 中有必需使用分号的吗? 以了解更多。 并不是所有人都同意，forks semistandard 和 happiness 有点唱反调，强调使用分号。我发现这些 forks 有点伤感，因为它们错过忽略了整个标准的要点。 如果我不同意某条规则，可以改吗？ 不行。制定这套 standard 规范的目的就是让大家都不必再花时间浪费在无谓的代码风格之争上面了。关于缩进该用制表符还是空格这个问题已经争论了很久了，永远也没有答案。争论这个都可以把需求提前写完了。遵循 standard 规范，你就不用再犹豫了，毕竟不管怎样争论总归会选择一种风格的。希望大家也能在个人语义和普适价值上做一个权衡。 就我个人而言，我已经开始喜欢不使用分号的编码风格了，也许是因为需要编写 Ruby、Python 和 CoffeeScript 的缘故，这些都不使用分号的语法。无论什么原因，当看不到分号的时候，我发现程序更清晰了。 良好的程序层次结构程序员应该重视： 正确性 可读性 幸福感 高效率 事实证明，采用 JavaScript Standard Style(JavaScript 标准编码风格)，对以上每一条都有好处。 正确性在所有程序中使用的任何东西，都必须做你想要的，并且没有错误。 编码风格并不会使程序更正确，但是在发布之前，检查工具可以帮你捕获一些错误。 可读性作为一个专业的开发人员，除了提供一份能正常运行的程序代码之外，代码的可读性是最重要的。阅读和尝试理解程序比编写代码要花费更多的精力和时间，因此请为未来的自己和维护代码的其他人进行可读性优化。 清晰可预测的风格使代码更容易阅读和理解。 程序员的幸福感我喜欢 JavaScript Standard Style(JavaScript 标准编码风格) 的原因之一是，它把重点放在人而不是机器上。程序员的幸福感在这个列表中排名第三的唯一原因是团队合作中更需要可读性，功能代码的正确性应该放在我们自己的幸福感之前，这是毋庸置疑的。 你想享受生活，不是吗？如果你很快就能完成工作，而且你的工作又有趣，那不就是我们想要的享受生活吗？这在一定程度上就是我们生活的目的。你的生活会更加美好。 – Yukihiro Matsumoto （注：松本行弘是一位日本计算机科学家和程序员。他是Ruby程序设计语言的主要设计者和实现者。） 人生苦短，不能因个人偏好的不同而引起意见分歧，设定一个标准并后续推进不是更好吗？如果一个标准的编码风格能够避免团队之间的分歧和摩擦，那么你就会更快乐。 高效率列在最后，但并非最不重要。 如果你必须在这些要点上进行权衡，那么你应该更加重视代码正确性、可读性，并且使程序员对快速编写代码感到愉悦。 计算机处理速度很快。如果程序高效，那就没事了。如果您发现性能不佳，请花时间寻找性能瓶颈并使代码更高效。 人类处理问题的速度相对来说很慢。让事情变得更有效率对我们来说更有价值。采用一种标准编码风格的清晰性使您的代码能够更快地理解并贡献代码。花在分歧上的时间也少了很多，这是最受欢迎的。 实施 JavaScript Standard Style(JavaScript 标准编码风格)你可以不用任何工具就可以采用这个标准，只要通读一下 规则 就可以，特别注意哪些和你以前习惯不同的规则。尝试一个星期，看看你是否喜欢。如果你不是特别反感，那就用它吧！ 还有一个 npm 包，用于检查你的JavaScript代码。 1npm install standard --global 通过这个检测器，运行 standard 将执行目录中的所有 JavaScript 文件。 此外，还有所有常见的 文本编辑器插件 ，这里是如何在 Atom 中安装检测器。 12apm install linterapm install linter-js-standard 就我个人而言，当你正在输入代码的时候，自动打印风格警告提示会让你分心。如果你有同样的感觉，在你完成工作后，再来检查会更好。JavaScript 标准编码风格 命令也有一个自动修复某些风格错误的 flag，这可能会节省一些时间。 1standard --fix 采用 JavaScript Standard Style(JavaScript 标准编码风格)你应该采用 JavaScript Standard Style(JavaScript 标准编码风格) 吗？那么这完全取决于你。 如果你没有合适的风格指南，那就准备好面对分歧和冲突吧。 如果你已经完善了一套理想的规则，并希望在整个代码库中执行它，那么 ESLint 可能就是你最好的选择。 如果你不想浪费时间在无聊的语法细节上，那就请用JavaScript Standard Style(JavaScript 标准编码风格) 吧，欢迎评论说出你的想法。 原文链接：https://www.sitepoint.com/why-use-javascript-style-guide/]]></content>
      <categories>
        <category>标准编码风格</category>
      </categories>
      <tags>
        <tag>标准编码风格</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[白话原型和原型链]]></title>
    <url>%2F2017%2F01%2F10%2F%E7%99%BD%E8%AF%9D%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE%2F</url>
    <content type="text"><![CDATA[关于原型和原型链的介绍，网上数不胜数，但能讲清楚这两个概念的很少，大多数都是介绍各种对象、属性之间如何指来指去，最后的结果就是箭头满天飞，大脑一团糟。本文将从这两个概念的命名入手，用通俗易懂的语言，帮助你理解这两个东西到底是何方神圣。 一. 背景知识JavaScript和Java、C++等传统面向对象的编程语言不同，它是没有类（class）的概念的（ES6 中的class也只不过是语法糖，并非真正意义上的类），而在JavaScript中，一切皆是对象（object）。在基于类的传统面向对象的编程语言中，对象由类实例化而来，实例化的过程中，类的属性和方法会拷贝到这个对象中；对象的继承实际上是类的继承，在定义子类继承于父类时，子类会将父类的属性和方法拷贝到自身当中。因此，这类语言中，对象创建和继承行为都是通过拷贝完成的。但在JavaScript中，对象的创建、对象的继承（更好的叫法是对象的代理，因为它并不是传统意义上的继承）是不存在拷贝行为的。现在让我们忘掉类、忘掉继承，这一切都不属于JavaScript。 二. 原型和原型链其实，原型这个名字本身就很容易产生误解，原型在百度词条中的释义是：指原来的类型或模型。按照这个定义解释的话，对象的原型是对象创建自身的模子，模子具备的特点对象都要具有，这俨然就是拷贝的概念。我们已经说过， JavaScript的对象创建不存在拷贝，对象的原型实际上也是一个对象，它和对象本身是完全独立的两个对象。既然如此，原型存在的意义又是什么呢？原型是为了共享多个对象之间的一些共有特性（属性或方法），这个功能也是任何一门面向对象的编程语言必须具备的。A、B两个对象的原型相同，那么它们必然有一些相同的特征。 JavaScript中的对象，都有一个内置属性[[Prototype]]，指向这个对象的原型对象。当查找一个属性或方法时，如果在当前对象中找不到定义，会继续在当前对象的原型对象中查找；如果原型对象中依然没有找到，会继续在原型对象的原型中查找（原型也是对象，也有它自己的原型）；如此继续，直到找到为止，或者查找到最顶层的原型对象中也没有找到，就结束查找，返回undefined。可以看出，这个查找过程是一个链式的查找，每个对象都有一个到它自身原型对象的链接，这些链接组件的整个链条就是原型链。拥有相同原型的多个对象，他们的共同特征正是通过这种查找模式体现出来的。 在上面的查找过程，我们提到了最顶层的原型对象，这个对象就是Object.prototype，这个对象中保存了最常用的方法，如toString、valueOf、hasOwnProperty等，因此我们才能在任何对象中使用这些方法。 1.字面量方式当通过字面量方式创建对象时，它的原型就是Object.prototype。虽然我们无法直接访问内置属性[[Prototype]]，但我们可以通过Object.getPrototypeOf()或对象的__proto__（不是标准属性，但几乎所有浏览器都实现了该属性）获取对象的原型。123var obj = &#123;&#125;;Object.getPrototypeOf(obj) === Object.prototype; // trueobj.__proto__ === Object.prototype; // true 2.函数的构造调用通过函数的构造调用（注意，我们不把它叫做构造函数，因为JavaScript中同样没有构造函数的概念，所有的函数都是平等的，只不过用来创建对象时，函数的调用方式不同而已）也是一种常用的创建对象的方式。基于同一个函数创建出来的对象，理应可以共享一些相同的属性或方法，但这些属性或方法如果放在Object.prototype里，那么所有的对象都可以使用它们了，作用域太大，显然不合适。于是，JavaScript在定义一个函数时，同时为这个函数定义了一个 默认的prototype属性，所有共享的属性或方法，都放到这个属性所指向的对象中。由此看出，通过一个函数的构造调用创建的对象，它的原型就是这个函数的prototype指向的对象。12345var f = function(name) &#123; this.name = name &#125;;f.prototype.getName = function() &#123; return this.name; &#125; //在prototype下存放所有对象的共享方法var obj = new f('JavaScript');obj.getName(); // JavaScriptobj.__proto__ === f.prototype; // true 3.Object.create（）第三种常用的创建对象的方式是使用Object.create()。这个方法会以你传入的对象作为创建出来的对象的原型。123var obj = &#123;&#125;;var obj2 = Object.create(obj);obj2.__proto__ === obj; // true 这种方式还可以模拟对象的“继承”行为。1234567891011121314151617181920212223242526272829function Foo(name) &#123; this.name = name;&#125;Foo.prototype.myName = function() &#123; return this.name;&#125;;function Bar(name,label) &#123; Foo.call( this, name ); // this.label = label;&#125;// temp对象的原型是Foo.prototypevar temp = Object.create( Foo.prototype ); // 通过new Bar() 创建的对象，其原型是temp, 而temp的原型是Foo.prototype，// 从而两个原型对象Bar.prototype和Foo.prototype 有了"继承"关系Bar.prototype = temp;Bar.prototype.myLabel = function() &#123; return this.label;&#125;;var a = new Bar( "a", "obj a" );a.myName(); // "a"a.myLabel(); // "obj a"a.__proto__.__proto__ === Foo.prototype; //true 三. __proto__和prototype这是容易混淆的两个属性。__proto__指向当前对象的原型，prototype是函数才具有的属性，默认情况下，new 一个函数创建出的对象，其原型都指向这个函数的prototype属性。 四. 三种特殊情况1.对于JavaScript中的内置对象，如String、Number、Array、Object、Function等，因为他们是native代码实现的，他们的原型打印出来都是ƒ () { [native code] }。 2.内置对象本质上也是函数，所以可以通过他们创建对象，创建出的对象的原型指向对应内置对象的prototype属性，最顶层的原型对象依然指向Object.prototype。1234567891011121314151617'abc'.__proto__ === String.prototype; // true new String('abc').__proto__ === String.prototype; //truenew Number(1).__proto__ ==== Number.prototype; // true[1,2,3].__proto__ === Array.prototype; // truenew Array(1,2,3).__proto__ === Array.prototype; // truevar obj = &#123;&#125;;obj.__proto__ === Object.prototype; // true (再次印证字面量创建的对象原型是Object.prototype)&#123;&#125;.__proto__ === Object.prototype; //chrome下报错，谁知道原因的告诉声new Object(&#123;&#125;).__proto__ === Object.prototype; // truevar f = function() &#123;&#125;;f.__proto__ === Function.prototype; // truevar f = new Function('&#123;&#125;');f.__proto__ === Function.prototype; // true 3.Object.create(null) 创建出的对象，不存在原型。12var a = Object.create(null); a.__proto__; // undefined 此外，函数的prototype中还有一个constructor方法，建议大家就当它不存在，它的存在让JavaScript原型的概念变得更加混乱，而且这个方法也几乎没有作用。]]></content>
      <categories>
        <category>原型</category>
      </categories>
      <tags>
        <tag>prototype</tag>
        <tag>原型链</tag>
        <tag>原型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS基础01]]></title>
    <url>%2F2016%2F02%2F10%2Fjs%E5%9F%BA%E7%A1%8001%2F</url>
    <content type="text"><![CDATA[介绍输出语句@常用输出语句 代码注释@代码注释//单行注释/ 多行注释 /书写多行注释的时候注意不要发生嵌套/** + 回车 用于函数的说明 书写位置@书写位置可以写在HTML页面内的任意位置或者从外部引用（可以类比样式代码的书写位置） 标签属性@script标签的属性type类型 src 地址async异步加载，加载完成立即执行 defer异步加载，页面上的东西都执行完了才执行（了解即可!!!） 变量变量的命名规范@变量的命名规则(必须遵守)区分大小写不能是关键字和保留字由字母、数字、下划线、$ 组成且开头不能是数字 1234tips:关键字和保留字那么多，记不住怎么办？首先，关键字就是你平时用的那些，而保留字在非严格模式下不能使用的只有：class enum extends super const export import而且，其实如果你使用了关键webstorm是有提示的，但是常见的几个最好还是记住 规范(建议遵守)变量的名称要有实际意义变量的命名遵守驼峰命名法，首字母小写,第二个单词的首字母大写 例如：userName 变量的声明赋值@变量的声明和赋值书写格式 1var 变量名 = 值 练习@交换两个变量的值@不使用第三个变量 弱类型@弱类型JavaScript是弱类型的语言，即声明不同数据类型的变量使用同一个关键字var 数据类型数据类型声明的时候不用考虑类型，但是处理和计算的时候要考虑类型基本数据类型number数值型 string字符串型 boolean布尔型 undefined 未定义 null空复杂数据类型object对象使用typeof关键字可以查看变量的数据类型 数值类型@数值类型字面量 1var num = 数字; 浮点数计算浮点数时会丢失精度我们通常用整数的计算来表示浮点数的计算不要以两个浮点数是否相等作为条件判断的依据（判断范围还是可以的）NaNNaN是数值类型NaN不等于自身 1isNaN( ) 不是有意义的数值返回true 字符串类型@字符串型字面量 1var str = “字符串”; 字符串的长度 12str.lengthlength就是长度的意思 转义符 1\n 换行 \’单引号 \”双引号 \斜杠 字符串的不可变性由于字符串有不可变性，在大量拼接字符串的时候会非常消耗内存。 布尔类型@布尔类型所有类型的值都可以转化成布尔值会转化成false的值有： 空字符串 数值零NaN undefined null undefined类型@undefined表示声明但未赋值的变量 类型转换转换成字符串@转换成字符串将任意类型转化为字符串 1String(值) 大部分类型都有toString方法 1值.toString() 小技巧 1值+”” 转化成数值型@转换成数值将任意类型转化为数值型 1Number(值) 将字符串转化为数值 1parseInt(“字符串”) parseFloat(“字符串”) 小技巧 1值-0 转化成布尔值@转换成布尔值将任意类型转化为布尔值 1Boolean(值) 条件判断中会自动转换 1if(值) 小技巧 1!!值 操作符@运算符 一元运算符@递增和递减递增++ 递减–a++ 先参与运算 后自加++a 先自加 后参与运算 逻辑运算符@逻辑运算符逻辑运算&amp;&amp;和||都采取短路运算，即第一个能够决定结果就不再看第二个了&amp;&amp; 的要求比较严格 要两个都是true才是true 所以看到第一个是false就没有必要继续完后看了 1console.log(false &amp;&amp; 不管了); || 的要求比较宽松 要两个都是false才是false 所以看到第一个是true就没有必要继续完后看了 1console.log(true || 不管了); 短路运算（了解）&amp;&amp;和||不但可以操作布尔类型的值，对其他类型的值也可以进行操作，并返回可以决定表达式结果的那个值。 赋值运算符@赋值运算符 1a+=b 等价于 a=a+b @表达式练习 运算符的优先级尽量记，记不住可以查，或者使用括号 语句选择语句ifif (condition) { statement1 } else if (condition) { statement2 } else { statement3 } @选择语句If 三元表达式1表达式1 ? 表达式2 : 表达式3 @三元表达式 选择语句switchswitch (expression) { case value: statement break; case value: statement break; default: statement } @选择语句switch 循环语句forfor (initialization; expression; post-loop-expression)｛ statement ｝ initialization表示：初始化表达式expression表示：控制表达式post-loop-expression表示：循环后表达式三者都是可选的@循环语句for break和continuebreak跳出当前循环，执行循环后的语句continue跳出当前循环，继续执行循环@break和continue 循环语句whilewhile语句 先判断后执行 1while(expression) statement do while 语句 先执行后判断 1do &#123;statement&#125; while (expression); @循环语句while 数组数组的声明通过构造函数声明（更加通用） 1var arr = new Array("a", "b", "c") 通过字面量声明（更加简便） 1var arr = ["a","b","c"]; 数组的赋值和取值赋值 1数组名[索引号] = 值 //arr[0]=100 取值（通过数组名和索引即可取到对应的值） 1数组名[索引号] //console.log(arr[0]) 数组的遍历（循环 枚举）@数组 数组的索引是从0开始的 数组的长度可以通过arr.length获取 由于数组的索引从0开始，所以最后一个值的索引为arr.length-1 通过for循环遍历数组 123for (var i = 0; i &lt;= arr.length - 1; i++) &#123; console.log(arr[i]); &#125; 可简写为： 123for (var i = 0; i &lt; arr.length; i++) &#123; console.log(arr[i]); &#125; @数组练习 @数组length的应用 往数组中添加新元素，数组的length会增加 通过给arr.length赋值可以改变数组的长度 @数组练习 冒泡排序@冒泡排序 1234567891011121314var arr = [65, 97, 76, 13, 27, 49, 58];//循环控制趟数for (var i = 0; i &lt; arr.length - 1; i++) &#123; //控制两两比较的次数 for (var j = 0; j &lt; arr.length - 1; j++) &#123; //两两比较 从小到大排序 if (arr[j] &gt; arr[j + 1]) &#123; //交换位置 var tmp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = tmp; &#125; &#125;&#125; 函数函数的声明和调用函数的声明123function 函数名 () &#123; //函数体 &#125; 函数的调用 1函数名(); @函数的声明和调用** 函数的参数有参数的函数的声明（声明中的参数只是一个占位符，没有实际的值，是形式参数，即形参）123function 函数名 (参数1,参数2,参数3...) &#123; //函数体&#125; 有参数的函数的调用（调用时传入的参数才是有真正数值的参数，是实际参数，即实参） 1函数名(参数1,参数2,参数3...); @函数的参数 函数的返回值在函数中通过return关键字将要返回值返回 1return 要返回的值; 函数高级概念@参数详解在JS中实参的个数和形参的个数可以不一致@返回值详解函数的返回值是什么，调用这个函数就相当于调用什么，如果没有回值则为undefined函数在执行完成return语句后便会退出函数，后面的代码不会执行@两种定义方式函数声明123function fn1() &#123; //函数体&#125; 函数表达式 var fn2 = function () { //函数体 };@匿名函数匿名函数（没有名字的函数） function () { //函数体 }@递归调用程序调用自身的编程技巧称为递归@回调函数函数也是一种普通的数据类型因此函数也可以被当作参数传递被当作参数传递的函数叫做回调函数 对象从宏观的角度讲，对象是对客观事物的抽象，事物的特征可以用属性表示，事物的行为可以用方法表示从微观的角度讲，对象就是一种数据类型，通过对象可以方便地对变量和函数进行管理初期我们甚至可以把他简单地理解为一个工具箱 1.2.1. 键值对键值对就是一种对应关系，通过键能够方便地找到值 1键:值 key:value k:v 对象的声明通过构造函数声明（更加通用） 1var obj= new Object(); 通过字面量声明（更加简便） 1var obj= &#123;&#125;; 对象具有属性和方法属性 用来描述对象的特征 一般是名词 对应变量方法 用来描述对象的行为 一般是动词 对应函数 属性属性的定义1对象.属性名 = 值 属性的调用1对象.属性名 方法方法的定义 1对象.方法名 = function()&#123; //函数体 &#125; 方法的调用 1对象.方法名() @找对象练习 其他概念对象字面量@对象字面量 var o = { name : “zs”, age : 18, sayHi : function() { console.log(this.name); } }; 对象标记法@对象标记法JavaScript Object Notation（JavaScript对象标记法）是仿照JS中对象字面量的格式去书写的一串用来记录对象数据的字符串，可以用于数据传输。将来学习AJAX会详细学习。 访问属性的两种方式@访问属性的两种方式点语法（简单）1对象.属性名 中括号（灵活）1对象[“属性名”] 遍历的两种方式@遍历的两种方式通过for可以对集合进行有序的遍历通过forin可以对集合进行有序的遍历1for(var k in json) &#123; 语句 &#125; k变量代表的是json中的各个属性（key）和 var i = 0中的i是一个意思 名字不同而已 对象对象的声明和使用通过构造函数声明（更加通用） 1var obj= new Object(); 通过字面量声明（更加简便） 1var obj= &#123;&#125;; 对象具有属性和方法属性 用来描述对象的特征 一般是名词 对应变量方法 用来描述对象的行为 一般是动词 对应函数属性属性的定义 1对象.属性名 = 值 属性的调用 1对象.属性名 方法方法的定义 1对象.方法名 = function()&#123; //函数体 &#125; 方法的调用 1对象.方法名() 关于this的指向全局上下文全局运行上下文中（在任何函数体外部），this 指代全局对象 函数上下文*对象方法中的this指的是该方法所属的对象直接调用中的this指的是全局对象总之，函数上下文中（在函数内部），this指的是当前函数所属的对象 构造函数中当一个函数被作为构造函数使用时（前面加new关键字），new关键字会让this的指向改变，并让其成为当前函数的返回值 批量创建对象工厂模式创建对象为什么要优化创建对象的方式因为对象在项目中被大规模的使用，所以每一点小小的改进都会对项目整体效率带来很大的提升，现阶段同学们还不可能有深刻的体会，只是让大家了解一下，后面讲项目大家自然就明白了。@工厂模式创建对象同类型对象，只是一些属性的值不同，通过对象字面量创建对象每次都要写那么多东西很费劲，我们可以将创建对象的过程封装进一个函数，只把发生变化的属性作为参数传入，从而简化对象创建的过程。但是工厂模式只是创建出来一个普通的对象并将其返回，因此无法判断实例的具体类型。 构造函数创建对象@this和new利用new 关键字可以声明的对象。new 关键字可以让构造函数中this的指向改变，并让构造函数把this返回。@构造函数构造函数也是函数，只不过会默认返回一个对象。 @构造函数创建对象通过构造函数创建对象更方便（不需要创建对象并返回）。更重要的是可以通过instanceof来判断实例的类型了。 基本类型和复杂类型分类基本数据类型（值类型）：直接存储值number、string、boolean、undefined、null（基本类型只有这五个）复杂数据类型（引用类型）：存储引用object 基本类型的复制* 复杂类型的复制 基本类型参数 复杂类型参数@复杂类型参数练习]]></content>
      <categories>
        <category>js基础</category>
      </categories>
      <tags>
        <tag>js基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模块化开发]]></title>
    <url>%2F2016%2F01%2F10%2F%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[在前端开发中，起初只需要在&lt;script&gt;&lt;/script&gt;加入很少的代码来实现一些基本的交互效果，后来随着js得到了越发的重视之后，使得前端项目也变得越来越来复杂，需要更好的组织形式来分类、实现业务逻辑，然而，JavaScript本身是没有类（class）的概念的，当然也就没有模块（module）的概念了。 一个模块就是实现特定功能的文件，有了模块，我们就可以更方便地使用别人的代码，想要什么功能，就加载什么模块。模块开发需要遵循一定的规范，否则就都乱套了。 目前，通行的js模块规范主要有两种：CommonJS和AMD。 根据AMD规范，我们可以使用define定义模块，使用require调用模块。 AMD规范 AMD 即Asynchronous Module Definition，中文名是“异步模块定义”的意思。它是一个在浏览器端模块化开发的规范，服务器端的规范是CommonJS 模块将被异步加载，模块加载不影响后面语句的运行。所有依赖某些模块的语句均放置在回调函数中。 AMD 是 RequireJS 在推广过程中对模块定义的规范化的产出。 define() 函数 AMD规范只定义了一个函数 define，它是全局变量。函数的描述为： 1define(id?, dependencies?, factory); 参数说明： id：指定义中模块的名字，可选；如果没有提供该参数，模块的名字应该默认为模块加载器请求的指定脚本的名字。如果提供了该参数，模块名必须是“顶级”的和绝对的（不允许相对名字）。 依赖dependencies：是一个当前模块依赖的，已被模块定义的模块标识的数组字面量。依赖参数是可选的，如果忽略此参数，它应该默认为[“require”, “exports”, “module”]。然而，如果工厂方法的长度属性小于3，加载器会选择以函数的长度属性指定的参数个数调用工厂方法。 工厂方法factory，模块初始化要执行的函数或对象。如果为函数，它应该只被执行一次。如果是对象，此对象应该为模块的输出值。 模块名的格式 模块名用来唯一标识定义中模块，它们同样在依赖性数组中使用： 模块名是用正斜杠分割的有意义单词的字符串单词须为驼峰形式，或者”.”，”..”模块名不允许文件扩展名的形式，如“.js”模块名可以为 “相对的” 或 “顶级的”。如果首字符为“.”或“..”则为相对的模块名顶级的模块名从根命名空间的概念模块解析相对的模块名从 “require” 书写和调用的模块解析 使用 require 和 exports 创建一个名为”alpha”的模块，使用了require，exports，和名为”beta”的模块: 1234567define("alpha", ["require", "exports", "beta"], function (require, exports, beta) &#123; exports.verb = function() &#123; return beta.verb(); //Or: return require("beta").verb(); &#125; &#125;); require API介绍[AMD规范中文版]https://github.com/amdjs/amdjs-api/wiki/AMD-(%E4%B8%AD%E6%96%87%E7%89%88) 目前，实现AMD的库有RequireJS 、rl 、Dojo 、Nodules 等。 *CommonJS规范 CommonJS是服务器端模块的规范，Node.js采用了这个规范。Node.JS首先采用了js模块化的概念。 根据CommonJS规范，一个单独的文件就是一个模块。每一个模块都是一个单独的作用域，也就是说，在该模块内部定义的变量，无法被其他模块读取，除非定义为global对象的属性。 输出模块变量的最好方法是使用module.exports对象。 123456789var i = 1;var max = 30; module.exports = function () &#123; for (i -= 1; i++ &lt; max; ) &#123; console.log(i); &#125; max *= 1.1;&#125;; 上面代码通过module.exports对象，定义了一个函数，该函数就是模块外部与内部通信的桥梁。 加载模块使用require方法，该方法读取一个文件并执行，最后返回文件内部的module.exports对象。 CommonJS 规范：http://javascript.ruanyifeng.com/nodejs/commonjs.html RequireJS和SeaJS RequireJS由James Burke创建，他也是AMD规范的创始人。 define方法用于定义模块，RequireJS要求每个模块放在一个单独的文件里。 RequireJS 和 Sea.js 都是模块加载器，倡导模块化开发理念，核心价值是让 JavaScript 的模块化开发变得简单自然。 SeaJS与RequireJS最大的区别: SeaJS对模块的态度是懒执行, 而RequireJS对模块的态度是预执行 不明白？看这篇图文并茂的文章吧：http://www.douban.com/note/283566440/ RequireJS API:http://www.requirejs.cn/docs/api.html RequireJS的用法：http://www.ruanyifeng.com/blog/2012/11/require_js.html 为什么要用requireJS 试想一下，如果一个网页有很多的js文件，那么浏览器在下载该页面的时候会先加载js文件，从而停止了网页的渲染，如果文件越多，浏览器可能失去响应。其次，要保证js文件的依赖性，依赖性最大的模块（文件）要放在最后加载，当依赖关系很复杂的时候，代码的编写和维护都会变得困难。 RequireJS就是为了解决这两个问题而诞生的： （1）实现js文件的异步加载，避免网页失去响应；（2）管理模块之间的依赖性，便于代码的编写和维护。 RequireJS文件下载：http://www.requirejs.cn/docs/download.html AMD和CMD CMD（Common Module Definition） 通用模块定义。该规范明确了模块的基本书写格式和基本交互规则。该规范是在国内发展出来的。AMD是依赖关系前置，CMD是按需加载。 在 CMD 规范中，一个模块就是一个文件。代码的书写格式如下： 1define(factory); factory 为函数时，表示是模块的构造方法。执行该构造方法，可以得到模块向外提供的接口。factory 方法在执行时，默认会传入三个参数：require、exports 和 module： 123define(function(require, exports, module) &#123; // 模块代码&#125;); require是可以把其他模块导入进来的一个参数，而export是可以把模块内的一些属性和方法导出的。 CMD规范地址：https://github.com/seajs/seajs/issues/242 AMD 是 RequireJS 在推广过程中对模块定义的规范化产出。CMD 是 SeaJS 在推广过程中对模块定义的规范化产出。 对于依赖的模块，AMD 是提前执行，CMD 是延迟执行。 AMD:提前执行（异步加载：依赖先执行）+延迟执行CMD:延迟执行（运行到需加载，根据顺序执行）CMD 推崇依赖就近，AMD 推崇依赖前置。看如下代码： 1234567891011121314151617// CMDdefine(function(require, exports, module) &#123;var a = require('./a')a.doSomething()// 此处略去 100 行var b = require('./b') // 依赖可以就近书写b.doSomething()// ... &#125;) // AMD 默认推荐的是define(['./a', './b'], function(a, b) &#123; // 依赖必须一开始就写好a.doSomething()// 此处略去 100 行b.doSomething()...&#125;) 另外一个区别是： AMD:API根据使用范围有区别，但使用同一个api接口CMD:每个API的职责单一AMD的优点是：异步并行加载，在AMD的规范下，同时异步加载是不会产生错误的。CMD的机制则不同，这种加载方式会产生错误，如果能规范化模块内容形式，也可以 jquery1.7以上版本会自动模块化，支持AMD模式：主要是使用define函数，sea.js虽然是CommonJS规范，但却使用了define来定义模块所以jQuery已经自动模块化了 123456seajs.config(&#123;'base':'/','alias':&#123; 'jquery':'jquery.js'//定义jQuery文件&#125;&#125;); define函数和AMD的define类似： 1234567define(function(require, exports, module&#123; //先要载入jQuery的模块 var $ = require('jquery'); //然后将jQuery对象传给插件模块 require('./cookie')($); //开始使用 $.cookie方法&#125;); sea.js如何使用？ 引入sea.js的库 如何变成模块？ define 3.如何调用模块？ -exports-sea.js.use4.如何依赖模块？ -require 1234567&lt;script type="text/javascript"&gt; define(function (require,exports,module) &#123; //exports : 对外的接口 //requires : 依赖的接口 require('./test.js');//如果地址是一个模块的话，那么require的返回值就是模块中的exports &#125;)&lt;/script&gt; sea.js 开发实例 123456789101112131415161718192021222324252627&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;&lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt;&lt;title&gt;鼠标拖拽的模块化开发实践&lt;/title&gt;&lt;style type="text/css"&gt;#div1&#123; width:200px; height:200px; background:black; position:absolute; display:none;&#125;#div2&#123; width:30px; height:30px; background:yellow; position:absolute; bottom:0; right:0;&#125;#div3&#123; width:100px; height:100px; background:blue; position:absolute; right:0; top:0;&#125;&lt;/style&gt;&lt;script type="text/javascript" src="./sea.js"&gt;&lt;/script&gt;&lt;script type="text/javascript"&gt; //A同事 ：seajs.use('./main.js'); &lt;/script&gt;&lt;/head&gt; &lt;body&gt;&lt;input type="button" value="确定" id="input1" /&gt;&lt;div id="div1"&gt; &lt;div id="div2"&gt;&lt;/div&gt;&lt;/div&gt;&lt;div id="div3"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; A同事 123456789101112131415161718//A同事写的main.js: define(function (require,exports,module) &#123; var oInput = document.getElementById('input1'); var oDiv1 = document.getElementById('div1'); var oDiv2 = document.getElementById('div2'); var oDiv3 = document.getElementById('div3'); require('./drag.js').drag(oDiv3); oInput.onclick = function () &#123; oDiv1.style.display = 'block'; require('./scale.js').scale(oDiv1,oDiv2); require.async('./scale.js', function (ex) &#123; ex.scale(oDiv1,oDiv2); &#125;) &#125;&#125;); B同事 12345678910111213141516171819202122232425262728293031323334//B同事写的drag.js: define(function(require,exports,module)&#123; function drag(obj)&#123; var disX = 0; var disY = 0; obj.onmousedown = function(ev)&#123; var ev = ev || window.event; disX = ev.clientX - obj.offsetLeft; disY = ev.clientY - obj.offsetTop; document.onmousemove = function(ev)&#123; var ev = ev || window.event; var L = require('./range.js').range(ev.clientX - disX , document.documentElement.clientWidth - obj.offsetWidth , 0 ); var T = require('./range.js').range(ev.clientY - disY , document.documentElement.clientHeight - obj.offsetHeight , 0 ); obj.style.left = L + 'px'; obj.style.top = T + 'px'; &#125;; document.onmouseup = function()&#123; document.onmousemove = null; document.onmouseup = null; &#125;; return false; &#125;; &#125; exports.drag = drag;//对外提供接口 &#125;); C同事 123456789101112131415161718192021222324252627282930313233343536373839//C同事写的scale.js: define(function(require,exports,module)&#123; function scale(obj1,obj2)&#123; var disX = 0; var disY = 0; var disW = 0; var disH = 0; obj2.onmousedown = function(ev)&#123; var ev = ev || window.event; disX = ev.clientX; disY = ev.clientY; disW = obj1.offsetWidth; disH = obj1.offsetHeight; document.onmousemove = function(ev)&#123; var ev = ev || window.event; var W = require('./range.js').range(ev.clientX - disX + disW , 500 , 100); var H = require('./range.js').range(ev.clientY - disY + disH , 500 , 100); obj1.style.width = W + 'px'; obj1.style.height = H + 'px'; &#125;; document.onmouseup = function()&#123; document.onmousemove = null; document.onmouseup = null; &#125;; return false; &#125;; &#125; exports.scale = scale; &#125;); D同事 123456789101112131415161718192021// D同事的range.js--限定拖拽范围 define(function(require,exports,module)&#123; function range(iNum,iMax,iMin)&#123; if( iNum &gt; iMax )&#123; return iMax; &#125; else if( iNum &lt; iMin )&#123; return iMin; &#125; else&#123; return iNum; &#125; &#125; exports.range = range; &#125;); requirejs开发实例 require.config是用来定义别名的，在paths属性下配置别名。然后通过requirejs(参数一，参数二)；参数一是数组，传入我们需要引用的模块名，第二个参数是个回调函数，回调函数传入一个变量，代替刚才所引入的模块。 main.js文件 12345678910//别名配置requirejs.config(&#123; paths: &#123; jquery: 'jquery.min' //可以省略.js &#125;&#125;);//引入模块，用变量$表示jquery模块requirejs(['jquery'], function ($) &#123; $('body').css('background-color','red');&#125;); 引入模块也可以只写require()。requirejs通过define()定义模块，定义的参数上同。在此模块内的方法和变量外部是无法访问的，只有通过return返回才行. define 模块 1234567define(['jquery'], function ($) &#123;//引入jQuery模块 return &#123; add: function(x,y)&#123; return x + y; &#125; &#125;;&#125;); 将该模块命名为math.js保存。 main.js引入模块方法 123require(['jquery','math'], function ($,math) &#123; console.log(math.add(10,100));//110&#125;); 没有依赖 如果定义的模块不依赖其他模块，则可以： 1234567define(function () &#123; return &#123; name: "trigkit4", age: "21" &#125;&#125;); AMD推荐的风格通过返回一个对象做为模块对象，CommonJS的风格通过对module.exports或exports的属性赋值来达到暴露模块对象的目的。]]></content>
      <categories>
        <category>模块化开发</category>
      </categories>
      <tags>
        <tag>模块化开发</tag>
      </tags>
  </entry>
</search>
